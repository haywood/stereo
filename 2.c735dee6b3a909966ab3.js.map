{"version":3,"sources":["webpack:///./src/core/pp.ts","webpack:///./src/web/inputs/index.ts","webpack:///./src/core/data.ts","webpack:///./src/core/pipe/pool.ts","webpack:///./src/core/constants.ts","webpack:///./src/core/fn/interval.ts","webpack:///./src/core/fn/cube.ts","webpack:///./src/core/fn/fn.ts","webpack:///./src/core/fn/rotator.ts","webpack:///./src/core/fn/sphere.ts","webpack:///./src/core/fn/fucked_up_torus.ts","webpack:///./src/core/fn/identity.ts","webpack:///./src/core/fn/spiral.ts","webpack:///./src/core/fn/stereo.ts","webpack:///./src/core/fn/torus.ts","webpack:///./src/core/pipe/resolver.ts","webpack:///./src/core/pipe/pipe.worker.ts","webpack:///./src/core/pipe/grammar.pegjs","webpack:///./src/core/pipe/parser.ts","webpack:///./src/core/pipe/compiler.ts","webpack:///./src/core/pipe/evaluator.ts","webpack:///./src/core/pipe/pipe.ts","webpack:///./src/web/renderer.ts"],"names":["pp","a","p","JSON","stringify","temp","persistenceEnabled","URLSearchParams","window","location","search","get","hash","substr","atob","AbstractInput","constructor","id","_value","persistent","this","has","parse","updateHash","BehaviorSubject","newValue","el","_setup","str","value","set","document","btoa","toString","initFromOrWriteToHash","subject","newSubject","Error","asObservable","oldValue","next","event","TextInput","super","onchange","oninput","size","length","stream","subscribe","text","ToggleInput","disabled","on","querySelector","onclick","off","style","display","test","bool","n","poolSize","inputs","pipe","theta","h","v","animate","mic","fullscreen","fullscreenEnabled","allowedDbs","input","multirange","minEl","maxEl","valueLow","valueHigh","innerText","min","max","split","parseInt","save","action","ev","canvas","renderer","domElement","render","blob","Promise","resolve","toBlob","url","URL","createObjectURL","createElement","download","href","click","revokeObjectURL","debug","Data","d","position","color","buffer","data","Float32Array","nOffset","positionOffset","d0","SharedArrayBuffer","inputOffset","arr","offset","subarray","inputLength","positionLength","colorOffset","i","stride","assert","pool","logger","getLogger","setLevel","navigator","hardwareConcurrency","startPool","info","Pool","spawn","Worker","name","Map","promises","push","queue","all","initialize","params","timing","forkJoin","chunk","w","iterate","getOrInitialize","key","l","getKey","bufferFor","op","Math","round","label","start","Date","now","t","elapsed","runPipeline","ast","Pipe","compile","resolver","Resolver","scopeFor","staticFn","dynamicFn","slice","inf","Interval","b","x","y","equal","limit","fn","nPerLevel","points","pop","successors","domain","pow","Cube","interval","sample","Array","fill","cos","sin","exp","tan","tanh","components","from","keys","CompositeFn","fns","first","rest","apply","domainMax","dMax","last","reduce","f","isFinite","sign","Rotator","d1","f0","f1","cube","r0","r1","Sphere","r","PI","phi","root","map","FuckedUpTorus","sphere","circle","q","Identity","Spiral","k","Stereo","to","fromTemp","toTemp","up","down","n2","norm2","divisor","result","Torus","cross","rotator","scope","node","kind","resolvePipe","resolveFn","resolveAccess","resolveIdToNumber","resolveArith","chain","links","fun","shift","args","link","resolveFirstStep","resolveStep","buildComposites","builder","Builder","isDynamic","add","init","build","type","funs","resolveScalar","some","isNodeDynamic","prev","ranges","arg","resolveId","index","target","idu","toUpperCase","fail","operands","ops","includes","rotate","spiral","torus","fucked_up_torus","stereo","module","exports","peg$SyntaxError","message","expected","found","captureStackTrace","child","parent","ctor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","s","replace","j","descriptions","sort","join","describeExpected","describeFound","SyntaxError","options","peg$result","peg$FAILED","peg$startRuleFunctions","peg$parsepipe","arith","peg$parsearith","peg$startRuleFunction","peg$c0","peg$c1","head","tail","peg$c2","peg$c3","toLowerCase","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$literalExpectation","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","parseFloat","peg$c16","peg$c17","peg$c18","peg$classExpectation","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s3","peg$parseuint","peg$parsepipe_sep","peg$parsechain","peg$parsestep","peg$parseidentifier","peg$parselparen","peg$parsestep_args","peg$parsecomma","peg$parserparen","s2","peg$parsescalar","peg$parse_","substring","peg$parsearith_op","s4","s5","s6","charAt","peg$parsemantissa","peg$parseint","peg$parsefloat","peg$parsenumber","peg$parsefn_args","peg$parse__","setDefaultLevel","loggingParse","expr","err","error","Parser","Compiler","parsePipe","simplifier","simplify","parseArith","simplifyArithNode","Simplifier","substitutions","simplifyStepNode","simplifyScalar","simplifyFnNode","simplifyAccessNode","simplifyIdNode","Evaluator","hv","dynaicFn","iter","computeColors","abs","hsv","hsl","c","Color","g","normalized","compilePipe","evaluatorForNormal","scopeForNormal","compiler","compileHV","power","chroma","onset","compileArith","width","innerWidth","height","innerHeight","aspect","setSize","camera","PerspectiveCamera","z","scene","geometry","forEach","isNaN","console","warn","setAttribute","BufferAttribute","computeBoundingSphere","boundingSphere","center","radius","requestAnimationFrame","WebGLRenderer","onresize","Points","BufferGeometry","PointsMaterial","vertexColors","VertexColors","Scene"],"mappings":"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","file":"2.c735dee6b3a909966ab3.js","sourcesContent":["export const pp = (a: any, p = 2) => JSON.stringify(a, null, p);\n","import multirange from 'multirange';\nimport { BehaviorSubject, Subject } from 'rxjs';\n\nimport { poolSize } from '../../core/pipe/pool';\nimport debug from '../debug';\nimport { renderer } from '../renderer';\n\ntype Change<T> = {\n  newValue: T;\n  oldValue?: T;\n  event?: Event;\n};\n\nconst query = new URLSearchParams(window.location.search);\nconst persistenceEnabled = query.get('p') != '0';\nconst hash = (() => {\n  const temp = window.location.hash.substr(1);\n  return new URLSearchParams(temp ? atob(temp) : '');\n})();\n\nexport abstract class AbstractInput<T, E = HTMLElement> {\n  private readonly subject: Subject<Change<T>>;\n  protected el?: E;\n\n  constructor(\n    readonly id: string,\n    private _value: T,\n    private readonly persistent: boolean,\n  ) {\n    if (persistenceEnabled) {\n      this.initFromOrWriteToHash();\n    } else {\n      this.persistent = false;\n    }\n    this.subject = this.newSubject();\n  }\n\n  initFromOrWriteToHash = () => {\n    if (this.persistent && hash.has(this.id)) {\n      this._value = this.parse(hash.get(this.id));\n    } else if (this.persistent) {\n      this.updateHash();\n    }\n  };\n\n  newSubject = () => new BehaviorSubject({ newValue: this._value });\n\n  setup = (el: E) => {\n    this.el = el;\n    this._setup();\n  };\n\n  protected abstract _setup(): void;\n\n  protected parse(str: string): T {\n    throw new Error('parse unsupported');\n  }\n\n  protected stringify(value: T): string {\n    throw new Error('stringify unsupported');\n  }\n\n  get stream() {\n    return this.subject.asObservable();\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(newValue: T) {\n    const oldValue = this.value;\n    this._value = newValue;\n    this.subject.next({ newValue, oldValue, event: window.event });\n    if (this.persistent) this.updateHash();\n  }\n\n  private updateHash = () => {\n    const str = this.stringify(this.value);\n    hash.set(this.id, str);\n    document.location.hash = btoa(hash.toString());\n  };\n}\n\ntype TextInputId = 'pipe' | 'theta' | 'h' | 'v';\n\nexport class TextInput extends AbstractInput<string, HTMLInputElement> {\n  readonly disabled = false;\n\n  constructor(readonly id: TextInputId, _value: string, persistent = true) {\n    super(id, _value, persistent);\n  }\n\n  protected _setup = () => {\n    this.el.onchange = () => (this.value = this.el.value);\n    this.el.oninput = () => (this.el.size = this.el.value.length);\n\n    this.stream.subscribe(({ newValue }) => {\n      this.el.value = newValue;\n      this.el.size = newValue.length;\n    });\n  };\n\n  protected parse(str: string) {\n    return str;\n  }\n\n  protected stringify(text: string) {\n    return text;\n  }\n}\n\ntype ToggleInputId = 'animate' | 'mic' | 'fullscreen';\n\nexport class ToggleInput extends AbstractInput<boolean> {\n  constructor(\n    readonly id: ToggleInputId,\n    _value: boolean,\n    readonly disabled: boolean = false,\n    persistent = true,\n  ) {\n    super(id, _value, persistent);\n  }\n\n  protected _setup = () => {\n    const on = this.el.querySelector<HTMLInputElement>('.on');\n    on.onclick = () => (this.value = true);\n\n    const off = this.el.querySelector<HTMLInputElement>('.off');\n    off.onclick = () => (this.value = false);\n\n    this.stream.subscribe(({ newValue }) => {\n      if (newValue) {\n        on.style.display = 'none';\n        off.style.display = 'inline';\n      } else {\n        on.style.display = 'inline';\n        off.style.display = 'none';\n      }\n    });\n  };\n\n  protected parse(str: string) {\n    if (/1|true/i.test(str)) return true;\n    else if (/0|false/i.test(str)) return false;\n    else throw new Error(`invalid boolean value for input ${this.id}: ${str}`);\n  }\n\n  protected stringify(bool: boolean) {\n    return bool ? '1' : '0';\n  }\n}\n\ntype RangeInputId = 'allowed_db_range';\n\nexport class RangeInput extends AbstractInput<[number, number]> {\n  constructor(\n    readonly id: RangeInputId,\n    _value: [number, number],\n    readonly disabled: boolean = false,\n    persistent = true,\n  ) {\n    super(id, _value, persistent);\n  }\n\n  protected _setup = () => {\n    const input = this.el.querySelector<MultirangeHTMLInputElement>('input');\n    multirange(input);\n    const minEl = this.el.querySelector<HTMLElement>('.min');\n    const maxEl = this.el.querySelector<HTMLElement>('.max');\n\n    input.onchange = () => {\n      this.value = [+input.valueLow, +input.valueHigh];\n    };\n\n    this.el.querySelector<HTMLInputElement>(\n      'input.ghost',\n    ).oninput = input.oninput = () => {\n      minEl.innerText = input.valueLow.toString();\n      maxEl.innerText = input.valueHigh.toString();\n    };\n\n    this.stream.subscribe(({ newValue }) => {\n      input.value = this.stringify(newValue);\n      minEl.innerText = input.valueLow.toString();\n      maxEl.innerText = input.valueHigh.toString();\n    });\n  };\n\n  protected parse(str: string): [number, number] {\n    const [min, max] = str.split(/,/);\n    return [parseInt(min), parseInt(max)];\n  }\n\n  protected stringify([min, max]) {\n    return `${min},${max}`;\n  }\n}\n\nexport class ActionInput extends AbstractInput<void> {\n  constructor(\n    id: string,\n    private readonly action: (ev: MouseEvent) => void,\n    readonly disabled: boolean = false,\n  ) {\n    super(id, null, false);\n  }\n\n  protected _setup = () => {\n    this.el.onclick = ev => this.action(ev);\n  };\n}\n\n// Points generation is done in parallel, so pick n such\n// that each chunk is size 2000\nconst n = 2000 * poolSize;\n\nexport const inputs = {\n  pipe: new TextInput(\n    'pipe',\n    `${n}->torus(4, 1, 1)->R(theta, 0, 1, cos, tan)->R(theta, 0, 2)->R(theta, 0, 3)->stereo(3)`,\n  ),\n  theta: new TextInput('theta', 'pi * t / 20'),\n  h: new TextInput('h', 'chroma * abs(p[0])'),\n  v: new TextInput('v', 'power'),\n  animate: new ToggleInput('animate', true, false, true),\n  mic: new ToggleInput('mic', false, false, false),\n  fullscreen: new ToggleInput(\n    'fullscreen',\n    false,\n    !document.fullscreenEnabled,\n    false,\n  ),\n  allowedDbs: new RangeInput('allowed_db_range', [-100, -30]),\n  save: new ActionInput('save', async () => {\n    const canvas = renderer.domElement;\n    renderer.render();\n    const blob = await new Promise(resolve => canvas.toBlob(resolve));\n    const url = URL.createObjectURL(blob);\n    try {\n      const a = document.createElement('a');\n      a.download = `stereo${document.location.hash}`;\n      a.href = url;\n      a.click();\n    } finally {\n      URL.revokeObjectURL(url);\n    }\n  }),\n};\nexport type Inputs = typeof inputs;\n\ndebug('inputs', inputs);\n","import assert from 'assert';\n\nexport type Vector = Float32Array;\n\nexport class Data {\n  constructor(\n    readonly n: number,\n    readonly d: number,\n    readonly position: Float32Array,\n    readonly color: Float32Array,\n  ) {}\n\n  static fromBuffer = (buffer: ArrayBuffer) => {\n    const data = new Float32Array(buffer);\n    const n = data[Data.nOffset];\n    const d = data[Data.positionOffset(data)];\n    const position = Data.position(data);\n    const color = Data.color(data);\n    return new Data(n, d, position, color);\n  };\n\n  static bufferFor = (n: number, d0: number, d: number): SharedArrayBuffer => {\n    const bytesPerNum = 4;\n    const count = 3 + n * (d0 + d + 3);\n    const byteLength = bytesPerNum * count;\n    const buffer = new SharedArrayBuffer(byteLength);\n    const data = new Float32Array(buffer);\n    data[Data.nOffset] = n;\n    data[Data.inputOffset] = d0;\n    data[Data.positionOffset(data)] = d;\n    return buffer;\n  };\n\n  static input = (arr: Float32Array) => {\n    const offset = Data.inputOffset + 1;\n    return arr.subarray(offset, offset + Data.inputLength(arr));\n  };\n\n  static position = (arr: Float32Array) => {\n    const offset = Data.positionOffset(arr) + 1;\n    return arr.subarray(offset, offset + Data.positionLength(arr));\n  };\n\n  static color = (arr: Float32Array) => {\n    const offset = Data.colorOffset(arr);\n    return arr.subarray(offset);\n  };\n\n  static nOffset = 0;\n\n  static inputOffset = Data.nOffset + 1;\n  private static inputLength = (arr: Float32Array) => {\n    const n = arr[Data.nOffset];\n    const d0 = arr[Data.inputOffset];\n    return n * d0;\n  };\n\n  static positionOffset = (arr: Float32Array) =>\n    Data.inputOffset + Data.inputLength(arr) + 1;\n  private static positionLength = (arr: Float32Array) => {\n    const n = arr[Data.nOffset];\n    const d = arr[Data.positionOffset(arr)];\n    return n * d;\n  };\n\n  static colorOffset = (arr: Float32Array) =>\n    Data.positionOffset(arr) + Data.positionLength(arr) + 1;\n\n  static get = (arr: Vector, i: number, stride: number) => {\n    const offset = i * stride;\n    return arr.subarray(offset, offset + stride);\n  };\n\n  static set = (\n    arr: Vector,\n    value: ArrayLike<number>,\n    i: number,\n    stride: number,\n  ) => {\n    assert(value.length <= stride);\n    const offset = i * stride;\n    return arr.set(value, offset);\n  };\n}\n","import { spawn, Worker, Pool, ModuleThread } from 'threads';\nimport { getLogger } from 'loglevel';\nimport { Params, PipelineWorker, Chunk } from './types';\nimport { Pipe } from './pipe';\nimport { Data } from '../data';\nimport { Resolver, Resolution } from './resolver';\n\nconst logger = getLogger('PipelinePool');\nlet pool: Pool<ModuleThread<PipelineWorker>>;\nlet data: Map<string, SharedArrayBuffer>;\nlogger.setLevel('info');\n\nexport const poolSize = 2 * navigator.hardwareConcurrency;\n\nexport const startPool = async () => {\n  logger.info('starting worker pool');\n  let i = 0;\n  pool = Pool(\n    () => spawn(new Worker('./pipe.worker', { name: `pipe${i++}` })),\n    poolSize,\n  );\n  data = new Map();\n  let promises = [];\n  for (let i = 0; i < poolSize; i++) {\n    // pre-load scripts so the first task doesn't take forever\n    promises.push(pool.queue(async () => {}));\n  }\n  await Promise.all(promises);\n};\n\nexport const stopPool = async (): Promise<void> => {\n  logger.info('waiting for pending tasks to complete before terminating pool');\n  try {\n    await pool.terminate(true);\n  } catch (err) {\n    logger.error(err);\n  } finally {\n    pool = null;\n  }\n};\n\nconst initialize = (\n  params: Params,\n  n: number,\n  buffer: SharedArrayBuffer,\n): Promise<void> => {\n  return timing('initialization')(async () => {\n    return forkJoin(n, async chunk => {\n      return pool.queue(w => w.initialize(params, chunk, buffer));\n    });\n  });\n};\n\nconst iterate = (params: Params, n: number, buffer: SharedArrayBuffer) => {\n  return timing('iteration')(async () => {\n    return forkJoin(n, async chunk => {\n      return pool.queue(w => w.iterate(params, chunk, buffer));\n    });\n  });\n};\n\nconst getKey = (params: Params) =>\n  JSON.stringify({\n    pipe: params.pipe,\n    theta: params.theta,\n    h: params.h,\n    l: params.v,\n  });\n\nconst getOrInitialize = async (\n  params: Params,\n  n: number,\n  d0: number,\n  d: number,\n): Promise<SharedArrayBuffer> => {\n  const key = getKey(params);\n  if (!data.has(key)) {\n    const buffer = Data.bufferFor(n, d0, d);\n    await initialize(params, n, buffer);\n    data.set(key, buffer);\n  }\n  return data.get(key);\n};\n\nconst forkJoin = async (n: number, op: (chunk: Chunk) => Promise<void>) => {\n  const size = Math.round(n / poolSize);\n  let promises = [];\n  for (let offset = 0; offset < n; offset += size) {\n    const chunk = { offset, size: Math.min(n - offset, size) };\n    promises.push(op(chunk));\n  }\n  await Promise.all(promises);\n};\n\nconst timing = (label: string) => async <T>(op: () => Promise<T>) => {\n  const start = Date.now();\n  const t = await op();\n  const elapsed = Date.now() - start;\n  logger.debug(`${label} took ${elapsed}ms`);\n  return t;\n};\n\nexport const runPipeline = async (\n  params: Params,\n): Promise<SharedArrayBuffer> => {\n  const ast = Pipe.compile(params);\n  const resolver = new Resolver(Pipe.scopeFor(params, ast.n));\n  const { n, staticFn, dynamicFn } = resolver.resolve(ast) as Resolution;\n  const buffer = await getOrInitialize(params, n, staticFn.d, dynamicFn.d);\n  await iterate(params, n, buffer);\n\n  return buffer.slice(0);\n};\n","export const inf = 2 ** 32 - 1;\n","import { Fn } from './fn';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Interval implements Fn {\n  readonly domain: number;\n\n  constructor(readonly d: number, readonly a: number[], readonly b: number[]) {\n    assert.equal(a.length, d);\n    assert.equal(b.length, d);\n    this.domain = d;\n  }\n\n  static nPerLevel = (d: number, n: number) => {\n    return Math.round(Math.pow(n, 1 / d));\n  };\n\n  static n = (d: number, n: number) => Interval.nPerLevel(d, n) ** d;\n\n  /**\n   * @param x A vector of length this.domain contained in the interval [0, 1].\n   * @returns A mapping of the vector into this interval.\n   */\n  fn = (x: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, b, d } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    for (let i = 0; i < d; i++) {\n      y[i] = a[i] + x[i] * (b[i] - a[i]);\n    }\n    return y;\n  };\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const { d, fn } = this;\n    n = Interval.nPerLevel(d, n);\n    const points: number[][] = [[]];\n    let i = 0;\n\n    while (points.length && i < limit) {\n      const p = points.pop()!;\n      if (p.length < d) {\n        points.push(...successors(p));\n      } else if (i++ >= offset) {\n        yield fn(p);\n      }\n    }\n\n    function* successors(p: number[]): Generator<number[]> {\n      for (let i = 0; i < n; i++) {\n        yield [...p, i / n];\n      }\n    }\n  };\n}\n","import Interval from './interval';\nimport { Fn } from './fn';\nimport { Vector } from '../data';\n\nexport default class Cube implements Fn {\n  private readonly interval: Interval;\n\n  constructor(readonly d: number, readonly l: number) {\n    this.interval = new Interval(\n      d,\n      new Array(d).fill(-l / 2),\n      new Array(d).fill(l / 2),\n    );\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  fn = (x: Vector, y?: Vector) => this.interval.fn(x, y);\n\n  sample = (n: number, offset: number, limit: number) =>\n    this.interval.sample(n, offset, limit);\n}\n","import { Vector } from '../data';\nimport assert from 'assert';\nimport { inf } from '../constants';\n\nexport const cos = Math.cos;\nexport const sin = Math.sin;\nexport const tan = Math.tan;\nexport const tanh = Math.tanh;\nexport const exp = Math.exp;\n\nexport const components = d => Array.from(new Array(d).keys());\n\nexport interface Fn {\n  readonly d: number;\n  readonly domain: number;\n  fn(x: Vector, y?: Vector): Vector;\n  sample(n: number, offset: number, limit: number): Generator<Vector>;\n}\n\nexport class CompositeFn implements Fn {\n  private readonly x: Vector;\n  private readonly y: Vector;\n  constructor(readonly fns: Fn[]) {\n    assert(fns.length, 'fns cannot be empty');\n\n    const length = Math.max(this.domainMax, this.dMax);\n    this.x = new Float32Array(length);\n    this.y = new Float32Array(length);\n  }\n\n  get first() {\n    return this.fns[0];\n  }\n\n  get last() {\n    return this.fns[this.fns.length - 1];\n  }\n\n  get domain() {\n    return this.first.domain;\n  }\n\n  get d() {\n    return this.last.d;\n  }\n\n  get domainMax() {\n    return this.fns.reduce((max, f) => Math.max(f.domain, max), 0);\n  }\n\n  get dMax() {\n    return this.fns.reduce((max, f) => Math.max(f.d, max), 0);\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const { fns, d } = this;\n    const [first, ...rest] = fns;\n    if (fns.length == 0) return [];\n\n    for (const x of first.sample(n, offset, limit)) {\n      this.x.set(x);\n      if (rest.length) {\n        CompositeFn.apply(rest, this.x, this.y);\n      } else {\n        this.y.set(x);\n      }\n      yield this.y.subarray(0, d);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { fns, domain, d } = this;\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    this.x.set(x);\n    CompositeFn.apply(fns, this.x, this.y);\n    y.set(this.y.subarray(0, d));\n    return y;\n  };\n\n  private static apply = (fns: Fn[], x: Vector, y: Vector) => {\n    assert.equal(x.length, y.length);\n    for (const f of fns) {\n      f.fn(x.subarray(0, f.domain), y.subarray(0, f.d));\n      x.set(y);\n    }\n    for (let i = 0; i < y.length; i++) {\n      if (!isFinite(y[i])) y[i] = Math.sign(y[i]) * inf;\n    }\n  };\n\n  static Builder = class {\n    private readonly fns: Fn[] = [];\n\n    get d() {\n      return this.last.d;\n    }\n\n    get last() {\n      return this.fns[this.fns.length - 1];\n    }\n\n    add = (fn: Fn) => {\n      const { fns, last } = this;\n      if (last && fn.domain !== last.d) {\n        throw new Error(\n          `Cannot add ${fn} to composite, because its domain is not ${last.d}`,\n        );\n      }\n      fns.push(fn);\n      return this;\n    };\n\n    build = () => {\n      return new CompositeFn(this.fns);\n    };\n  };\n}\n","import { Fn, cos, sin } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Rotator implements Fn {\n  readonly r0: number;\n  readonly r1: number;\n\n  constructor(\n    readonly d: number,\n    readonly theta: number,\n    readonly d0: number,\n    readonly d1: number,\n    readonly f0: (theta: number) => number = cos,\n    readonly f1: (theta: number) => number = sin,\n  ) {\n    this.r0 = f0(theta);\n    this.r1 = f1(theta);\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const p of cube.sample(n, offset, limit)) {\n      yield this.fn(p);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, d0, d1, r0, r1 } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    y.set(x);\n\n    const a = x[d0],\n      b = x[d1];\n    y[d0] = a * r0 - b * r1;\n    y[d1] = a * r1 + b * r0;\n    return y;\n  };\n}\n","import Rotator from './rotator';\nimport Cube from './cube';\nimport { Fn, components, CompositeFn } from './fn';\nimport { TypedArray } from 'three';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Sphere implements Fn {\n  private readonly root: Float32Array;\n\n  constructor(readonly d: number, r: number) {\n    this.root = new Float32Array(d);\n    this.root[0] = r;\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * Math.PI);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, root } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    const r = new CompositeFn(\n      components(d - 1).map(i => new Rotator(d, phi[i], 0, i + 1)),\n    );\n    r.fn(root, y);\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\n// This shape does not implement a torus. It used to,\n// but then I changed the way Rotator works, which\n// changed the way that the points of the sphere are\n// distributed, making the translation step behave incorrectly\n// Still makes a cool shape though, so keeping it\nexport default class FuckedUpTorus implements Fn {\n  private readonly sphere: Sphere;\n  private readonly circle: Sphere;\n\n  constructor(readonly d: number, readonly r: number, readonly t: number) {\n    this.sphere = new Sphere(d, t);\n    this.circle = new Sphere(2, r);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * Math.PI);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { domain, d, sphere, circle } = this;\n    assert.equal(phi.length, domain);\n    assert.equal(y.length, d);\n    sphere.fn(phi, y);\n    const q = circle.fn(phi.subarray(d - 2));\n    y[0] += q[0];\n    y[d - 1] += q[1];\n    return y;\n  };\n}\n","import { Fn } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport class Identity implements Fn {\n  readonly domain: number;\n\n  constructor(readonly d: number) {\n    this.domain = d;\n  }\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    y.set(x);\n    return y;\n  };\n\n  sample = function*(n: number, offset: number, limit: number) {\n    throw new Error('identity function does not support sampling');\n  };\n}\n","import { Fn, exp, components } from './fn';\nimport Cube from './cube';\nimport Sphere from './sphere';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Spiral implements Fn {\n  private readonly sphere: Sphere;\n\n  constructor(readonly d: number, readonly a: number[], readonly k: number[]) {\n    this.sphere = new Sphere(d, 1);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 4 * Math.PI);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, k, domain, d } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    this.sphere.fn(phi, y);\n    let x = 0;\n    for (let i = 0; i < domain; i++) {\n      x += k[i] * phi[i];\n    }\n    const r = exp(x);\n    for (let i = 0; i < d; i++) {\n      y[i] = y[i] * a[i] * r;\n    }\n    return y;\n  };\n}\n","import { Fn } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Stereo implements Fn {\n  private readonly fromTemp: Vector;\n  private readonly toTemp: Vector;\n\n  constructor(private readonly from: number, private readonly to: number) {\n    this.fromTemp = new Float32Array(Math.max(from, to));\n    this.toTemp = new Float32Array(Math.max(from, to));\n  }\n\n  get domain() {\n    return this.from;\n  }\n\n  get d() {\n    return this.to;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.to)) => {\n    let { from, to, fromTemp, toTemp } = this;\n    assert.equal(x.length, from);\n    assert.equal(y.length, to);\n\n    if (from === to) {\n      y.set(x);\n      return y;\n    }\n\n    fromTemp.set(x);\n\n    while (from < to) {\n      Stereo.up(fromTemp.subarray(0, from), toTemp.subarray(0, ++from));\n      fromTemp.set(toTemp);\n    }\n\n    while (from > to) {\n      Stereo.down(fromTemp.subarray(0, from), toTemp.subarray(0, --from));\n      fromTemp.set(toTemp);\n    }\n\n    y.set(toTemp.subarray(0, to));\n    return y;\n  };\n\n  static up = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length + 1);\n    const n2 = norm2(x);\n    const divisor = n2 + 1;\n    temp[0] = (n2 - 1) / divisor;\n    for (let i = 1; i <= x.length; i++) {\n      temp[i] = (2 * x[i - 1]) / divisor;\n    }\n  };\n\n  static down = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length - 1);\n    for (let i = 0; i < temp.length; i++) {\n      temp[i] = x[i + 1] / (1 - x[0]);\n    }\n  };\n}\n\nconst norm2 = (x: Vector) => {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * x[i];\n  }\n  return result;\n};\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport Rotator from './rotator';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Torus implements Fn {\n  private readonly cross: Sphere;\n\n  constructor(readonly d: number, readonly r: number, readonly t: number) {\n    assert(d > 2, `torus is only defined for d > 2; got ${d}`);\n    this.cross = new Sphere(d - 1, t);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * Math.PI);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (theta: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { cross, d, r } = this;\n    assert.equal(\n      theta.length,\n      d - 1,\n      `torus expects an input of ${d - 1}; got ${theta.length}`,\n    );\n    const rotator = new Rotator(d, theta[d - 2], 0, d - 1);\n\n    cross.fn(theta.subarray(0, d - 2), y.subarray(0, d - 1));\n    y[0] += r;\n    rotator.fn(y, y);\n\n    return y;\n  };\n}\n","import assert from 'assert';\n\nimport Cube from '../fn/cube';\nimport { CompositeFn, Fn } from '../fn/fn';\nimport FuckedUpTorus from '../fn/fucked_up_torus';\nimport { Identity } from '../fn/identity';\nimport Interval from '../fn/interval';\nimport Rotator from '../fn/rotator';\nimport Sphere from '../fn/sphere';\nimport Spiral from '../fn/spiral';\nimport Stereo from '../fn/stereo';\nimport Torus from '../fn/torus';\nimport { pp } from '../pp';\n\nimport {\n  AccessNode,\n  ArithNode,\n  FnNode,\n  NumberNode,\n  PipeNode,\n  Scalar,\n  StepNode,\n  Value,\n} from './ast';\nimport { Link, Scope, UnaryOperator } from './types';\n\nexport type Resolution = {\n  n: number;\n  staticFn: CompositeFn;\n  dynamicFn: CompositeFn;\n};\n\nexport class Resolver {\n  constructor(private readonly scope: Scope) {}\n\n  resolve = (node: PipeNode | Scalar) => {\n    switch (node.kind) {\n      case 'pipe':\n        return this.resolvePipe(node);\n      case 'number':\n        return node.value;\n      case 'fn':\n        return this.resolveFn(node);\n      case 'access':\n        return this.resolveAccess(node);\n      case 'id':\n        return this.resolveIdToNumber(node.id);\n      case 'arith':\n        return this.resolveArith(node);\n    }\n  };\n\n  resolvePipe = (pipe: PipeNode): Resolution => {\n    const chain = pipe.chain;\n    const links: Link[] = [];\n    const fun = chain.shift();\n    const d = (fun.args.shift() as NumberNode).value;\n    const link = this.resolveFirstStep(d, fun);\n    const n = Interval.n(link.fn.domain, pipe.n);\n\n    links.push(link);\n\n    for (let i = 0; i < chain.length; i++) {\n      const fun = chain[i];\n      const link = this.resolveStep(links[i].fn, fun);\n      links.push(link);\n    }\n\n    const [staticFn, dynamicFn] = this.buildComposites(links);\n    return { n, staticFn, dynamicFn };\n  };\n\n  private buildComposites = (links: Link[]) => {\n    let builder = new CompositeFn.Builder();\n    while (links.length && !links[0].isDynamic) {\n      builder.add(links.shift().fn);\n    }\n\n    const init = builder.build();\n    builder = new CompositeFn.Builder().add(new Identity(init.d));\n\n    while (links.length) {\n      builder.add(links.shift().fn);\n    }\n\n    const iter = builder.build();\n    return [init, iter];\n  };\n\n  private resolveFirstStep = (d: number, { type, args }: StepNode) => {\n    const fn = funs[type](d, ...args.map(a => this.resolveScalar(a)));\n    const isDynamic = args.some(isNodeDynamic);\n\n    return { fn, isDynamic };\n  };\n\n  private resolveStep = (prev: Fn, { type, args }: StepNode): Link => {\n    const d = ranges[type](prev.d);\n    const fn = funs[type](d, ...args.map(a => this.resolveScalar(a)));\n    const isDynamic = args.some(isNodeDynamic);\n\n    return { fn, isDynamic };\n  };\n\n  private resolveScalar = (arg: Scalar): Value => {\n    switch (arg.kind) {\n      case 'number':\n        return arg.value;\n      case 'fn':\n        return this.resolveFn(arg);\n      case 'access':\n        return this.resolveAccess(arg);\n      case 'id':\n        return this.resolveId(arg.id);\n      case 'arith':\n        return this.resolveArith(arg);\n    }\n  };\n\n  private resolveFn = ({ name, args }: FnNode): number => {\n    const fn = Math[name];\n    assert(\n      typeof fn === 'function',\n      `Expected ${name} to be a Math function in ${pp({ name, args })}`,\n    );\n    return fn(...args.map(a => this.resolveScalar(a)));\n  };\n\n  private resolveAccess = ({ id, index }: AccessNode): number => {\n    const scope = this.scope;\n    const target = scope[id];\n    assert(target, `Unable to resolve ${id} in scope ${pp(scope, 2)}`);\n    return target[this.resolveScalar(index) as number];\n  };\n\n  private resolveId = (id: string): Value => {\n    if (id in this.scope) {\n      return this.scope[id];\n    } else if (id in Math) {\n      return Math[id];\n    } else {\n      const idu = id.toUpperCase();\n      if (idu in Math) return Math[idu];\n    }\n\n    assert.fail(`unable to resolve id ${id} in scope ${pp(this.scope, 2)}`);\n  };\n\n  private resolveIdToNumber = (id: string): number => {\n    const value = this.resolveId(id);\n    assert.equal(\n      typeof value,\n      'number',\n      `id ${id} resolved to ${value} but a number was expected`,\n    );\n    return value as number;\n  };\n\n  private resolveArith = ({ op, operands }: ArithNode) => {\n    const [a, b] = operands.map(a => this.resolveScalar(a));\n    if (typeof a === 'number' && typeof b === 'number') {\n      return ops[op](a, b);\n    }\n    assert.fail(\n      `One or more arithmetic operands evaluate to a non-number in ${pp(\n        { op, operands },\n        2,\n      )}`,\n    );\n  };\n}\n\nconst isNodeDynamic = (node: Scalar): boolean => {\n  switch (node.kind) {\n    case 'fn':\n      return node.args.some(isNodeDynamic);\n    case 'id':\n      return ['t', 'power', 'chroma', 'onset'].includes(node.id);\n    case 'arith':\n      return node.operands.some(isNodeDynamic);\n    default:\n      return false;\n  }\n};\n\nconst ops: { [op: string]: (a: number, b: number) => number } = {\n  '+': (a, b) => a + b,\n  '-': (a, b) => a - b,\n  '*': (a, b) => a * b,\n  '/': (a, b) => a / b,\n  '**': (a, b) => a ** b,\n  '^': (a, b) => a ** b,\n};\n\nconst rotate = (\n  d: number,\n  theta: number,\n  d0: number,\n  d1: number,\n  f0: UnaryOperator = Math.cos,\n  f1: UnaryOperator = Math.sin,\n) => {\n  return new Rotator(d, theta, d0, d1, f0, f1);\n};\n\nconst funs: { [op: string]: (d: number, ...rest) => Fn } = {\n  cube: (d, l) => new Cube(d, l),\n  sphere: (d, r: number) => new Sphere(d, r),\n  spiral: (d, a: number, k: number) =>\n    new Spiral(d, new Array(d).fill(a), new Array(d - 1).fill(k)),\n  torus: (d, r: number, t: number) => new Torus(d, r, t),\n  fucked_up_torus: (d, r: number, t: number) => new FuckedUpTorus(d, r, t),\n  rotate,\n  r: rotate,\n  stereo: (d, to) => new Stereo(d, to),\n};\n\ntype Funs = typeof funs;\n\ntype Ranges = {\n  [P in keyof Funs]: (domain: number) => number;\n};\n\nconst ranges: Ranges = {\n  cube: domain => domain,\n  sphere: domain => domain + 1,\n  spiral: domain => domain + 1,\n  torus: domain => domain + 1,\n  fucked_up_torus: domain => domain + 1,\n  rotate: domain => domain,\n  r: domain => domain,\n  stereo: domain => domain,\n};\n","module.exports = __webpack_public_path__ + \"0.53dab15f94a37c340dda.worker.js\"","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { pipe: peg$parsepipe, arith: peg$parsearith },\n      peg$startRuleFunction  = peg$parsepipe,\n\n      peg$c0 = function(n, chain) {\n        return {kind: 'pipe', n: parseInt(n), chain};\n      },\n      peg$c1 = function(head, tail) { return [head, ...tail]; },\n      peg$c2 = function(f) { return [f]; },\n      peg$c3 = function(type, args) {\n          return {kind: 'step', type: type.toLowerCase(), args};\n        },\n      peg$c4 = function(arg) { return [arg]; },\n      peg$c5 = function(s, op, a) {\n           return {kind: 'arith', op, operands: [s, a]};\n        },\n      peg$c6 = function(value) { return {kind: 'number', value}; },\n      peg$c7 = function(name, args) {\n          return {kind: 'fn', name: name.toLowerCase(), args};\n        },\n      peg$c8 = \"[\",\n      peg$c9 = peg$literalExpectation(\"[\", false),\n      peg$c10 = \"]\",\n      peg$c11 = peg$literalExpectation(\"]\", false),\n      peg$c12 = function(id, index) { return {kind: 'access', id, index}; },\n      peg$c13 = function(id) { return {kind: 'id', id: id.toLowerCase()}; },\n      peg$c14 = function(a) { return a; },\n      peg$c15 = function(f) { return parseFloat(f); },\n      peg$c16 = function(i) { return parseInt(i); },\n      peg$c17 = /^[a-zA-Z]/,\n      peg$c18 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n      peg$c19 = /^[a-zA-Z0-9]/,\n      peg$c20 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n      peg$c21 = function(id) { return id; },\n      peg$c22 = /^[+\\-]/,\n      peg$c23 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c24 = /^[0-9]/,\n      peg$c25 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c26 = /^[eE]/,\n      peg$c27 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c28 = \".\",\n      peg$c29 = peg$literalExpectation(\".\", false),\n      peg$c30 = \"+\",\n      peg$c31 = peg$literalExpectation(\"+\", false),\n      peg$c32 = \"-\",\n      peg$c33 = peg$literalExpectation(\"-\", false),\n      peg$c34 = \"*\",\n      peg$c35 = peg$literalExpectation(\"*\", false),\n      peg$c36 = \"/\",\n      peg$c37 = peg$literalExpectation(\"/\", false),\n      peg$c38 = \"**\",\n      peg$c39 = peg$literalExpectation(\"**\", false),\n      peg$c40 = \"^\",\n      peg$c41 = peg$literalExpectation(\"^\", false),\n      peg$c42 = function(op) { return op; },\n      peg$c43 = \"(\",\n      peg$c44 = peg$literalExpectation(\"(\", false),\n      peg$c45 = \")\",\n      peg$c46 = peg$literalExpectation(\")\", false),\n      peg$c47 = \",\",\n      peg$c48 = peg$literalExpectation(\",\", false),\n      peg$c49 = \"->\",\n      peg$c50 = peg$literalExpectation(\"->\", false),\n      peg$c51 = \"=>\",\n      peg$c52 = peg$literalExpectation(\"=>\", false),\n      peg$c53 = /^[ \\t\\n\\r]/,\n      peg$c54 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepipe() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseuint();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsechain() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestep();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestep();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestep() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselparen();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestep_args();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserparen();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestep_args() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsearith();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestep_args();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsearith();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsescalar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsearith_op();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsearith();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c5(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsescalar();\n    }\n\n    return s0;\n  }\n\n  function peg$parsescalar() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c6(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseidentifier();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselparen();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefn_args();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parserparen();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c7(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseidentifier();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s2 = peg$c8;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c9); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsescalar();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s4 = peg$c10;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c11); }\n              }\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c12(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseidentifier();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1);\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parselparen();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsearith();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parserparen();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c14(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefn_args() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsearith();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefn_args();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsearith();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefloat();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseint();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c16(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        if (peg$c19.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c20); }\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          if (peg$c19.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c20); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c21(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloat() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c22.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c24.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsemantissa();\n        if (s4 !== peg$FAILED) {\n          if (peg$c26.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c27); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseint();\n            if (s6 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5, s6];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseint();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemantissa();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseint() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c22.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseuint() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c24.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c25); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c24.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c25); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemantissa() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c28;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith_op() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s3 = peg$c30;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s3 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s3 = peg$c32;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c33); }\n        }\n        if (s3 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s3 = peg$c34;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c35); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c36;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s3 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c38) {\n                s3 = peg$c38;\n                peg$currPos += 2;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c39); }\n              }\n              if (s3 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 94) {\n                  s3 = peg$c40;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c41); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c42(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c43;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 41) {\n        s2 = peg$c45;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c46); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c47;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepipe_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c49) {\n        s3 = peg$c49;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c51) {\n            s3 = peg$c51;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c53.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c54); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c53.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c54); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c53.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c54); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c53.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","import { parse } from './grammar.pegjs';\nimport { PipeNode, ArithNode } from './ast';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\n\nconst logger = getLogger('Parser');\nlogger.setDefaultLevel('info');\n\ntype Options = {\n  startRule: 'arith';\n};\n\nconst loggingParse: typeof parse = <T>(expr: string, options?: Options): T => {\n  try {\n    const node = parse(expr, options);\n    logger.debug(`parsed ${expr} into node ${pp(node)}`);\n    return node;\n  } catch (err) {\n    logger.error(\n      `error parsing ${expr} at ${pp(err.location)}: ${err.message}`,\n    );\n    throw err;\n  }\n};\n\nexport class Parser {\n  static parsePipe = (pipe: string): PipeNode => loggingParse(pipe);\n\n  static parseArith = (expr: string): ArithNode =>\n    loggingParse(expr, { startRule: 'arith' });\n}\n","import { NormalizedParams } from './types';\nimport { Parser } from './parser';\nimport {\n  PipeNode,\n  ArithNode,\n  Scalar,\n  StepNode,\n  FnNode,\n  IdNode,\n  AccessNode,\n} from './ast';\n\nexport class Compiler {\n  private readonly simplifier: Simplifier;\n\n  constructor(params: NormalizedParams) {\n    this.simplifier = new Simplifier({\n      theta: Parser.parseArith(params.theta),\n    });\n  }\n\n  compilePipe = (expr: string): PipeNode => {\n    const ast = Parser.parsePipe(expr);\n    return this.simplifier.simplify(ast);\n  };\n\n  compileArith = (expr: string): ArithNode => {\n    const ast = Parser.parseArith(expr);\n    return this.simplifier.simplifyArithNode(ast);\n  };\n}\n\ntype Substitutions = {\n  [id: string]: Scalar;\n};\n\nexport class Simplifier {\n  constructor(private readonly substitutions: Substitutions) {}\n\n  simplify = (pipe: PipeNode): PipeNode => {\n    const n = pipe.n;\n    const chain = pipe.chain;\n\n    return {\n      kind: pipe.kind,\n      n,\n      chain: chain.map(this.simplifyStepNode),\n    };\n  };\n\n  simplifyArithNode = ({ kind, op, operands }: ArithNode): ArithNode => {\n    const [a, b] = operands.map(this.simplifyScalar);\n    return { kind, op, operands: [a, b] };\n  };\n\n  private simplifyStepNode = ({ kind, type: fn, args }: StepNode): StepNode => {\n    return {\n      kind,\n      type: fn,\n      args: args.map(this.simplifyScalar),\n    };\n  };\n\n  private simplifyScalar = (node: Scalar): Scalar => {\n    switch (node.kind) {\n      case 'number':\n        return node;\n      case 'fn':\n        return this.simplifyFnNode(node);\n      case 'access':\n        return this.simplifyAccessNode(node);\n      case 'id':\n        return this.simplifyIdNode(node);\n      case 'arith':\n        return this.simplifyArithNode(node);\n    }\n  };\n\n  private simplifyFnNode = ({ kind, name, args }: FnNode): FnNode => {\n    return {\n      kind,\n      name,\n      args: args.map(this.simplifyIdNode),\n    };\n  };\n\n  private simplifyAccessNode = ({\n    kind,\n    id,\n    index,\n  }: AccessNode): AccessNode => {\n    return { kind, id, index: this.simplifyScalar(index) };\n  };\n\n  private simplifyIdNode = (node: IdNode): Scalar => {\n    const { id } = node;\n    if (id in this.substitutions) {\n      return this.simplifyScalar(this.substitutions[id]);\n    } else {\n      return node;\n    }\n  };\n}\n","import assert from 'assert';\nimport { hsv } from 'color-convert';\nimport { getLogger } from 'loglevel';\nimport { Color } from 'three';\n\nimport { inf } from '../constants';\nimport { Data, Vector } from '../data';\nimport { CompositeFn } from '../fn/fn';\nimport { pp } from '../pp';\n\nimport { PipeNode } from './ast';\nimport { Resolution, Resolver } from './resolver';\nimport { Chunk, HV, Scope } from './types';\n\nconst logger = getLogger('Evaluator');\n\nexport class Evaluator {\n  private readonly n: number;\n  private readonly staticFn: CompositeFn;\n  private readonly dynaicFn: CompositeFn;\n  private readonly offset: number;\n  private readonly limit: number;\n  private readonly resolver: Resolver;\n\n  constructor(\n    private readonly scope: Scope,\n    ast: PipeNode,\n    private readonly hv: HV,\n    chunk: Chunk,\n  ) {\n    const resolver = new Resolver(scope);\n    const { n, staticFn, dynamicFn } = resolver.resolve(ast) as Resolution;\n    const offset = chunk.offset;\n    const size = chunk.size;\n    const limit = offset + size;\n    assert(offset >= 0, `offset must be non-negative; got ${offset}`);\n    assert(\n      limit <= n,\n      `offset + size must be <= n; got ${offset} + ${size} = ${limit} > ${n}`,\n    );\n\n    this.n = n;\n    this.staticFn = staticFn;\n    this.dynaicFn = dynamicFn;\n    this.offset = offset;\n    this.limit = limit;\n    this.resolver = resolver;\n  }\n\n  private get d() {\n    return this.dynaicFn.d;\n  }\n\n  initialize = (buffer: SharedArrayBuffer): void => {\n    const data = new Float32Array(buffer);\n    const { n, staticFn: init, offset, limit } = this;\n    const input = Data.input(data);\n    let i = offset;\n    for (const y of init.sample(n, offset, limit)) {\n      Data.set(input, y, i++, init.d);\n    }\n  };\n\n  iterate = (buffer: SharedArrayBuffer): void => {\n    const data = new Float32Array(buffer);\n    const { staticFn: init, dynaicFn: iter, scope, n, offset, limit } = this;\n    const input = Data.input(data);\n    const position = Data.position(data);\n    const start = Date.now();\n\n    assert.equal(data[Data.nOffset], n, `n(data) != n(evaluator)`);\n    assert.equal(data[Data.inputOffset], init.d, `d0(data) != d0(evaluator)`);\n    assert.equal(\n      data[Data.positionOffset(data)],\n      iter.d,\n      'd(data) != d(evaluator)',\n    );\n\n    logger.debug(`iterating using ${pp(scope)}, ${pp(iter)}`);\n    for (let i = offset; i < limit; i++) {\n      iter.fn(Data.get(input, i, init.d), Data.get(position, i, iter.d));\n    }\n\n    this.computeColors(data);\n\n    logger.debug(`iteration complete in ${Date.now() - start}ms`);\n  };\n\n  private computeColors = (data: Vector) => {\n    logger.debug(`computing colors`);\n    const { d, hv, offset, limit, resolver } = this;\n    const position = Data.position(data);\n    const color = Data.color(data);\n\n    this.scope.max = position.reduce((max, p) => Math.max(max, Math.abs(p)), 0);\n\n    for (let i = offset; i < limit; i++) {\n      const p = Data.get(position, i, d);\n      this.scope.p = p;\n      this.scope.i = i;\n      const [h, s, l] = hsv.hsl([\n        Math.round(resolver.resolve(hv.h) as number),\n        100,\n        Math.round(resolver.resolve(hv.v) as number),\n      ]);\n      const c = new Color(`hsl(${h}, ${s}%, ${l}%)`);\n\n      Data.set(color, [c.r, c.g, c.b], i, 3);\n    }\n  };\n}\n","import { getLogger } from 'loglevel';\nimport { Params, NormalizedParams, HV, Chunk } from './types';\nimport { Compiler } from './compiler';\nimport { Evaluator } from './evaluator';\nimport { PipeNode } from './ast';\nimport { inf } from '../constants';\n\nconst logger = getLogger('Pipe');\nlogger.setLevel('info');\n\nexport class Pipe {\n  static compile = (params: Params): PipeNode => {\n    return new Compiler(Pipe.normalized(params)).compilePipe(params.pipe);\n  };\n\n  static evaluatorFor = (params: Params, chunk?: Chunk) => {\n    return Pipe.evaluatorForNormal(Pipe.normalized(params), chunk);\n  };\n\n  static scopeFor = (params: Params, n: number) => {\n    return Pipe.scopeForNormal(Pipe.normalized(params), n);\n  };\n\n  private static evaluatorForNormal = (\n    params: NormalizedParams,\n    chunk?: Chunk,\n  ) => {\n    const compiler = new Compiler(params);\n    const ast = compiler.compilePipe(params.pipe);\n    const hv = Pipe.compileHV(params, compiler);\n    return new Evaluator(Pipe.scopeForNormal(params, ast.n), ast, hv, chunk);\n  };\n\n  private static normalized = (params: Params): NormalizedParams => {\n    return {\n      pipe: params.pipe,\n      theta: params.theta || 't',\n      h: params.h || '1',\n      v: params.v || '0.5',\n      t: params.t || 0,\n      power: params.power || 0,\n      chroma: params.chroma || 0,\n      onset: params.onset || 0,\n    };\n  };\n\n  private static scopeForNormal = (params: NormalizedParams, n: number) => {\n    const { power, t, chroma, onset } = params;\n    return { t, power, chroma, n, inf, onset };\n  };\n\n  private static compileHV = (\n    params: NormalizedParams,\n    compiler: Compiler,\n  ): HV => {\n    return {\n      h: compiler.compileArith(`359 * (${params.h})`),\n      v: compiler.compileArith(`100 * (${params.v})`),\n    };\n  };\n}\n","import {\n  PerspectiveCamera,\n  BufferGeometry,\n  BufferAttribute,\n  Points,\n  PointsMaterial,\n  WebGLRenderer,\n  VertexColors,\n  Scene,\n} from 'three';\nimport { Data } from '../core/data';\nimport assert from 'assert';\n\nclass Renderer {\n  private renderer: WebGLRenderer;\n  private scene: Scene;\n  private camera: PerspectiveCamera;\n  private points: Points;\n  private z = 5;\n\n  constructor() {\n    this.renderer = new WebGLRenderer();\n    this.setSize();\n    window.onresize = () => {\n      this.setSize();\n      requestAnimationFrame(this.render);\n    };\n\n    this.points = new Points(\n      new BufferGeometry(),\n      new PointsMaterial({\n        vertexColors: VertexColors,\n        size: 0.001,\n      }),\n    );\n\n    this.scene = new Scene();\n    this.scene.add(this.points);\n  }\n\n  private setSize = () => {\n    const near = 0.01,\n      far = 1000;\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const aspect = width / height;\n    const fov = 100;\n\n    this.renderer.setSize(width, height);\n    this.camera = new PerspectiveCamera(fov, aspect, near, far);\n    this.camera.position.z = this.z;\n  };\n\n  get domElement() {\n    return this.renderer.domElement;\n  }\n\n  render = () => {\n    this.renderer.render(this.scene, this.camera);\n  };\n\n  update = ({ d, position, color }: Data) => {\n    const { points } = this;\n    const geometry = points.geometry as BufferGeometry;\n    assert.equal(position.length % d, 0);\n    assert.equal(color.length % 3, 0);\n\n    position.forEach((p, i) => {\n      if (isNaN(p)) {\n        console.warn(`found NaN value at index ${i}`);\n      }\n    });\n\n    geometry.setAttribute('position', new BufferAttribute(position, d));\n    geometry.setAttribute('color', new BufferAttribute(color, 3));\n\n    let z = 5;\n    if (d > 2) {\n      geometry.computeBoundingSphere();\n      const s = geometry.boundingSphere;\n      z = Math.min(5, s.center.z + s.radius + 1);\n    }\n    this.camera.position.z = this.z = z;\n\n    requestAnimationFrame(this.render);\n  };\n}\n\nexport const renderer = new Renderer();\n"],"sourceRoot":""}