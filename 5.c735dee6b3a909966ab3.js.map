{"version":3,"sources":["webpack:///./src/web/audio/constants.ts","webpack:///./src/web/audio/spectrum.ts","webpack:///./src/web/error.ts","webpack:///./src/web/audio/graph.ts","webpack:///./src/web/audio/index.ts","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/Action.js","webpack:///./node_modules/rxjs/_esm5/internal/Scheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/async.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/interval.js","webpack:///./src/web/constants.ts","webpack:///./src/web/params.ts","webpack:///./node_modules/rxjs/_esm5/internal/util/isNumeric.js","webpack:///./src/web/data.ts","webpack:///./src/web/audio/power.worklet.ts"],"names":["NO_AUDIO","power","chroma","onset","binCount","octaveCount","Spectrum","constructor","dbMin","dbMax","k","Math","floor","octave","pow","error","err","Error","log","pp","AudioGraph","ctx","source","subject","this","close","AudioWorkletNode","numberOfInputs","channelCountMode","channelCount","port","onmessage","msg","next","data","onprocessorerror","inputs","mic","value","connect","destination","allowedDbs","stream","subscribe","newValue","min","max","parameters","get","setValueAtTime","currentTime","f","filter","BiquadFilterNode","type","frequency","Q","mediaStream","AudioContext","audioWorklet","addModule","processorUrl","MediaStreamAudioSourceNode","graph","logger","getLogger","BehaviorSubject","audioStream","asObservable","event","info","navigator","mediaDevices","getUserMedia","audio","create","_super","AsyncAction","scheduler","work","_this","call","pending","prototype","schedule","state","delay","closed","id","recycleAsyncId","requestAsyncId","setInterval","flush","bind","clearInterval","execute","_execute","errored","errorValue","undefined","e","unsubscribe","_unsubscribe","actions","index","indexOf","splice","Action","Scheduler","SchedulerAction","now","Date","AsyncScheduler","delegate","active","scheduled","action","push","shift","dispatch","subscriber","counter","period","fftSize","params","t","pipe","theta","h","v","paramsStream","count","a","val","isArray","parseFloat","Observable","add","animate","setDefaultLevel","Subject","dataStream","webWorkerSource","console","startPool","getData","runPipeline","then","Data","fromBuffer","inFlight","logged","debug","module","exports"],"mappings":"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","file":"5.c735dee6b3a909966ab3.js","sourcesContent":["import { Audio } from \"./types\";\n\n/**\n * This defines the values used for power and chroma when audio is not enabled.\n */\nexport const NO_AUDIO: Audio = {\n    power: 1,\n    chroma: 0.5,\n    onset: 1,\n};\n\nexport const chromaCount = 12;\nexport const octaveMin = 0;\nexport const octaveMax = 8;\nexport const octaveCount = octaveMax - octaveMin;\nexport const frameSize = 128;\nexport const binCount = octaveCount * chromaCount;\n","import { chromaCount } from './constants';\n\nexport class Spectrum {\n  constructor(public dbMin: number, public dbMax: number) {}\n\n  static octave = (k: number) => Math.floor(k / chromaCount);\n\n  static chroma = (k: number) => k % chromaCount;\n\n  static f = (k: number): number => {\n    const octave = Spectrum.octave(k);\n    const chroma = Spectrum.chroma(k);\n    const c0 = 16.35; // c0 per https://pages.mtu.edu/~suits/notefreqs.html\n\n    return c0 * 2 ** octave * Math.pow(2, 1 / chromaCount) ** chroma;\n  };\n}\n","import { pp } from '../core/pp';\nimport * as log from 'loglevel';\n\nexport const error = async (err: any) => {\n  if (err instanceof Error) {\n    log.error(err);\n  } else {\n    log.error(pp(err));\n  }\n};\n","import { Subject } from \"rxjs\";\nimport { Audio } from './types';\nimport { Spectrum } from \"./spectrum\";\nimport { binCount } from \"./constants\";\nimport processorUrl from './power.worklet';\nimport { error } from '../error';\nimport { inputs } from \"../inputs\";\n\nexport class AudioGraph {\n\n    static create = async (mediaStream: MediaStream, subject: Subject<Audio>) => {\n        const ctx = new AudioContext();\n        await ctx.audioWorklet.addModule(processorUrl);\n        const source = new MediaStreamAudioSourceNode(ctx, { mediaStream });\n        return new AudioGraph(ctx, source, subject);\n    };\n\n    constructor(\n        private readonly ctx: AudioContext,\n        source: AudioNode,\n        subject: Subject<Audio>,\n    ) {\n        const power = new AudioWorkletNode(ctx, 'power', {\n            numberOfInputs: binCount,\n            channelCountMode: 'explicit',\n            channelCount: 1,\n        });\n        power.port.onmessage = (msg) => subject.next(msg.data as Audio);\n        power.onprocessorerror = (err) => {\n            error(err);\n            // processor dies after an error, so close the graph\n            inputs.mic.value = false;\n        };\n        power.connect(ctx.destination);\n        inputs.allowedDbs.stream.subscribe(({ newValue: [min, max] }) => {\n            power.parameters.get('dbMin').setValueAtTime(min, ctx.currentTime);\n            power.parameters.get('dbMax').setValueAtTime(max, ctx.currentTime);\n        });\n\n        for (let k = 0; k < binCount; k++) {\n            const f = Spectrum.f(k);\n            const filter = new BiquadFilterNode(ctx, {\n                type: 'bandpass',\n                frequency: f,\n                Q: binCount / f,\n            });\n            source.connect(filter).connect(power, 0, k);\n        }\n    }\n\n    close = () => this.ctx.close();\n}\n","import { BehaviorSubject, interval, Observable } from 'rxjs';\nimport { getLogger } from 'loglevel';\nimport { inputs } from '../inputs';\nimport { Audio } from './types';\nimport { NO_AUDIO } from './constants';\nimport { AudioGraph } from './graph';\n\nconst logger = getLogger('Audio');\n\nconst subject = new BehaviorSubject<Audio>(NO_AUDIO);\nexport const audioStream = subject.asObservable();\nlet graph: AudioGraph;\n\ninputs.mic.stream.subscribe(async ({ newValue, event }) => {\n    if (newValue) {\n        logger.info('getting user media');\n        const stream = await navigator.mediaDevices\n            .getUserMedia({ audio: true });\n        logger.info('starting new audio graph');\n        graph = await AudioGraph.create(stream, subject);\n    } else {\n        logger.info('closing audio graph');\n        if (graph) await graph.close();\n        subject.next(NO_AUDIO);\n    }\n});\n","/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Action } from './Action';\nvar AsyncAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.pending = false;\n        return _this;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        clearInterval(id);\n        return undefined;\n    };\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action));\nexport { AsyncAction };\n//# sourceMappingURL=AsyncAction.js.map\n","/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscription } from '../Subscription';\nvar Action = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Action, _super);\n    function Action(scheduler, work) {\n        return _super.call(this) || this;\n    }\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return this;\n    };\n    return Action;\n}(Subscription));\nexport { Action };\n//# sourceMappingURL=Action.js.map\n","var Scheduler = /*@__PURE__*/ (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = function () { return Date.now(); };\n    return Scheduler;\n}());\nexport { Scheduler };\n//# sourceMappingURL=Scheduler.js.map\n","/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\nimport { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);\n//# sourceMappingURL=async.js.map\n","/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Scheduler } from '../Scheduler';\nvar AsyncScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncScheduler, _super);\n    function AsyncScheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        var _this = _super.call(this, SchedulerAction, function () {\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n                return AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        }) || this;\n        _this.actions = [];\n        _this.active = false;\n        _this.scheduled = undefined;\n        return _this;\n    }\n    AsyncScheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n            return AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return _super.prototype.schedule.call(this, work, delay, state);\n        }\n    };\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift());\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler));\nexport { AsyncScheduler };\n//# sourceMappingURL=AsyncScheduler.js.map\n","/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period, scheduler) {\n    if (period === void 0) {\n        period = 0;\n    }\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    if (!isNumeric(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = async;\n    }\n    return new Observable(function (subscriber) {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    var subscriber = state.subscriber, counter = state.counter, period = state.period;\n    subscriber.next(counter);\n    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);\n}\n//# sourceMappingURL=interval.js.map\n","// TODO make these inputs :D\nexport const fps = 60;\nexport const dataSampleRate = fps / 1000;\nexport const audioSampleRate = 2 * dataSampleRate;\nexport const fftSize = 1024;\nexport const psdSize = Math.floor(fftSize / 2) + 1;\n","import { audioStream } from './audio';\nimport { Params } from '../core/pipe/types';\nimport { interval, BehaviorSubject } from 'rxjs';\nimport { inputs } from './inputs';\nimport { fps } from './constants';\nimport { Audio } from './audio/types';\nimport { error } from './error';\nimport { NO_AUDIO } from './audio/constants';\n\nconst params = (t: number, { power, chroma, onset }: Audio) => {\n  return {\n    pipe: inputs.pipe.value,\n    theta: inputs.theta.value,\n    h: inputs.h.value,\n    v: inputs.v.value,\n    t,\n    power,\n    chroma,\n    onset,\n  };\n};\n\nconst subject = new BehaviorSubject<Params>(params(0, NO_AUDIO));\nexport const paramsStream = subject.asObservable();\nlet count = 0;\n\nlet audio: Audio;\naudioStream.subscribe(a => (audio = a), error);\n\nconst maybeEmit = () => {\n  if (inputs.animate.value) {\n    subject.next(params(count++ / fps, audio));\n  }\n};\n\ninterval(1000 / fps).subscribe(maybeEmit, error);\n","/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */\nimport { isArray } from './isArray';\nexport function isNumeric(val) {\n    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n//# sourceMappingURL=isNumeric.js.map\n","import { Observable, timer, Subject, interval, EMPTY } from 'rxjs';\nimport { retryWhen, delayWhen, repeatWhen, tap } from 'rxjs/operators';\nimport { Data } from '../core/data';\nimport { Params } from '../core/pipe/types';\nimport { startPool, runPipeline } from '../core/pipe/pool';\nimport * as params from './params';\nimport { getLogger } from 'loglevel';\nimport { pp } from '../core/pp';\nimport { error } from './error';\nimport debug from './debug';\n\nconst logger = getLogger('Data');\nlogger.setDefaultLevel('info');\nconst subject = new Subject<Data>();\n\nexport const dataStream = subject.asObservable();\n\ntype Source = {\n  getData(params: Params): Promise<Data>;\n};\n\nconst webWorkerSource = async (): Promise<Source> => {\n  console.info('starting web worker data source');\n  await startPool();\n\n  const getData = (params: Params) => runPipeline(params).then(Data.fromBuffer);\n\n  return { getData };\n};\n\n(async () => {\n  const { getData } = await webWorkerSource();\n  let inFlight: Promise<Data> | null;\n  let logged = 0;\n\n  params.paramsStream.subscribe(\n    async params => {\n      if (inFlight) return;\n      debug('params', params);\n      logger.debug('requesting data with params', params);\n      if (Date.now() - logged >= 1000) {\n        logger.debug(`sending request for data with params ${pp(params)}`);\n        logged = Date.now();\n      }\n      // TODO i feel like there's a more rx-y way to do this\n      inFlight = getData(params);\n      try {\n        subject.next(await inFlight);\n      } catch (err) {\n        error(err);\n      } finally {\n        inFlight = null;\n      }\n    },\n    err => error(err),\n  );\n})();\n","module.exports = __webpack_public_path__ + \"84cc0a5b4512eb11f528.worklet.js\";"],"sourceRoot":""}