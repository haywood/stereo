{"version":3,"sources":["webpack:///./src/core/pp.ts","webpack:///./src/client/inputs.ts","webpack:///./src/core/data.ts","webpack:///./src/client/params.ts","webpack:///./src/client/data.ts","webpack:///./src/client/constants.ts","webpack:///./src/core/pipe/pool.ts","webpack:///./src/core/pipe/pipe.worker.ts","webpack:///./src/core/pipe/grammar.pegjs","webpack:///./src/client/mic.ts","webpack:///./src/client/mic/mic.worker.ts","webpack:///./src/client/mic/analyzer.ts","webpack:///./src/core/fn/fn.ts","webpack:///./src/core/fn/interval.ts","webpack:///./src/core/fn/cube.ts","webpack:///./src/core/fn/rotator.ts","webpack:///./src/core/fn/sphere.ts","webpack:///./src/core/fn/spiral.ts","webpack:///./src/core/fn/torus.ts","webpack:///./src/core/fn/fucked_up_torus.ts","webpack:///./src/core/fn/stereo.ts","webpack:///./src/core/fn/identity.ts","webpack:///./src/core/pipe/resolver.ts","webpack:///./src/core/pipe/simplifier.ts","webpack:///./src/core/pipe/parser.ts","webpack:///./src/core/pipe/compiler.ts","webpack:///./src/core/pipe/evaluator.ts","webpack:///./src/core/pipe/pipe.ts"],"names":["pp","a","p","JSON","stringify","f0s","f1s","rotations","initialValues","pipe","limit","ps","i","j","length","push","planes","map","plane","key","f0","f1","join","theta","h","l","animate","sound","subjects","streams","persistence","query","URLSearchParams","window","location","search","get","saved","Object","entries","value","localStorage","getItem","restore","Subject","asObservable","values","Proxy","set","target","property","oldValue","success","Reflect","setItem","toString","persist","next","newValue","event","Data","constructor","n","d","position","color","buffer","data","Float32Array","nOffset","positionOffset","d0","SharedArrayBuffer","inputOffset","arr","offset","subarray","inputLength","positionLength","colorOffset","stride","assert","music","subject","stream","t","mic","subscribe","m","err","error","interval","fps","eaudio","daudio","emit","logger","getLogger","setDefaultLevel","webWorkerSource","console","info","startPool","navigator","hardwareConcurrency","getData","params","runPipeline","then","fromBuffer","inFlight","logged","debug","Date","now","audioSampleRate","pool","setLevel","poolSize","size","Pool","spawn","Worker","Map","promises","queue","Promise","all","events","initialize","timing","forkJoin","chunk","w","iterate","getOrInitialize","getKey","has","bufferFor","op","ceil","Math","min","label","start","elapsed","init","iter","Pipe","compile","slice","module","exports","peg$SyntaxError","message","expected","found","this","name","Error","captureStackTrace","child","parent","ctor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","escapedParts","parts","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toUpperCase","s","replace","descriptions","type","sort","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","peg$parsepipe","arith","peg$parsearith","peg$startRuleFunction","peg$c0","chain","parseInt","peg$c1","head","tail","peg$c2","f","peg$c3","fn","args","peg$c4","peg$c5","operands","peg$c6","peg$c7","peg$c8","id","peg$c9","parseFloat","peg$c10","peg$c11","peg$c12","peg$classExpectation","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$literalExpectation","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s3","peg$parseuint","peg$parsepipe_sep","peg$parsechain","peg$parsefun","peg$parseidentifier","peg$parselparen","peg$parsefun_args","peg$parsefun_arg","s2","peg$parse_","peg$parsefn_arg_sep","peg$parserparen","peg$parseid","peg$parsescalar","substr","substring","peg$parsearith_op","s4","s5","s6","test","charAt","peg$parsemantissa","peg$parseint","peg$parsefloat","peg$parsenumber","peg$parse__","FAKE_MUSIC","BehaviorSubject","worker","analyzer","Analyzer","inputs","analyze","read","subscription","mediaDevices","getUserMedia","audio","unsubscribe","mediaStream","node","getByteFrequencyData","bytes","ctx","AudioContext","AnalyserNode","fftSize","Uint8Array","frequencyBinCount","MediaStreamAudioSourceNode","connect","cos","sin","exp","tan","tanh","components","from","keys","CompositeFn","fns","first","rest","x","sample","apply","y","domain","equal","max","domainMax","dMax","last","reduce","Interval","b","nPerLevel","points","pop","successors","floor","nthRoot","Cube","fill","Rotator","d1","cube","r0","r1","Sphere","r","tau","phi","root","Spiral","k","sphere","Torus","cross","rotator","FuckedUpTorus","circle","q","Stereo","to","fromTemp","toTemp","up","down","temp","n2","norm2","divisor","result","Identity","Resolver","scope","resolvePipeNode","assertDefInNode","links","fun","shift","link","resolveFirstFunNode","assertNumberInNode","resolveFunNode","buildComposites","builder","Builder","isTemporal","add","build","funs","resolveFunArgNode","some","isNodeTemporal","prev","ranges","arg","resolveVarNode","resolveArithNode","ops","resolveNumberNode","fail","assertCondInNode","cond","rotate","spiral","torus","fucked_up_torus","R","stereo","Simplifier","substitutions","simplifyPipeNode","simplifyFunNode","simplifyFunArgNode","simplifyVarNode","simplifyArithNode","simplifyNumberNode","math","scalar","loggingParse","expr","Parser","Compiler","ast","parsePipe","parseArith","simplifier","resolve","simplify","Evaluator","hl","computeColors","colorScope","hue","round","evaluate","lightness","c","Color","g","compileNormal","normalized","evaluatorForNormal","finalScope","compileHL"],"mappings":"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","file":"4.a722c0b6c4437ff627d0.js","sourcesContent":["export const pp = (a: any, p = 2) => JSON.stringify(a, null, p);\n","import { Observable, Subject } from 'rxjs';\n\nconst initialValues = {\n    pipe: defaultPipe(),\n    theta: 'pi * t * daudio / 20',\n    h: 'abs(sin(theta)) * i / n',\n    l: 'eaudio',\n    animate: true,\n    sound: false,\n};\nexport type Inputs = typeof initialValues;\n\ntype Change<T> = {\n    newValue: T;\n    oldValue?: T;\n    event?: Event;\n};\nconst subjects: { [P in keyof Inputs]?: Subject<Change<Inputs[P]>> } = {};\n\nexport const streams: { [P in keyof Inputs]?: Observable<Change<Inputs[P]>> } = {};\n\nconst persistence: { [P in keyof Inputs]: boolean } = {\n    pipe: true,\n    theta: true,\n    h: true,\n    l: true,\n    animate: false,\n    sound: false,\n};\n\nconst persist = () => {\n    for (const [key, value] of Object.entries(values)) {\n        if (persistence[key]) {\n            localStorage.setItem(`inputs.${key}`, value.toString());\n        };\n    }\n};\n\nconst restore = () => {\n    // TODO (maybe): also support override from window.location.hash\n    for (const [key, saved] of Object.entries(persistence)) {\n        if (saved) {\n            const value = localStorage.getItem(`inputs.${key}`);\n            if (value) initialValues[key] = value;\n        };\n    }\n};\n\nconst query = new URLSearchParams(window.location.search);\nif (query.get('restore') !== '0') {\n    restore();\n}\n\nfor (const key in initialValues) {\n    subjects[key] = new Subject();\n    streams[key] = subjects[key].asObservable();\n}\n\nexport const values = new Proxy(initialValues, {\n    set(target, property, value) {\n        const oldValue = target[property];\n        const success = Reflect.set(target, property, value);\n        if (query.get('persist') !== '0') persist();\n        subjects[property].next({ newValue: value, event: window.event, oldValue });\n        return success;\n    }\n});\n\n// Genereates 10,000 points on a 4-d spiral and oscillates them\n// in the first 3 of the 6 planes of R^4. Use of tanh instead of sin in\n// the xy-plane causes the system to expand and contract at intervals.\nfunction defaultPipe() {\n    const d = 4;\n    const planes = (limit: number): [number, number][] => {\n        let ps = [];\n        for (let i = 0; i < d; i++) {\n            for (let j = i + 1; j < d; j++) {\n                if (ps.length < limit) {\n                    ps.push([i, j]);\n                } else {\n                    return ps;\n                }\n            }\n        }\n        return ps;\n    };\n\n    const f0s = {\n    };\n\n    const f1s = {\n        '[0,2]': 'sin',\n    };\n\n    const rotations = planes(3).map(plane => {\n        const key = JSON.stringify(plane);\n        const f0 = f0s[key] || 'cos';\n        const f1 = f1s[key] || 'tan';\n        return `R(theta, ${plane[0]}, ${plane[1]}, ${f0}, ${f1})`;\n    }).join('->');\n\n    return `10000->sphere(${d}, 1)->${rotations}->stereo(3)`;\n}\n","import assert from 'assert';\n\nexport type Vector = Float32Array;\n\nexport class Data {\n    constructor(\n        readonly n: number,\n        readonly d: number,\n        readonly position: Float32Array,\n        readonly color: Float32Array\n    ) { }\n\n    static fromBuffer = (buffer: ArrayBuffer) => {\n        const data = new Float32Array(buffer);\n        const n = data[Data.nOffset];\n        const d = data[Data.positionOffset(data)];\n        const position = Data.position(data);\n        const color = Data.color(data);\n        return new Data(n, d, position, color);\n    };\n\n    static bufferFor = (n: number, d0: number, d: number): SharedArrayBuffer => {\n        const bytesPerNum = 4;\n        const count = 3 + n * (d0 + d + 3);\n        const byteLength = bytesPerNum * count;\n        const buffer = new SharedArrayBuffer(byteLength);\n        const data = new Float32Array(buffer);\n        data[Data.nOffset] = n;\n        data[Data.inputOffset] = d0;\n        data[Data.positionOffset(data)] = d;\n        return buffer;\n    };\n\n    static input = (arr: Float32Array) => {\n        const offset = Data.inputOffset + 1;\n        return arr.subarray(offset, offset + Data.inputLength(arr));\n    };\n\n    static position = (arr: Float32Array) => {\n        const offset = Data.positionOffset(arr) + 1;\n        return arr.subarray(offset, offset + Data.positionLength(arr));\n    };\n\n    static color = (arr: Float32Array) => {\n        const offset = Data.colorOffset(arr);\n        return arr.subarray(offset);\n    };\n\n    static nOffset = 0;\n\n    static inputOffset = Data.nOffset + 1;\n    private static inputLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d0 = arr[Data.inputOffset];\n        return n * d0;\n    };\n\n    static positionOffset = (arr: Float32Array) =>\n        Data.inputOffset + Data.inputLength(arr) + 1;\n    private static positionLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d = arr[Data.positionOffset(arr)];\n        return n * d;\n    };\n\n    static colorOffset = (arr: Float32Array) =>\n        Data.positionOffset(arr) + Data.positionLength(arr) + 1;\n\n    static get = (arr: Vector, i: number, stride: number) => {\n        const offset = i * stride;\n        return arr.subarray(offset, offset + stride);\n    };\n\n    static set = (arr: Vector, value: ArrayLike<number>, i: number, stride: number) => {\n        assert(value.length <= stride);\n        const offset = i * stride;\n        return arr.set(value, offset);\n    };\n}\n","import * as mic from './mic';\nimport { Params } from '../core/pipe/types';\nimport { Subject, interval } from 'rxjs';\nimport { values } from './inputs';\nimport { Music } from './mic/types';\nimport { fps } from './constants';\n\nconst subject = new Subject<Params>();\nexport const stream = subject;\nlet t = 0;\n\nlet music: Music;\nmic.stream.subscribe(\n    m => music = m,\n    err => subject.error(err),\n);\n\nconst emit = () => {\n    const { eaudio, daudio } = music;\n    stream.next({\n        pipe: values.pipe,\n        theta: values.theta,\n        h: values.h,\n        l: values.l,\n        t,\n        eaudio: eaudio,\n        daudio: daudio,\n    });\n    t += 1 / fps;\n};\n\ninterval(1000 / fps).subscribe(\n    () => values.animate && emit(),\n    err => subject.error(err),\n);\n","import { Observable, timer, Subject, interval, EMPTY } from 'rxjs';\nimport { retryWhen, delayWhen, repeatWhen, tap } from 'rxjs/operators';\nimport { Data } from '../core/data';\nimport { Params } from \"../core/pipe/types\";\nimport { startPool, runPipeline } from '../core/pipe/pool';\nimport * as params from './params';\nimport { getLogger } from 'loglevel';\nimport { pp } from '../core/pp';\n\nconst logger = getLogger('Data');\nlogger.setDefaultLevel('info');\nconst subject = new Subject<Data>();\n\nexport const stream = subject.asObservable();\n\ntype Source = {\n  getData(params: Params): Promise<Data>;\n};\n\nconst webWorkerSource = async (): Promise<Source> => {\n  console.info('starting web worker data source');\n  await startPool(navigator.hardwareConcurrency);\n\n  const getData = (params: Params) =>\n    runPipeline(params).then(Data.fromBuffer);\n\n  return { getData };\n};\n\n(async () => {\n  const { getData } = await webWorkerSource();\n  let inFlight: Promise<Data> | null;\n  let logged = 0;\n\n  params.stream.subscribe(\n    async (params) => {\n      if (inFlight) return;\n      logger.debug('requesting data with params', params);\n      if (Date.now() - logged >= 1000) {\n        logger.info(`sending request for data with params ${pp(params)}`);\n        logged = Date.now();\n      }\n      // TODO i feel like there's a more rx-y way to do this\n      inFlight = getData(params);\n      try {\n        subject.next(await inFlight);\n      } catch (err) {\n        subject.error(err);\n      } finally {\n        inFlight = null;\n      }\n    },\n    err => subject.error(err),\n  );\n})();\n","// TODO make these inputs :D\nexport const fps = 60;\nexport const dataSampleRate = fps / 1000;\nexport const audioSampleRate = 2 * dataSampleRate;\n","import { spawn, Worker, Pool, ModuleThread } from \"threads\";\nimport { getLogger } from 'loglevel';\nimport { Params, PipelineWorker, Chunk } from './types';\nimport { Pipe } from \"./pipe\";\nimport { ceil } from \"mathjs\";\nimport { Data } from \"../data\";\n\nconst logger = getLogger('PipelinePool');\nlet pool: Pool<ModuleThread<PipelineWorker>>;\nlet data: Map<string, SharedArrayBuffer>;\nlogger.setLevel('info');\nlet poolSize = 0;\n\nexport const startPool = async (size: number) => {\n    logger.info('starting worker pool');\n    pool = Pool(() => spawn(new Worker('./pipe.worker')), size);\n    poolSize = size;\n    data = new Map();\n    let promises = [];\n    for (let i = 0; i < size; i++) {\n        // pre-load scripts so the first task doesn't take forever\n        promises.push(pool.queue(async () => { }));\n    }\n    await Promise.all(promises);\n\n    pool.events().subscribe((event: any) => {\n        if (event.error) {\n            logger.error('received error event from worker pool', event);\n        }\n    });\n};\n\nexport const stopPool = async (): Promise<void> => {\n    logger.info('waiting for pending tasks to complete before terminating pool');\n    try {\n        await pool.terminate(true);\n    } catch (err) {\n        logger.error(err);\n    } finally {\n        pool = null;\n    }\n};\n\nconst initialize = (params: Params, n: number, buffer: SharedArrayBuffer): Promise<void> => {\n    return timing('initialization')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.initialize(params, chunk, buffer));\n        });\n    });\n};\n\nconst iterate = (params: Params, n: number, buffer: SharedArrayBuffer) => {\n    return timing('iteration')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.iterate(params, chunk, buffer));\n        });\n    });\n};\n\nconst getKey = (params: Params) => JSON.stringify({\n    pipe: params.pipe,\n    theta: params.theta,\n    h: params.h,\n    l: params.l,\n});\n\nconst getOrInitialize = async (params: Params, n: number, d0: number, d: number): Promise<SharedArrayBuffer> => {\n    const key = getKey(params);\n    if (!data.has(key)) {\n        const buffer = Data.bufferFor(n, d0, d);\n        await initialize(params, n, buffer);\n        data.set(key, buffer);\n    }\n    return data.get(key);\n};\n\nconst forkJoin = async (n: number, op: (chunk: Chunk) => Promise<void>) => {\n    const size = ceil(n / poolSize);\n    let promises = [];\n    for (let offset = 0; offset < n; offset += size) {\n        const chunk = { offset, size: Math.min(n - offset, size) };\n        promises.push(op(chunk));\n    }\n    await Promise.all(promises);\n};\n\nconst timing = (label: string) => async<T>(op: () => Promise<T>) => {\n    const start = Date.now();\n    const t = await op();\n    const elapsed = Date.now() - start;\n    logger.debug(`${label} took ${elapsed}ms`);\n    return t;\n};\n\nexport const runPipeline = async (params: Params): Promise<SharedArrayBuffer> => {\n    const { n, init, iter } = Pipe.compile(params);\n    const buffer = await getOrInitialize(params, n, init.d, iter.d);\n    await iterate(params, n, buffer);\n\n    return buffer.slice(0);\n};\n","module.exports = __webpack_public_path__ + \"0.40dd2897f4b89eb6d8fe.worker.js\"","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { pipe: peg$parsepipe, arith: peg$parsearith },\n      peg$startRuleFunction  = peg$parsepipe,\n\n      peg$c0 = function(n, chain) {\n        return {n: parseInt(n), chain};\n      },\n      peg$c1 = function(head, tail) { return [head, ...tail]; },\n      peg$c2 = function(f) { return [f]; },\n      peg$c3 = function(fn, args) { return {fn, args} },\n      peg$c4 = function(a) { return [a]; },\n      peg$c5 = function(s, op, a) { return {op, operands: [s, a]}; },\n      peg$c6 = function(a) { return a; },\n      peg$c7 = function(value) { return {value}; },\n      peg$c8 = function(id) { return {id}; },\n      peg$c9 = function(f) { return parseFloat(f); },\n      peg$c10 = function(i) { return parseInt(i); },\n      peg$c11 = /^[a-zA-Z]/,\n      peg$c12 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n      peg$c13 = /^[a-zA-Z0-9]/,\n      peg$c14 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n      peg$c15 = function(id) { return id; },\n      peg$c16 = /^[+\\-]/,\n      peg$c17 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c18 = /^[0-9]/,\n      peg$c19 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c20 = /^[eE]/,\n      peg$c21 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c22 = \".\",\n      peg$c23 = peg$literalExpectation(\".\", false),\n      peg$c24 = \"+\",\n      peg$c25 = peg$literalExpectation(\"+\", false),\n      peg$c26 = \"-\",\n      peg$c27 = peg$literalExpectation(\"-\", false),\n      peg$c28 = \"*\",\n      peg$c29 = peg$literalExpectation(\"*\", false),\n      peg$c30 = \"/\",\n      peg$c31 = peg$literalExpectation(\"/\", false),\n      peg$c32 = \"**\",\n      peg$c33 = peg$literalExpectation(\"**\", false),\n      peg$c34 = \"^\",\n      peg$c35 = peg$literalExpectation(\"^\", false),\n      peg$c36 = function(op) { return op; },\n      peg$c37 = \"(\",\n      peg$c38 = peg$literalExpectation(\"(\", false),\n      peg$c39 = \")\",\n      peg$c40 = peg$literalExpectation(\")\", false),\n      peg$c41 = \",\",\n      peg$c42 = peg$literalExpectation(\",\", false),\n      peg$c43 = \"->\",\n      peg$c44 = peg$literalExpectation(\"->\", false),\n      peg$c45 = \"=>\",\n      peg$c46 = peg$literalExpectation(\"=>\", false),\n      peg$c47 = /^[ \\t\\n\\r]/,\n      peg$c48 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepipe() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseuint();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsechain() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefun();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefun();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselparen();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefun_args();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserparen();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun_args() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefun_arg();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefn_arg_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefun_args();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefun_arg();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun_arg() {\n    var s0;\n\n    s0 = peg$parseid();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsearith();\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsescalar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsearith_op();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsearith();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c5(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsescalar();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parselparen();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsearith();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parserparen();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c6(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsescalar() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseid();\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c8(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefloat();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseint();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c10(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      if (peg$c11.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        if (peg$c13.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c14); }\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          if (peg$c13.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloat() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c18.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsemantissa();\n        if (s4 !== peg$FAILED) {\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseint();\n            if (s6 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5, s6];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseint();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemantissa();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseint() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseuint() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c18.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c18.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemantissa() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c22;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith_op() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s3 = peg$c24;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s3 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s3 = peg$c26;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c27); }\n        }\n        if (s3 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s3 = peg$c28;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c29); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c30;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c31); }\n            }\n            if (s3 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c32) {\n                s3 = peg$c32;\n                peg$currPos += 2;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c33); }\n              }\n              if (s3 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 94) {\n                  s3 = peg$c34;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c35); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c36(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c37;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 41) {\n        s2 = peg$c39;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefn_arg_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c41;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepipe_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c43) {\n        s3 = peg$c43;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c45) {\n            s3 = peg$c45;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c46); }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c47.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","import { BehaviorSubject, interval, Observable } from 'rxjs';\nimport { getLogger } from 'loglevel';\nimport * as inputs from './inputs';\nimport { Music, MusicWorker } from './mic/types';\nimport { spawn, Worker, ModuleThread } from 'threads';\nimport { audioSampleRate } from './constants';\nimport { Analyzer } from './mic/analyzer';\n\nconst logger = getLogger('Energy');\n\nconst FAKE_MUSIC: Music = {\n    eaudio: 0.5,\n    daudio: 1,\n};\n\nconst subject = new BehaviorSubject<Music>(FAKE_MUSIC);\n\nconst start = async (stream: MediaStream): Promise<void> => {\n    logger.info('initializing audio graph');\n    const worker = await spawn<ModuleThread<MusicWorker>>(new Worker('./mic/mic.worker'));\n    const analyzer = new Analyzer(stream);\n\n    interval(1 / audioSampleRate).subscribe(async () => {\n        if (!inputs.values.sound) return;\n\n        try {\n            subject.next(await worker.analyze(analyzer.read()));\n        } catch (err) {\n            subject.error(err);\n        }\n    });\n};\n\nexport const stream = subject.asObservable();\n\nlet subscription = inputs.streams.sound.subscribe(async ({ newValue, event }) => {\n    if (newValue && event) {\n        const stream = await navigator.mediaDevices\n            .getUserMedia({ audio: true });\n        await start(stream);\n        subscription.unsubscribe();\n        subscription = null;\n    }\n});\n\ninputs.streams.sound.subscribe(async ({ newValue }) => {\n    if (!newValue) subject.next(FAKE_MUSIC);\n});\n","module.exports = __webpack_public_path__ + \"1.df174d31163bb32902df.worker.js\"","export class Analyzer {\n    private readonly node: AnalyserNode;\n    private readonly data: Float32Array;\n    private readonly bytes: Uint8Array;\n\n    constructor(mediaStream: MediaStream) {\n        const ctx = new AudioContext();\n        this.node = new AnalyserNode(ctx, { fftSize: 2048 });\n        this.bytes = new Uint8Array(this.node.frequencyBinCount);\n        this.data = new Float32Array(this.node.frequencyBinCount);\n\n        new MediaStreamAudioSourceNode(ctx, { mediaStream })\n            .connect(this.node);\n    }\n\n    read = () => {\n        this.node.getByteFrequencyData(this.bytes);\n        this.data.set(this.bytes);\n        for (let i = 0; i < this.data.length; i++) {\n            this.data[i] /= 255;\n        }\n        return this.data;\n    };\n}\n","import { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport const cos = Math.cos;\nexport const sin = Math.sin;\nexport const tan = Math.tan;\nexport const tanh = Math.tanh;\nexport const exp = Math.exp;\n\nexport const components = (d) => Array.from(new Array(d).keys());\n\nexport interface Fn {\n  readonly d: number;\n  readonly domain: number;\n  fn(x: Vector, y?: Vector): Vector;\n  sample(n: number, offset: number, limit: number): Generator<Vector>;\n}\n\nexport class CompositeFn implements Fn {\n  private readonly x: Vector;\n  private readonly y: Vector;\n  constructor(readonly fns: Fn[]) {\n    assert(fns.length, 'fns cannot be empty');\n\n    const length = Math.max(this.domainMax, this.dMax);\n    this.x = new Float32Array(length);\n    this.y = new Float32Array(length);\n\n  }\n\n  get first() {\n    return this.fns[0];\n  }\n\n  get last() {\n    return this.fns[this.fns.length - 1];\n  }\n\n  get domain() {\n    return this.first.domain;\n  }\n\n  get d() {\n    return this.last.d;\n  }\n\n  get domainMax() {\n    return this.fns.reduce((max, f) => Math.max(f.domain, max), 0);\n  }\n\n  get dMax() {\n    return this.fns.reduce((max, f) => Math.max(f.d, max), 0);\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { fns, d } = this;\n    const [first, ...rest] = fns;\n    if (fns.length == 0) return [];\n\n    for (const x of first.sample(n, offset, limit)) {\n      this.x.set(x);\n      if (rest.length) {\n        CompositeFn.apply(rest, this.x, this.y);\n      } else {\n        this.y.set(x);\n      }\n      yield this.y.subarray(0, d);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { fns, domain, d } = this;\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    this.x.set(x);\n    CompositeFn.apply(fns, this.x, this.y);\n    y.set(this.y.subarray(0, d));\n    return y;\n  };\n\n  private static apply = (fns: Fn[], x: Vector, y: Vector) => {\n    assert.equal(x.length, y.length);\n    for (const f of fns) {\n      f.fn(x.subarray(0, f.domain), y.subarray(0, f.d));\n      x.set(y);\n    }\n  };\n\n  static Builder = class {\n    private readonly fns: Fn[] = [];\n\n    get d() {\n      return this.last.d;\n    }\n\n    get last() {\n      return this.fns[this.fns.length - 1];\n    }\n\n    add = (fn: Fn) => {\n      const { fns, last } = this;\n      if (last && fn.domain !== last.d) {\n        throw new Error(\n          `Cannot add ${fn} to composite, because its domain is not ${last.d}`,\n        );\n      }\n      fns.push(fn);\n      return this;\n    };\n\n    build = () => {\n      return new CompositeFn(this.fns);\n    };\n  };\n}\n","import { floor, nthRoot } from 'mathjs';\nimport { Fn } from './fn';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Interval implements Fn {\n  readonly domain: number;\n\n  constructor(readonly d: number, readonly a: number[], readonly b: number[]) {\n    assert.equal(a.length, d);\n    assert.equal(b.length, d);\n    this.domain = d;\n  }\n\n  static nPerLevel = (d: number, n: number) => floor(nthRoot(n, d) as number);\n\n  static n = (d: number, n: number) => Interval.nPerLevel(d, n) ** d;\n\n  /**\n   * @param x A vector of length this.domain contained in the interval [0, 1].\n   * @returns A mapping of the vector into this interval.\n   */\n  fn = (x: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, b, d } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    for (let i = 0; i < d; i++) {\n      y[i] = a[i] + x[i] * (b[i] - a[i]);\n    }\n    return y;\n  };\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { d, fn } = this;\n    n = Interval.nPerLevel(d, n);\n    const points: number[][] = [[]];\n    let i = 0;\n\n    while (points.length && i < limit) {\n      const p = points.pop()!;\n      if (p.length < d) {\n        points.push(...successors(p));\n      } else if (i++ >= offset) {\n        yield fn(p);\n      }\n    }\n\n    function* successors(p: number[]): Generator<number[]> {\n      for (let i = 0; i < n; i++) {\n        yield [...p, i / n];\n      }\n    }\n  };\n}\n","import Interval from \"./interval\";\nimport { Fn } from \"./fn\";\nimport { Vector } from \"../data\";\n\nexport default class Cube implements Fn {\n  private readonly interval: Interval;\n\n  constructor(readonly d: number, readonly l: number) {\n    this.interval = new Interval(\n      d,\n      new Array(d).fill(-l / 2),\n      new Array(d).fill(l / 2)\n    );\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  fn = (x: Vector, y?: Vector) => this.interval.fn(x, y);\n\n  sample = (n: number, offset: number, limit: number) =>\n    this.interval.sample(n, offset, limit);\n}\n","import { Fn, cos, sin } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Rotator implements Fn {\n  readonly r0: number;\n  readonly r1: number;\n\n  constructor(\n    readonly d: number,\n    readonly theta: number,\n    readonly d0: number,\n    readonly d1: number,\n    readonly f0: (theta: number) => number = cos,\n    readonly f1: (theta: number) => number = sin,\n  ) {\n    this.r0 = f0(theta);\n    this.r1 = f1(theta);\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const p of cube.sample(n, offset, limit)) {\n      yield this.fn(p);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, d0, d1, r0, r1 } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    y.set(x);\n\n    const a = x[d0], b = x[d1];\n    y[d0] = a * r0 - b * r1;\n    y[d1] = a * r1 + b * r0;\n    return y;\n  };\n}\n","import { equal } from 'mathjs';\nimport Rotator from './rotator';\nimport Cube from './cube';\nimport { tau, zeros } from 'mathjs';\nimport { Fn, components, CompositeFn } from './fn';\nimport { TypedArray } from 'three';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Sphere implements Fn {\n  private readonly root: Float32Array;\n\n  constructor(readonly d: number, r: number) {\n    this.root = new Float32Array(d);\n    this.root[0] = r;\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, root } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    const r = new CompositeFn(components(d - 1).map((i) => new Rotator(d, phi[i], 0, i + 1)));\n    r.fn(root, y);\n    return y;\n  };\n}\n","import { Fn, exp, components } from './fn';\nimport Cube from './cube';\nimport Sphere from './sphere';\nimport { tau, sum, multiply } from 'mathjs';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Spiral implements Fn {\n  private readonly sphere: Sphere;\n\n  constructor(readonly d: number, readonly a: number[], readonly k: number[]) {\n    this.sphere = new Sphere(d, 1);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, k, domain, d } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    this.sphere.fn(phi, y);\n    let x = 0;\n    for (let i = 0; i < domain; i++) {\n      x += k[i] * phi[i];\n    };\n    const r = exp(x);\n    for (let i = 0; i < d; i++) {\n      y[i] = y[i] * a[i] * r;\n    }\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { tau } from 'mathjs';\nimport Rotator from './rotator';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Torus implements Fn {\n  private readonly cross: Sphere;\n\n  constructor(readonly d: number, readonly r: number, readonly t: number) {\n    assert(d > 2, `torus is only defined for d > 2; got ${d}`);\n    this.cross = new Sphere(d - 1, t);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (theta: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { cross, d, r } = this;\n    assert.equal(theta.length, d - 1, `torus expects an input of ${d - 1}; got ${theta.length}`);\n    const rotator = new Rotator(d, theta[d - 2], 0, d - 1);\n\n    cross.fn(theta.subarray(0, d - 2), y.subarray(0, d - 1));\n    y[0] += r;\n    rotator.fn(y, y);\n\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { tau } from 'mathjs';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\n// This shape does not implement a torus. It used to,\n// but then I changed the way Rotator works, which\n// changed the way that the points of the sphere are\n// distributed, making the translation step behave incorrectly\n// Still makes a cool shape though, so keeping it\nexport default class FuckedUpTorus implements Fn {\n    private readonly sphere: Sphere;\n    private readonly circle: Sphere;\n\n    constructor(readonly d: number, readonly r: number, readonly t: number) {\n        this.sphere = new Sphere(d, t);\n        this.circle = new Sphere(2, r);\n    }\n\n    get domain() {\n        return this.d - 1;\n    }\n\n    sample = function* (n: number, offset: number, limit: number) {\n        const cube = new Cube(this.domain, tau);\n        for (const phi of cube.sample(n, offset, limit)) {\n            yield this.fn(phi);\n        }\n    };\n\n    fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { domain, d, sphere, circle } = this;\n        assert.equal(phi.length, domain);\n        assert.equal(y.length, d);\n        sphere.fn(phi, y);\n        const q = circle.fn(phi.subarray(d - 2));\n        y[0] += q[0];\n        y[d - 1] += q[1];\n        return y;\n    };\n}\n","import { Fn } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Stereo implements Fn {\n  private readonly fromTemp: Vector;\n  private readonly toTemp: Vector;\n\n  constructor(private readonly from: number, private readonly to: number) {\n    this.fromTemp = new Float32Array(Math.max(from, to));\n    this.toTemp = new Float32Array(Math.max(from, to));\n  }\n\n  get domain() {\n    return this.from;\n  }\n\n  get d() {\n    return this.to;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.to)) => {\n    let { from, to, fromTemp, toTemp } = this;\n    assert.equal(x.length, from);\n    assert.equal(y.length, to);\n\n    if (from === to) {\n      y.set(x);\n      return y;\n    }\n\n    fromTemp.set(x);\n\n    while (from < to) {\n      Stereo.up(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, ++from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    while (from > to) {\n      Stereo.down(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, --from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    y.set(toTemp.subarray(0, to));\n    return y;\n  };\n\n  static up = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length + 1);\n    const n2 = norm2(x);\n    const divisor = n2 + 1;\n    temp[0] = (n2 - 1) / divisor;\n    for (let i = 1; i <= x.length; i++) {\n      temp[i] = (2 * x[i - 1]) / divisor;\n    }\n  };\n\n  static down = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length - 1);\n    for (let i = 0; i < temp.length; i++) {\n      temp[i] = x[i + 1] / (1 - x[0]);\n    }\n  };\n}\n\nconst norm2 = (x: Vector) => {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * x[i];\n  }\n  return result;\n};\n","import { Fn } from \"./fn\";\nimport Cube from \"./cube\";\nimport { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport class Identity implements Fn {\n    readonly domain: number;\n\n    constructor(readonly d: number) {\n        this.domain = d;\n    }\n\n    fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { d } = this;\n        assert.equal(x.length, d);\n        assert.equal(y.length, d);\n        y.set(x);\n        return y;\n    };\n\n    sample = function* (n: number, offset: number, limit: number) {\n        throw new Error('identity function does not support sampling');\n    };\n}\n","import { Scope, CompiledAST, Value, UnaryOperator, Link, ASTNode } from './types';\nimport assert from 'assert';\nimport { pp } from '../pp';\nimport { Fn, CompositeFn } from '../fn/fn';\nimport Cube from '../fn/cube';\nimport Spiral from '../fn/spiral';\nimport Torus from '../fn/torus';\nimport FuckedUpTorus from '../fn/fucked_up_torus';\nimport Sphere from '../fn/sphere';\nimport Stereo from '../fn/stereo';\nimport Rotator from '../fn/rotator';\nimport Interval from '../fn/interval';\nimport { Identity } from '../fn/identity';\n\nexport class Resolver {\n    constructor(private readonly scope: Scope) { }\n\n    resolve = (pipe: ASTNode): CompiledAST => {\n        return this.resolvePipeNode(pipe);\n    };\n\n    private resolvePipeNode = (pipe: ASTNode): CompiledAST => {\n        const chain = assertDefInNode('chain', pipe);\n        const links: Link[] = [];\n        const fun = chain.shift();\n        const d = fun.args.shift().value as number;\n        const link = this.resolveFirstFunNode(d, fun);\n        const n = Interval.n(link.fn.domain, assertNumberInNode('n', pipe));\n\n        links.push(link);\n\n        for (let i = 0; i < chain.length; i++) {\n            const fun = chain[i];\n            const link = this.resolveFunNode(links[i].fn, fun);\n            links.push(link);\n        }\n\n        const [init, iter] = this.buildComposites(links);\n        return { n, chain: links, init, iter };\n    };\n\n    private buildComposites = (links: Link[]) => {\n        let builder = new CompositeFn.Builder();\n        while (links.length && !links[0].isTemporal) {\n            builder.add(links.shift().fn);\n        }\n\n        const init = builder.build();\n        builder = new CompositeFn.Builder().add(new Identity(init.d));\n\n        while (links.length) {\n            builder.add(links.shift().fn);\n        }\n\n        const iter = builder.build();\n        return [init, iter];\n    };\n\n    private resolveFirstFunNode = (d: number, fun: ASTNode) => {\n        const name: string = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n        const fn = funs[name](d, ...args.map(this.resolveFunArgNode));\n        const isTemporal = args.some(isNodeTemporal);\n\n        return { fn, isTemporal };\n    };\n\n    private resolveFunNode = (prev: Fn, fun: ASTNode): Link => {\n        const name: string = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n        const d = ranges[name](prev.d);\n        const fn = funs[name](d, ...args.map(this.resolveFunArgNode));\n        const isTemporal = args.some(isNodeTemporal);\n\n        return { fn, isTemporal };\n    };\n\n    private resolveFunArgNode = (arg: ASTNode): Value => {\n        if (arg.id) {\n            return this.resolveVarNode(arg);\n        } else {\n            return this.resolveArithNode(arg);\n        }\n    };\n\n    private resolveArithNode = (node: ASTNode): number => {\n        if (node.op != null) {\n            const op = ops[node.op];\n            const [a, b] = assertDefInNode('operands', node)\n                .map(this.resolveArithNode);\n            const c = op(a, b);\n            return c;\n        } else {\n            return this.resolveNumberNode(node);\n        }\n    };\n\n    private resolveVarNode = (node: ASTNode): Value => {\n        const { value } = node;\n        if (typeof value === 'function') {\n            return value;\n        } else {\n            return this.resolveNumberNode(node);\n        }\n    };\n\n    private resolveNumberNode = (node: ASTNode): number => {\n        const { value } = node;\n        if (typeof value === 'number') {\n            return value;\n        } else {\n            assert.fail(`don't know how to handle number node ${pp(node)}`);\n        }\n    };\n}\n\nconst assertDefInNode = (name: string, node: ASTNode) => {\n    const x = node[name];\n    assertCondInNode(x != null, name, 'to be defined', node);\n    return x;\n};\n\nconst assertNumberInNode = (name: string, node: ASTNode): number => {\n    const x = node[name];\n    assertCondInNode(typeof x === 'number', name, 'a number', node);\n    return x as number;\n};\n\nconst assertCondInNode = (cond: boolean, name: string, expected: string, node: ASTNode) => {\n    assert(cond, `Expected ${name} to be ${expected} in ${pp(node)}`);\n};\n\nconst isNodeTemporal = (node: ASTNode): boolean => {\n    if (node.id === 't') return true;\n    else if (node.args) return node.args.some(isNodeTemporal);\n    else if (node.operands) return node.operands.some(isNodeTemporal);\n    else return false;\n};\n\nconst ops: {\n    [op: string]: (a: number, b: number) => number;\n} = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '*': (a, b) => a * b,\n    '/': (a, b) => a / b,\n    '**': (a, b) => a ** b,\n    '^': (a, b) => a ** b,\n};\n\nconst rotate = (\n    d: number,\n    theta: number,\n    d0: number,\n    d1: number,\n    f0: UnaryOperator = Math.cos,\n    f1: UnaryOperator = Math.sin,\n) => {\n    return new Rotator(d, theta, d0, d1, f0, f1);\n};\n\nconst funs: {\n    [op: string]: (d: number, ...rest) => Fn;\n} = {\n    cube: (d, l) => new Cube(d, l),\n    sphere: (d, r: number) => new Sphere(d, r),\n    spiral: (d, a: number, k: number) =>\n        new Spiral(d, new Array(d).fill(a), new Array(d - 1).fill(k)),\n    torus: (d, r: number, t: number) => new Torus(d, r, t),\n    fucked_up_torus: (d, r: number, t: number) =>\n        new FuckedUpTorus(d, r, t),\n    rotate,\n    R: rotate,\n    stereo: (d, to) => new Stereo(d, to),\n};\n\ntype Funs = typeof funs;\n\ntype Ranges = {\n    [P in keyof Funs]: (domain: number) => number;\n};\n\nconst ranges: Ranges = {\n    cube: (domain) => domain,\n    sphere: (domain) => domain + 1,\n    spiral: (domain) => domain + 1,\n    torus: (domain) => domain + 1,\n    fucked_up_torus: (domain) => domain + 1,\n    rotate: (domain) => domain,\n    R: (domain) => domain,\n    stereo: (domain) => domain,\n};\n","import * as math from 'mathjs';\nimport { Scope, Substitutions, ASTNode } from './types';\nimport assert from 'assert';\nimport { pp } from '../pp';\n\nexport class Simplifier {\n    constructor(\n        private readonly scope: Scope,\n        private readonly substitutions: Substitutions,\n    ) { }\n\n    simplify = (pipe: ASTNode): ASTNode => {\n        return this.simplifyPipeNode(pipe);\n    };\n\n    private simplifyPipeNode = (pipe: ASTNode): ASTNode => {\n        const n = assertNumberInNode('n', pipe);\n        const chain = assertDefInNode('chain', pipe);\n\n        return {\n            n,\n            chain: chain.map(this.simplifyFunNode),\n        };\n    };\n\n    private simplifyFunNode = (fun: ASTNode): ASTNode => {\n        const fn = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n\n        return {\n            fn,\n            args: args.map(this.simplifyFunArgNode),\n        };\n    };\n\n    private simplifyFunArgNode = (arg: ASTNode): ASTNode => {\n        if (arg.id) {\n            return this.simplifyVarNode(arg);\n        } else {\n            return this.simplifyArithNode(arg);\n        }\n    };\n\n    private simplifyArithNode = (arith: ASTNode): ASTNode => {\n        if (arith.op != null) {\n            const operands = assertDefInNode('operands', arith);\n            return { op: arith.op, operands: operands.map(this.simplifyArithNode) };\n        } else {\n            return this.simplifyNumberNode(arith);\n        }\n    };\n\n    private simplifyVarNode = (node: ASTNode): ASTNode => {\n        const id = node.id;\n        if (id in this.substitutions) {\n            return this.simplifyArithNode(this.substitutions[id]);\n        } else if (id in Math && typeof Math[id] === 'function') {\n            return { id, value: Math[id] };\n        } else {\n            return { id, value: math.evaluate(id, this.scope) };\n        }\n    };\n\n    private simplifyNumberNode = (scalar: ASTNode): ASTNode => {\n        const { id, value } = scalar;\n        if (value != null) {\n            return scalar;\n        } else if (id in this.substitutions) {\n            return this.simplifyArithNode(this.substitutions[id]);\n        } else if (id) {\n            const result = math.evaluate(id, this.scope);\n            assert.equal(typeof result, 'number', `Expected evaluation of ${pp(id)} to produce a number`);\n            return { id, value: result };\n        } else {\n            return scalar;\n        }\n    };\n}\n\nconst assertDefInNode = (name: string, node: ASTNode) => {\n    const x = node[name];\n    assertCondInNode(x != null, name, 'to be defined', node);\n    return x;\n};\n\nconst assertNumberInNode = (name: string, node: ASTNode): number => {\n    const x = node[name];\n    assertCondInNode(typeof x === 'number', name, 'a number', node);\n    return x as number;\n};\n\nconst assertCondInNode = (cond: boolean, name: string, expected: string, node: ASTNode) => {\n    assert(cond, `Expected ${name} to be ${expected} in ${pp(node)}`);\n};\n","import { parse } from './grammar.pegjs';\nimport { ASTNode } from './types';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\n\nconst logger = getLogger('Parser');\nlogger.setDefaultLevel('info');\n\ntype Options = {\n    startRule: 'arith';\n};\n\nconst loggingParse: typeof parse = (expr: string, options?: Options): ASTNode => {\n    try {\n        const node = parse(expr, options);\n        logger.debug(`parsed ${expr} into node ${pp(node)}`);\n        return node;\n    } catch (err) {\n        logger.error(`error parsing ${expr} at ${pp(err.location)}: ${err.message}`);\n        throw err;\n    }\n};\n\nexport class Parser {\n    static parsePipe = (pipe: string) => loggingParse(pipe);\n\n    static parseArith = (expr: string) => loggingParse(expr, { startRule: 'arith' });\n}\n","import { Scope, CompiledAST, NormalizedParams } from './types';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\nimport { Resolver } from './resolver';\nimport { Simplifier } from './simplifier';\nimport { Parser } from './parser';\n\nconst logger = getLogger('Compiler');\nlogger.setDefaultLevel('info');\n\nexport class Compiler {\n    constructor(private readonly scope: Scope) { }\n\n    compile = (params: NormalizedParams): CompiledAST => {\n        const ast = Parser.parsePipe(params.pipe);\n        logger.debug(`parsed params into ast ${pp(ast)}`);\n        const substitutions = {\n            theta: Parser.parseArith(params.theta),\n        };\n        const simplifier = new Simplifier(this.scope, substitutions);\n        const resolver = new Resolver(this.scope);\n        return resolver.resolve(simplifier.simplify(ast));\n    };\n}\n","import { CompositeFn } from \"../fn/fn\";\nimport { CompiledAST, Scope, HL, Chunk } from \"./types\";\nimport { Data, Vector } from \"../data\";\nimport { pp } from \"../pp\";\nimport { getLogger } from \"loglevel\";\nimport { round } from \"mathjs\";\nimport assert from 'assert';\nimport { Color } from \"three\";\n\nconst logger = getLogger('Evaluator');\n\nexport class Evaluator {\n    private readonly n: number;\n    private readonly init: CompositeFn;\n    private readonly iter: CompositeFn;\n    private readonly offset: number;\n    private readonly limit: number;\n\n    constructor(\n        private readonly scope: Scope,\n        ast: CompiledAST,\n        private readonly hl: HL,\n        chunk: Chunk,\n    ) {\n        const { n, init, iter } = ast;\n        const offset = chunk.offset;\n        const size = chunk.size;\n        const limit = offset + size;\n        assert(offset >= 0, `offset must be non-negative; got ${offset}`);\n        assert(limit <= n, `offset + size must be <= n; got ${offset} + ${size} = ${limit} > ${n}`);\n\n        this.n = n;\n        this.init = init;\n        this.iter = iter;\n        this.offset = offset;\n        this.limit = limit;\n    }\n\n\n    private get d() {\n        return this.iter.d;\n    }\n\n    initialize = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { n, init, offset, limit } = this;\n        const input = Data.input(data);\n        let i = offset;\n        for (const y of init.sample(n, offset, limit)) {\n            Data.set(input, y, i++, init.d);\n        }\n    };\n\n    iterate = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { init, iter, scope, n, offset, limit } = this;\n        const input = Data.input(data);\n        const position = Data.position(data);\n        const start = Date.now();\n\n        assert.equal(data[Data.nOffset], n, `n(data) != n(evaluator)`);\n        assert.equal(data[Data.inputOffset], init.d, `d0(data) != d0(evaluator)`);\n        assert.equal(data[Data.positionOffset(data)], iter.d, 'd(data) != d(evaluator)');\n\n        logger.debug(`iterating using ${pp(scope)}, ${pp(iter)}`);\n        for (let i = offset; i < limit; i++) {\n            iter.fn(Data.get(input, i, init.d), Data.get(position, i, iter.d));\n        }\n\n        this.computeColors(data);\n\n        logger.debug(`iteration complete in ${Date.now() - start}ms`);\n    };\n\n    private computeColors = (data: Vector) => {\n        logger.debug(`computing colors`);\n        const { d, scope, hl, offset, limit } = this;\n        const position = Data.position(data);\n        const color = Data.color(data);\n\n        for (let i = offset; i < limit; i++) {\n            const p = Data.get(position, i, d);\n            const colorScope = { ...scope, p, i };\n            const hue = round(hl.h.evaluate(colorScope), 0);\n            const lightness = round(hl.l.evaluate(colorScope), 0);\n            const c = new Color(`hsl(${hue}, 100%, ${lightness}%)`);\n\n            Data.set(color, [c.r, c.g, c.b], i, 3);\n        }\n\n    };\n}\n","import * as math from 'mathjs';\nimport { getLogger } from 'loglevel';\nimport { Params, Scope, NormalizedParams, CompiledAST, HL, Chunk } from './types';\nimport { Compiler } from './compiler';\nimport { Evaluator } from './evaluator';\n\nconst logger = getLogger('Pipe');\nlogger.setLevel('info');\n\nexport class Pipe {\n    static compile = (params: Params): CompiledAST => {\n        return Pipe.compileNormal(Pipe.normalized(params));\n    };\n    static evaluatorFor = (params: Params, chunk?: Chunk) => {\n        return Pipe.evaluatorForNormal(Pipe.normalized(params), chunk);\n    };\n\n    private static evaluatorForNormal = (params: NormalizedParams, chunk?: Chunk) => {\n        const ast = Pipe.compileNormal(params);\n        const scope = Pipe.finalScope(params, ast);\n        const hl = Pipe.compileHL(params);\n        return new Evaluator(scope, ast, hl, chunk);\n    };\n\n    private static compileNormal = (params: NormalizedParams): CompiledAST => {\n        const { eaudio, daudio, t } = params;\n        return new Compiler({ t, eaudio, daudio }).compile(params);\n\n    };\n\n    private static normalized = (params: Params): NormalizedParams => {\n        return {\n            pipe: params.pipe,\n            theta: params.theta || 't',\n            h: params.h || '1',\n            l: params.l || '0.5',\n            t: params.t || 0,\n            eaudio: params.eaudio || 0,\n            daudio: params.daudio || 0,\n        };\n    };\n\n    private static finalScope = (params: NormalizedParams, ast: CompiledAST): Scope => {\n        const { eaudio, daudio, t } = params;\n        const scope: Scope = { t, eaudio, daudio, n: ast.n };\n        scope.theta = math.evaluate(params.theta, scope);\n\n        return scope;\n    };\n\n    private static compileHL = (params: NormalizedParams): HL => {\n        return {\n            h: math.compile(`360 * (${params.h})`),\n            l: math.compile(`100 * (${params.l})`),\n        };\n    };\n}\n"],"sourceRoot":""}