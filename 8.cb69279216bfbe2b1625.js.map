{"version":3,"sources":["webpack:///./node_modules/loglevel/lib/loglevel.js"],"names":["root","definition","noop","undefinedType","isIE","window","test","navigator","userAgent","logMethods","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","console","log","trace","replaceLoggingMethods","level","loggerName","i","length","this","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","undefined","realMethod","Logger","name","defaultLevel","factory","currentLevel","self","storageKey","getPersistedLevel","storedLevel","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","getLevel","setLevel","persist","toUpperCase","SILENT","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","enableAll","TRACE","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers"],"mappings":"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","file":"8.cb69279216bfbe2b1625.js","sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n"],"sourceRoot":""}