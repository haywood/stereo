{"version":3,"sources":["webpack:///./src/core/pp.ts","webpack:///./src/client/inputs.ts","webpack:///./src/core/data.ts","webpack:///./src/client/audio/constants.ts","webpack:///./src/client/audio/spectrum.ts","webpack:///./src/client/audio/graph.ts","webpack:///./src/client/audio/index.ts","webpack:///./src/client/params.ts","webpack:///./src/client/constants.ts","webpack:///./src/client/data.ts","webpack:///./src/core/pipe/pool.ts","webpack:///./src/core/pipe/pipe.worker.ts","webpack:///./src/core/pipe/grammar.pegjs","webpack:///./src/client/audio/power.worklet.ts","webpack:///./src/core/fn/fn.ts","webpack:///./src/core/fn/interval.ts","webpack:///./src/core/fn/cube.ts","webpack:///./src/core/fn/rotator.ts","webpack:///./src/core/fn/sphere.ts","webpack:///./src/core/fn/spiral.ts","webpack:///./src/core/fn/torus.ts","webpack:///./src/core/fn/fucked_up_torus.ts","webpack:///./src/core/fn/stereo.ts","webpack:///./src/core/fn/identity.ts","webpack:///./src/core/pipe/resolver.ts","webpack:///./src/core/pipe/simplifier.ts","webpack:///./src/core/pipe/parser.ts","webpack:///./src/core/pipe/compiler.ts","webpack:///./src/core/pipe/evaluator.ts","webpack:///./src/core/pipe/pipe.ts"],"names":["pp","a","p","JSON","stringify","initialValues","pipe","theta","h","l","animate","sound","subjects","streams","persistence","query","URLSearchParams","window","location","search","key","get","saved","Object","entries","value","localStorage","getItem","restore","Subject","asObservable","values","Proxy","set","target","property","oldValue","success","Reflect","setItem","toString","persist","next","newValue","event","Data","constructor","n","d","position","color","buffer","data","Float32Array","nOffset","positionOffset","d0","SharedArrayBuffer","inputOffset","arr","offset","subarray","inputLength","positionLength","colorOffset","i","stride","assert","length","binCount","octaveCount","Spectrum","frames","map","frame","this","processFrame","Array","from","intensities","math","logIntensities","offsetLogIntensities","bottom","k","octave","ocatave","chroma","AudioGraph","ctx","source","subject","close","power","AudioWorkletNode","numberOfInputs","channelCountMode","channelCount","port","onmessage","msg","onprocessorerror","err","error","connect","destination","f","filter","BiquadFilterNode","type","frequency","Q","mediaStream","AudioContext","audioWorklet","addModule","processorUrl","MediaStreamAudioSourceNode","graph","logger","getLogger","BehaviorSubject","stream","inputs","subscribe","info","navigator","mediaDevices","getUserMedia","audio","create","warn","music","floor","fftSize","t","interval","emit","setDefaultLevel","webWorkerSource","console","startPool","hardwareConcurrency","getData","params","runPipeline","then","fromBuffer","inFlight","logged","debug","Date","now","pool","setLevel","poolSize","size","Pool","spawn","Worker","Map","promises","push","queue","Promise","all","events","initialize","timing","forkJoin","chunk","w","iterate","getOrInitialize","getKey","has","bufferFor","op","ceil","Math","min","label","start","elapsed","init","iter","Pipe","compile","slice","module","exports","peg$SyntaxError","message","expected","found","name","Error","captureStackTrace","child","parent","ctor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toUpperCase","s","replace","j","descriptions","sort","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","peg$parsepipe","arith","peg$parsearith","peg$startRuleFunction","peg$c0","chain","parseInt","peg$c1","head","tail","peg$c2","peg$c3","fn","args","peg$c4","peg$c5","operands","peg$c6","peg$c7","peg$c8","id","peg$c9","parseFloat","peg$c10","peg$c11","peg$c12","peg$classExpectation","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$literalExpectation","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s3","peg$parseuint","peg$parsepipe_sep","peg$parsechain","peg$parsefun","peg$parseidentifier","peg$parselparen","peg$parsefun_args","peg$parsefun_arg","s2","peg$parse_","peg$parsefn_arg_sep","peg$parserparen","peg$parseid","peg$parsescalar","substr","substring","peg$parsearith_op","s4","s5","s6","test","charAt","peg$parsemantissa","peg$parseint","peg$parsefloat","peg$parsenumber","peg$parse__","cos","sin","exp","tan","tanh","components","keys","CompositeFn","fns","limit","first","rest","x","sample","apply","y","domain","equal","max","domainMax","dMax","last","reduce","Interval","b","nPerLevel","points","pop","successors","nthRoot","Cube","fill","Rotator","d1","f0","f1","cube","r0","r1","Sphere","r","tau","phi","root","Spiral","sphere","Torus","cross","rotator","FuckedUpTorus","circle","q","Stereo","to","fromTemp","toTemp","up","down","temp","n2","norm2","divisor","result","Identity","Resolver","scope","resolvePipeNode","assertDefInNode","links","fun","shift","link","resolveFirstFunNode","assertNumberInNode","resolveFunNode","buildComposites","builder","Builder","isTemporal","add","build","funs","resolveFunArgNode","some","isNodeTemporal","prev","ranges","arg","resolveVarNode","resolveArithNode","node","ops","resolveNumberNode","fail","assertCondInNode","cond","rotate","spiral","torus","fucked_up_torus","R","stereo","Simplifier","substitutions","simplifyPipeNode","simplifyFunNode","simplifyFunArgNode","simplifyVarNode","simplifyArithNode","simplifyNumberNode","scalar","loggingParse","expr","Parser","Compiler","ast","parsePipe","parseArith","simplifier","resolve","simplify","Evaluator","hl","computeColors","colorScope","hue","round","evaluate","lightness","c","Color","g","compileNormal","normalized","evaluatorForNormal","finalScope","compileHL"],"mappings":"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","file":"4.c948feab8fb306391d28.js","sourcesContent":["export const pp = (a: any, p = 2) => JSON.stringify(a, null, p);\n","import { Observable, Subject } from 'rxjs';\n\nconst initialValues = {\n    pipe: '10000->sphere(4, 1)->R(theta, 0, 1, cos, tan)->R(theta, 0, 2)->R(theta, 0, 3)->stereo(3)',\n    theta: 'pi * (t + power) / 20',\n    h: 'chroma * i / n',\n    l: '0.2 + 0.8 * power',\n    animate: true,\n    sound: false,\n};\nexport type Inputs = typeof initialValues;\n\ntype Change<T> = {\n    newValue: T;\n    oldValue?: T;\n    event?: Event;\n};\nconst subjects: { [P in keyof Inputs]?: Subject<Change<Inputs[P]>> } = {};\n\nexport const streams: { [P in keyof Inputs]?: Observable<Change<Inputs[P]>> } = {};\n\nconst persistence: { [P in keyof Inputs]: boolean } = {\n    pipe: true,\n    theta: true,\n    h: true,\n    l: true,\n    animate: false,\n    sound: false,\n};\n\nconst persist = () => {\n    for (const [key, value] of Object.entries(values)) {\n        if (persistence[key]) {\n            localStorage.setItem(`inputs.${key}`, value.toString());\n        };\n    }\n};\n\nconst restore = () => {\n    // TODO (maybe): also support override from window.location.hash\n    for (const [key, saved] of Object.entries(persistence)) {\n        if (saved) {\n            const value = localStorage.getItem(`inputs.${key}`);\n            if (value) initialValues[key] = value;\n        };\n    }\n};\n\nconst query = new URLSearchParams(window.location.search);\nif (query.get('restore') !== '0') {\n    restore();\n}\n\nfor (const key in initialValues) {\n    subjects[key] = new Subject();\n    streams[key] = subjects[key].asObservable();\n}\n\nexport const values = new Proxy(initialValues, {\n    set(target, property, value) {\n        const oldValue = target[property];\n        const success = Reflect.set(target, property, value);\n        if (query.get('persist') !== '0') persist();\n        subjects[property].next({ newValue: value, event: window.event, oldValue });\n        return success;\n    }\n});\n","import assert from 'assert';\n\nexport type Vector = Float32Array;\n\nexport class Data {\n    constructor(\n        readonly n: number,\n        readonly d: number,\n        readonly position: Float32Array,\n        readonly color: Float32Array\n    ) { }\n\n    static fromBuffer = (buffer: ArrayBuffer) => {\n        const data = new Float32Array(buffer);\n        const n = data[Data.nOffset];\n        const d = data[Data.positionOffset(data)];\n        const position = Data.position(data);\n        const color = Data.color(data);\n        return new Data(n, d, position, color);\n    };\n\n    static bufferFor = (n: number, d0: number, d: number): SharedArrayBuffer => {\n        const bytesPerNum = 4;\n        const count = 3 + n * (d0 + d + 3);\n        const byteLength = bytesPerNum * count;\n        const buffer = new SharedArrayBuffer(byteLength);\n        const data = new Float32Array(buffer);\n        data[Data.nOffset] = n;\n        data[Data.inputOffset] = d0;\n        data[Data.positionOffset(data)] = d;\n        return buffer;\n    };\n\n    static input = (arr: Float32Array) => {\n        const offset = Data.inputOffset + 1;\n        return arr.subarray(offset, offset + Data.inputLength(arr));\n    };\n\n    static position = (arr: Float32Array) => {\n        const offset = Data.positionOffset(arr) + 1;\n        return arr.subarray(offset, offset + Data.positionLength(arr));\n    };\n\n    static color = (arr: Float32Array) => {\n        const offset = Data.colorOffset(arr);\n        return arr.subarray(offset);\n    };\n\n    static nOffset = 0;\n\n    static inputOffset = Data.nOffset + 1;\n    private static inputLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d0 = arr[Data.inputOffset];\n        return n * d0;\n    };\n\n    static positionOffset = (arr: Float32Array) =>\n        Data.inputOffset + Data.inputLength(arr) + 1;\n    private static positionLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d = arr[Data.positionOffset(arr)];\n        return n * d;\n    };\n\n    static colorOffset = (arr: Float32Array) =>\n        Data.positionOffset(arr) + Data.positionLength(arr) + 1;\n\n    static get = (arr: Vector, i: number, stride: number) => {\n        const offset = i * stride;\n        return arr.subarray(offset, offset + stride);\n    };\n\n    static set = (arr: Vector, value: ArrayLike<number>, i: number, stride: number) => {\n        assert(value.length <= stride);\n        const offset = i * stride;\n        return arr.set(value, offset);\n    };\n}\n","import { Audio } from \"./types\";\n\nexport const SILENCE: Audio = {\n    power: 0,\n    chroma: 0,\n};\n\nexport const chromaCount = 12;\nexport const octaveMin = 0;\nexport const octaveMax = 8;\nexport const octaveCount = octaveMax - octaveMin;\nexport const frameSize = 128;\nexport const binCount = octaveCount * chromaCount;\n","import { chromaCount } from './constants';\nimport * as math from 'mathjs';\n\nexport class Spectrum {\n    process = (frames: Float32Array[]): number[] => {\n        return frames.map((frame, i) => {\n            return this.processFrame(frame.length ? Array.from(frame) : [0]);\n        });\n    };\n\n    /**\n     * Computes the inverse of the RMS of the log intensities of the frame after\n     * offsetting each log by -1. The goal is to map the intensities onto a\n     * logarithmic scale with the same inputs, since this is closer to how humans\n     * hear.\n     */\n    processFrame = (frame: number[]): number => {\n        const intensities = math.abs(frame); // silent=0, loud=1\n        const logIntensities = math.log10(intensities); // silent=-Infinity, loud=0\n        const offsetLogIntensities = math.subtract(logIntensities, 1); // silent=-Infinity, loud=-1\n        const bottom = math.norm(offsetLogIntensities); // silent=Infinity, loud=√frame.length\n        const power = math.sqrt(frame.length) / bottom; // silent=0, loud=1\n        return power;\n    };\n\n    static ocatave = (k: number) => math.floor(k / chromaCount);\n\n    static chroma = (k: number) => k % chromaCount;\n\n    static f = (k: number): number => {\n        const octave = Spectrum.ocatave(k);\n        const chroma = Spectrum.chroma(k);\n        const c0 = 16.35; // c0 per https://pages.mtu.edu/~suits/notefreqs.html\n\n        return c0 * 2 ** octave * math.nthRoot(2, chromaCount) ** chroma;\n    };\n}\n","import { Subject } from \"rxjs\";\nimport { Audio } from './types';\nimport { Spectrum } from \"./spectrum\";\nimport { binCount } from \"./constants\";\nimport processorUrl from './power.worklet';\n\nexport class AudioGraph {\n\n    static create = async (mediaStream: MediaStream, subject: Subject<Audio>) => {\n        const ctx = new AudioContext();\n        await ctx.audioWorklet.addModule(processorUrl);\n        const source = new MediaStreamAudioSourceNode(ctx, { mediaStream });\n        return new AudioGraph(ctx, source, subject);\n    };\n\n    constructor(\n        private readonly ctx: AudioContext,\n        source: AudioNode,\n        subject: Subject<Audio>,\n    ) {\n        const power = new AudioWorkletNode(ctx, 'power', {\n            numberOfInputs: binCount,\n            channelCountMode: 'explicit',\n            channelCount: 1,\n        });\n        power.port.onmessage = (msg) => subject.next(msg.data as Audio);\n        power.onprocessorerror = (err) => subject.error(err);\n        power.connect(ctx.destination);\n\n        for (let k = 0; k < binCount; k++) {\n            const f = Spectrum.f(k);\n            const filter = new BiquadFilterNode(ctx, {\n                type: 'bandpass',\n                frequency: f,\n                Q: binCount / f,\n            });\n            source.connect(filter).connect(power, 0, k);\n        }\n    }\n\n    close = () => this.ctx.close();\n}\n","import { BehaviorSubject, interval, Observable } from 'rxjs';\nimport { getLogger } from 'loglevel';\nimport * as inputs from '../inputs';\nimport { Audio } from './types';\nimport { SILENCE } from './constants';\nimport { AudioGraph } from './graph';\n\nconst logger = getLogger('Audio');\n\nconst subject = new BehaviorSubject<Audio>(SILENCE);\nexport const stream = subject.asObservable();\nlet graph: AudioGraph;\n\ninputs.streams.sound.subscribe(async ({ newValue, event }) => {\n    if (newValue && event) {\n        logger.info('getting user media');\n        const stream = await navigator.mediaDevices\n            .getUserMedia({ audio: true });\n        logger.info('starting new audio graph');\n        graph = await AudioGraph.create(stream, subject);\n    } else if (!newValue && graph) {\n        logger.info('closing audio graph');\n        graph.close();\n    } else {\n        logger.warn(`inputs.streams.sound changed, but there was nothing to do: `, event);\n    }\n});\n","import * as audio from './audio';\nimport { Params } from '../core/pipe/types';\nimport { Subject, interval } from 'rxjs';\nimport { values } from './inputs';\nimport { fps } from './constants';\nimport { Audio } from './audio/types';\n\nconst subject = new Subject<Params>();\nexport const stream = subject;\nlet t = 0;\n\nlet music: Audio;\naudio.stream.subscribe(\n    a => music = a,\n    err => subject.error(err),\n);\n\nconst emit = () => {\n    const { power, chroma } = music;\n    stream.next({\n        pipe: values.pipe,\n        theta: values.theta,\n        h: values.h,\n        l: values.l,\n        t,\n        power,\n        chroma,\n    });\n    t += 1 / fps;\n};\n\ninterval(1000 / fps).subscribe(\n    () => values.animate && emit(),\n    err => subject.error(err),\n);\n","import { floor } from 'mathjs';\n\n// TODO make these inputs :D\nexport const fps = 60;\nexport const dataSampleRate = fps / 1000;\nexport const audioSampleRate = 2 * dataSampleRate;\nexport const fftSize = 1024;\nexport const psdSize = floor(fftSize / 2) + 1;\n","import { Observable, timer, Subject, interval, EMPTY } from 'rxjs';\nimport { retryWhen, delayWhen, repeatWhen, tap } from 'rxjs/operators';\nimport { Data } from '../core/data';\nimport { Params } from \"../core/pipe/types\";\nimport { startPool, runPipeline } from '../core/pipe/pool';\nimport * as params from './params';\nimport { getLogger } from 'loglevel';\nimport { pp } from '../core/pp';\n\nconst logger = getLogger('Data');\nlogger.setDefaultLevel('info');\nconst subject = new Subject<Data>();\n\nexport const stream = subject.asObservable();\n\ntype Source = {\n  getData(params: Params): Promise<Data>;\n};\n\nconst webWorkerSource = async (): Promise<Source> => {\n  console.info('starting web worker data source');\n  await startPool(navigator.hardwareConcurrency);\n\n  const getData = (params: Params) =>\n    runPipeline(params).then(Data.fromBuffer);\n\n  return { getData };\n};\n\n(async () => {\n  const { getData } = await webWorkerSource();\n  let inFlight: Promise<Data> | null;\n  let logged = 0;\n\n  params.stream.subscribe(\n    async (params) => {\n      if (inFlight) return;\n      logger.debug('requesting data with params', params);\n      if (Date.now() - logged >= 1000) {\n        logger.info(`sending request for data with params ${pp(params)}`);\n        logged = Date.now();\n      }\n      // TODO i feel like there's a more rx-y way to do this\n      inFlight = getData(params);\n      try {\n        subject.next(await inFlight);\n      } catch (err) {\n        subject.error(err);\n      } finally {\n        inFlight = null;\n      }\n    },\n    err => subject.error(err),\n  );\n})();\n","import { spawn, Worker, Pool, ModuleThread } from \"threads\";\nimport { getLogger } from 'loglevel';\nimport { Params, PipelineWorker, Chunk } from './types';\nimport { Pipe } from \"./pipe\";\nimport { ceil } from \"mathjs\";\nimport { Data } from \"../data\";\n\nconst logger = getLogger('PipelinePool');\nlet pool: Pool<ModuleThread<PipelineWorker>>;\nlet data: Map<string, SharedArrayBuffer>;\nlogger.setLevel('info');\nlet poolSize = 0;\n\nexport const startPool = async (size: number) => {\n    logger.info('starting worker pool');\n    pool = Pool(() => spawn(new Worker('./pipe.worker')), size);\n    poolSize = size;\n    data = new Map();\n    let promises = [];\n    for (let i = 0; i < size; i++) {\n        // pre-load scripts so the first task doesn't take forever\n        promises.push(pool.queue(async () => { }));\n    }\n    await Promise.all(promises);\n\n    pool.events().subscribe((event: any) => {\n        if (event.error) {\n            logger.error('received error event from worker pool', event);\n        }\n    });\n};\n\nexport const stopPool = async (): Promise<void> => {\n    logger.info('waiting for pending tasks to complete before terminating pool');\n    try {\n        await pool.terminate(true);\n    } catch (err) {\n        logger.error(err);\n    } finally {\n        pool = null;\n    }\n};\n\nconst initialize = (params: Params, n: number, buffer: SharedArrayBuffer): Promise<void> => {\n    return timing('initialization')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.initialize(params, chunk, buffer));\n        });\n    });\n};\n\nconst iterate = (params: Params, n: number, buffer: SharedArrayBuffer) => {\n    return timing('iteration')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.iterate(params, chunk, buffer));\n        });\n    });\n};\n\nconst getKey = (params: Params) => JSON.stringify({\n    pipe: params.pipe,\n    theta: params.theta,\n    h: params.h,\n    l: params.l,\n});\n\nconst getOrInitialize = async (params: Params, n: number, d0: number, d: number): Promise<SharedArrayBuffer> => {\n    const key = getKey(params);\n    if (!data.has(key)) {\n        const buffer = Data.bufferFor(n, d0, d);\n        await initialize(params, n, buffer);\n        data.set(key, buffer);\n    }\n    return data.get(key);\n};\n\nconst forkJoin = async (n: number, op: (chunk: Chunk) => Promise<void>) => {\n    const size = ceil(n / poolSize);\n    let promises = [];\n    for (let offset = 0; offset < n; offset += size) {\n        const chunk = { offset, size: Math.min(n - offset, size) };\n        promises.push(op(chunk));\n    }\n    await Promise.all(promises);\n};\n\nconst timing = (label: string) => async<T>(op: () => Promise<T>) => {\n    const start = Date.now();\n    const t = await op();\n    const elapsed = Date.now() - start;\n    logger.debug(`${label} took ${elapsed}ms`);\n    return t;\n};\n\nexport const runPipeline = async (params: Params): Promise<SharedArrayBuffer> => {\n    const { n, init, iter } = Pipe.compile(params);\n    const buffer = await getOrInitialize(params, n, init.d, iter.d);\n    await iterate(params, n, buffer);\n\n    return buffer.slice(0);\n};\n","module.exports = __webpack_public_path__ + \"0.a74f84a348d6fdb45bda.worker.js\"","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { pipe: peg$parsepipe, arith: peg$parsearith },\n      peg$startRuleFunction  = peg$parsepipe,\n\n      peg$c0 = function(n, chain) {\n        return {n: parseInt(n), chain};\n      },\n      peg$c1 = function(head, tail) { return [head, ...tail]; },\n      peg$c2 = function(f) { return [f]; },\n      peg$c3 = function(fn, args) { return {fn, args} },\n      peg$c4 = function(a) { return [a]; },\n      peg$c5 = function(s, op, a) { return {op, operands: [s, a]}; },\n      peg$c6 = function(value) { return {value}; },\n      peg$c7 = function(a) { return a; },\n      peg$c8 = function(id) { return {id}; },\n      peg$c9 = function(f) { return parseFloat(f); },\n      peg$c10 = function(i) { return parseInt(i); },\n      peg$c11 = /^[a-zA-Z]/,\n      peg$c12 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n      peg$c13 = /^[a-zA-Z0-9]/,\n      peg$c14 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n      peg$c15 = function(id) { return id; },\n      peg$c16 = /^[+\\-]/,\n      peg$c17 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c18 = /^[0-9]/,\n      peg$c19 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c20 = /^[eE]/,\n      peg$c21 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c22 = \".\",\n      peg$c23 = peg$literalExpectation(\".\", false),\n      peg$c24 = \"+\",\n      peg$c25 = peg$literalExpectation(\"+\", false),\n      peg$c26 = \"-\",\n      peg$c27 = peg$literalExpectation(\"-\", false),\n      peg$c28 = \"*\",\n      peg$c29 = peg$literalExpectation(\"*\", false),\n      peg$c30 = \"/\",\n      peg$c31 = peg$literalExpectation(\"/\", false),\n      peg$c32 = \"**\",\n      peg$c33 = peg$literalExpectation(\"**\", false),\n      peg$c34 = \"^\",\n      peg$c35 = peg$literalExpectation(\"^\", false),\n      peg$c36 = function(op) { return op; },\n      peg$c37 = \"(\",\n      peg$c38 = peg$literalExpectation(\"(\", false),\n      peg$c39 = \")\",\n      peg$c40 = peg$literalExpectation(\")\", false),\n      peg$c41 = \",\",\n      peg$c42 = peg$literalExpectation(\",\", false),\n      peg$c43 = \"->\",\n      peg$c44 = peg$literalExpectation(\"->\", false),\n      peg$c45 = \"=>\",\n      peg$c46 = peg$literalExpectation(\"=>\", false),\n      peg$c47 = /^[ \\t\\n\\r]/,\n      peg$c48 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepipe() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseuint();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsechain() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefun();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefun();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselparen();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefun_args();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserparen();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun_args() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefun_arg();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefn_arg_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefun_args();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefun_arg();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun_arg() {\n    var s0;\n\n    s0 = peg$parseid();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsearith();\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsescalar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsearith_op();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsearith();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c5(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsescalar();\n    }\n\n    return s0;\n  }\n\n  function peg$parsescalar() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c6(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseid();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parselparen();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsearith();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parserparen();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c7(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c8(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefloat();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseint();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c10(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      if (peg$c11.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        if (peg$c13.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c14); }\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          if (peg$c13.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloat() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c18.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsemantissa();\n        if (s4 !== peg$FAILED) {\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseint();\n            if (s6 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5, s6];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseint();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemantissa();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseint() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseuint() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c18.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c18.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemantissa() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c22;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith_op() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s3 = peg$c24;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s3 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s3 = peg$c26;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c27); }\n        }\n        if (s3 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s3 = peg$c28;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c29); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c30;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c31); }\n            }\n            if (s3 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c32) {\n                s3 = peg$c32;\n                peg$currPos += 2;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c33); }\n              }\n              if (s3 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 94) {\n                  s3 = peg$c34;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c35); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c36(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c37;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 41) {\n        s2 = peg$c39;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefn_arg_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c41;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepipe_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c43) {\n        s3 = peg$c43;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c45) {\n            s3 = peg$c45;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c46); }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c47.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","module.exports = __webpack_public_path__ + \"1518edd34e6bc57c2082.worklet.js\";","import { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport const cos = Math.cos;\nexport const sin = Math.sin;\nexport const tan = Math.tan;\nexport const tanh = Math.tanh;\nexport const exp = Math.exp;\n\nexport const components = (d) => Array.from(new Array(d).keys());\n\nexport interface Fn {\n  readonly d: number;\n  readonly domain: number;\n  fn(x: Vector, y?: Vector): Vector;\n  sample(n: number, offset: number, limit: number): Generator<Vector>;\n}\n\nexport class CompositeFn implements Fn {\n  private readonly x: Vector;\n  private readonly y: Vector;\n  constructor(readonly fns: Fn[]) {\n    assert(fns.length, 'fns cannot be empty');\n\n    const length = Math.max(this.domainMax, this.dMax);\n    this.x = new Float32Array(length);\n    this.y = new Float32Array(length);\n\n  }\n\n  get first() {\n    return this.fns[0];\n  }\n\n  get last() {\n    return this.fns[this.fns.length - 1];\n  }\n\n  get domain() {\n    return this.first.domain;\n  }\n\n  get d() {\n    return this.last.d;\n  }\n\n  get domainMax() {\n    return this.fns.reduce((max, f) => Math.max(f.domain, max), 0);\n  }\n\n  get dMax() {\n    return this.fns.reduce((max, f) => Math.max(f.d, max), 0);\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { fns, d } = this;\n    const [first, ...rest] = fns;\n    if (fns.length == 0) return [];\n\n    for (const x of first.sample(n, offset, limit)) {\n      this.x.set(x);\n      if (rest.length) {\n        CompositeFn.apply(rest, this.x, this.y);\n      } else {\n        this.y.set(x);\n      }\n      yield this.y.subarray(0, d);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { fns, domain, d } = this;\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    this.x.set(x);\n    CompositeFn.apply(fns, this.x, this.y);\n    y.set(this.y.subarray(0, d));\n    return y;\n  };\n\n  private static apply = (fns: Fn[], x: Vector, y: Vector) => {\n    assert.equal(x.length, y.length);\n    for (const f of fns) {\n      f.fn(x.subarray(0, f.domain), y.subarray(0, f.d));\n      x.set(y);\n    }\n  };\n\n  static Builder = class {\n    private readonly fns: Fn[] = [];\n\n    get d() {\n      return this.last.d;\n    }\n\n    get last() {\n      return this.fns[this.fns.length - 1];\n    }\n\n    add = (fn: Fn) => {\n      const { fns, last } = this;\n      if (last && fn.domain !== last.d) {\n        throw new Error(\n          `Cannot add ${fn} to composite, because its domain is not ${last.d}`,\n        );\n      }\n      fns.push(fn);\n      return this;\n    };\n\n    build = () => {\n      return new CompositeFn(this.fns);\n    };\n  };\n}\n","import { floor, nthRoot } from 'mathjs';\nimport { Fn } from './fn';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Interval implements Fn {\n  readonly domain: number;\n\n  constructor(readonly d: number, readonly a: number[], readonly b: number[]) {\n    assert.equal(a.length, d);\n    assert.equal(b.length, d);\n    this.domain = d;\n  }\n\n  static nPerLevel = (d: number, n: number) => floor(nthRoot(n, d) as number);\n\n  static n = (d: number, n: number) => Interval.nPerLevel(d, n) ** d;\n\n  /**\n   * @param x A vector of length this.domain contained in the interval [0, 1].\n   * @returns A mapping of the vector into this interval.\n   */\n  fn = (x: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, b, d } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    for (let i = 0; i < d; i++) {\n      y[i] = a[i] + x[i] * (b[i] - a[i]);\n    }\n    return y;\n  };\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { d, fn } = this;\n    n = Interval.nPerLevel(d, n);\n    const points: number[][] = [[]];\n    let i = 0;\n\n    while (points.length && i < limit) {\n      const p = points.pop()!;\n      if (p.length < d) {\n        points.push(...successors(p));\n      } else if (i++ >= offset) {\n        yield fn(p);\n      }\n    }\n\n    function* successors(p: number[]): Generator<number[]> {\n      for (let i = 0; i < n; i++) {\n        yield [...p, i / n];\n      }\n    }\n  };\n}\n","import Interval from \"./interval\";\nimport { Fn } from \"./fn\";\nimport { Vector } from \"../data\";\n\nexport default class Cube implements Fn {\n  private readonly interval: Interval;\n\n  constructor(readonly d: number, readonly l: number) {\n    this.interval = new Interval(\n      d,\n      new Array(d).fill(-l / 2),\n      new Array(d).fill(l / 2)\n    );\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  fn = (x: Vector, y?: Vector) => this.interval.fn(x, y);\n\n  sample = (n: number, offset: number, limit: number) =>\n    this.interval.sample(n, offset, limit);\n}\n","import { Fn, cos, sin } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Rotator implements Fn {\n  readonly r0: number;\n  readonly r1: number;\n\n  constructor(\n    readonly d: number,\n    readonly theta: number,\n    readonly d0: number,\n    readonly d1: number,\n    readonly f0: (theta: number) => number = cos,\n    readonly f1: (theta: number) => number = sin,\n  ) {\n    this.r0 = f0(theta);\n    this.r1 = f1(theta);\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const p of cube.sample(n, offset, limit)) {\n      yield this.fn(p);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, d0, d1, r0, r1 } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    y.set(x);\n\n    const a = x[d0], b = x[d1];\n    y[d0] = a * r0 - b * r1;\n    y[d1] = a * r1 + b * r0;\n    return y;\n  };\n}\n","import { equal } from 'mathjs';\nimport Rotator from './rotator';\nimport Cube from './cube';\nimport { tau, zeros } from 'mathjs';\nimport { Fn, components, CompositeFn } from './fn';\nimport { TypedArray } from 'three';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Sphere implements Fn {\n  private readonly root: Float32Array;\n\n  constructor(readonly d: number, r: number) {\n    this.root = new Float32Array(d);\n    this.root[0] = r;\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, root } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    const r = new CompositeFn(components(d - 1).map((i) => new Rotator(d, phi[i], 0, i + 1)));\n    r.fn(root, y);\n    return y;\n  };\n}\n","import { Fn, exp, components } from './fn';\nimport Cube from './cube';\nimport Sphere from './sphere';\nimport { tau, sum, multiply } from 'mathjs';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Spiral implements Fn {\n  private readonly sphere: Sphere;\n\n  constructor(readonly d: number, readonly a: number[], readonly k: number[]) {\n    this.sphere = new Sphere(d, 1);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, k, domain, d } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    this.sphere.fn(phi, y);\n    let x = 0;\n    for (let i = 0; i < domain; i++) {\n      x += k[i] * phi[i];\n    };\n    const r = exp(x);\n    for (let i = 0; i < d; i++) {\n      y[i] = y[i] * a[i] * r;\n    }\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { tau } from 'mathjs';\nimport Rotator from './rotator';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Torus implements Fn {\n  private readonly cross: Sphere;\n\n  constructor(readonly d: number, readonly r: number, readonly t: number) {\n    assert(d > 2, `torus is only defined for d > 2; got ${d}`);\n    this.cross = new Sphere(d - 1, t);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (theta: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { cross, d, r } = this;\n    assert.equal(theta.length, d - 1, `torus expects an input of ${d - 1}; got ${theta.length}`);\n    const rotator = new Rotator(d, theta[d - 2], 0, d - 1);\n\n    cross.fn(theta.subarray(0, d - 2), y.subarray(0, d - 1));\n    y[0] += r;\n    rotator.fn(y, y);\n\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { tau } from 'mathjs';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\n// This shape does not implement a torus. It used to,\n// but then I changed the way Rotator works, which\n// changed the way that the points of the sphere are\n// distributed, making the translation step behave incorrectly\n// Still makes a cool shape though, so keeping it\nexport default class FuckedUpTorus implements Fn {\n    private readonly sphere: Sphere;\n    private readonly circle: Sphere;\n\n    constructor(readonly d: number, readonly r: number, readonly t: number) {\n        this.sphere = new Sphere(d, t);\n        this.circle = new Sphere(2, r);\n    }\n\n    get domain() {\n        return this.d - 1;\n    }\n\n    sample = function* (n: number, offset: number, limit: number) {\n        const cube = new Cube(this.domain, tau);\n        for (const phi of cube.sample(n, offset, limit)) {\n            yield this.fn(phi);\n        }\n    };\n\n    fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { domain, d, sphere, circle } = this;\n        assert.equal(phi.length, domain);\n        assert.equal(y.length, d);\n        sphere.fn(phi, y);\n        const q = circle.fn(phi.subarray(d - 2));\n        y[0] += q[0];\n        y[d - 1] += q[1];\n        return y;\n    };\n}\n","import { Fn } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Stereo implements Fn {\n  private readonly fromTemp: Vector;\n  private readonly toTemp: Vector;\n\n  constructor(private readonly from: number, private readonly to: number) {\n    this.fromTemp = new Float32Array(Math.max(from, to));\n    this.toTemp = new Float32Array(Math.max(from, to));\n  }\n\n  get domain() {\n    return this.from;\n  }\n\n  get d() {\n    return this.to;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.to)) => {\n    let { from, to, fromTemp, toTemp } = this;\n    assert.equal(x.length, from);\n    assert.equal(y.length, to);\n\n    if (from === to) {\n      y.set(x);\n      return y;\n    }\n\n    fromTemp.set(x);\n\n    while (from < to) {\n      Stereo.up(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, ++from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    while (from > to) {\n      Stereo.down(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, --from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    y.set(toTemp.subarray(0, to));\n    return y;\n  };\n\n  static up = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length + 1);\n    const n2 = norm2(x);\n    const divisor = n2 + 1;\n    temp[0] = (n2 - 1) / divisor;\n    for (let i = 1; i <= x.length; i++) {\n      temp[i] = (2 * x[i - 1]) / divisor;\n    }\n  };\n\n  static down = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length - 1);\n    for (let i = 0; i < temp.length; i++) {\n      temp[i] = x[i + 1] / (1 - x[0]);\n    }\n  };\n}\n\nconst norm2 = (x: Vector) => {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * x[i];\n  }\n  return result;\n};\n","import { Fn } from \"./fn\";\nimport Cube from \"./cube\";\nimport { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport class Identity implements Fn {\n    readonly domain: number;\n\n    constructor(readonly d: number) {\n        this.domain = d;\n    }\n\n    fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { d } = this;\n        assert.equal(x.length, d);\n        assert.equal(y.length, d);\n        y.set(x);\n        return y;\n    };\n\n    sample = function* (n: number, offset: number, limit: number) {\n        throw new Error('identity function does not support sampling');\n    };\n}\n","import { Scope, CompiledAST, Value, UnaryOperator, Link, ASTNode } from './types';\nimport assert from 'assert';\nimport { pp } from '../pp';\nimport { Fn, CompositeFn } from '../fn/fn';\nimport Cube from '../fn/cube';\nimport Spiral from '../fn/spiral';\nimport Torus from '../fn/torus';\nimport FuckedUpTorus from '../fn/fucked_up_torus';\nimport Sphere from '../fn/sphere';\nimport Stereo from '../fn/stereo';\nimport Rotator from '../fn/rotator';\nimport Interval from '../fn/interval';\nimport { Identity } from '../fn/identity';\n\nexport class Resolver {\n    constructor(private readonly scope: Scope) { }\n\n    resolve = (pipe: ASTNode): CompiledAST => {\n        return this.resolvePipeNode(pipe);\n    };\n\n    private resolvePipeNode = (pipe: ASTNode): CompiledAST => {\n        const chain = assertDefInNode('chain', pipe);\n        const links: Link[] = [];\n        const fun = chain.shift();\n        const d = fun.args.shift().value as number;\n        const link = this.resolveFirstFunNode(d, fun);\n        const n = Interval.n(link.fn.domain, assertNumberInNode('n', pipe));\n\n        links.push(link);\n\n        for (let i = 0; i < chain.length; i++) {\n            const fun = chain[i];\n            const link = this.resolveFunNode(links[i].fn, fun);\n            links.push(link);\n        }\n\n        const [init, iter] = this.buildComposites(links);\n        return { n, init, iter };\n    };\n\n    private buildComposites = (links: Link[]) => {\n        let builder = new CompositeFn.Builder();\n        while (links.length && !links[0].isTemporal) {\n            builder.add(links.shift().fn);\n        }\n\n        const init = builder.build();\n        builder = new CompositeFn.Builder().add(new Identity(init.d));\n\n        while (links.length) {\n            builder.add(links.shift().fn);\n        }\n\n        const iter = builder.build();\n        return [init, iter];\n    };\n\n    private resolveFirstFunNode = (d: number, fun: ASTNode) => {\n        const name: string = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n        const fn = funs[name](d, ...args.map(this.resolveFunArgNode));\n        const isTemporal = args.some(isNodeTemporal);\n\n        return { fn, isTemporal };\n    };\n\n    private resolveFunNode = (prev: Fn, fun: ASTNode): Link => {\n        const name: string = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n        const d = ranges[name](prev.d);\n        const fn = funs[name](d, ...args.map(this.resolveFunArgNode));\n        const isTemporal = args.some(isNodeTemporal);\n\n        return { fn, isTemporal };\n    };\n\n    private resolveFunArgNode = (arg: ASTNode): Value => {\n        if (arg.id) {\n            return this.resolveVarNode(arg);\n        } else {\n            return this.resolveArithNode(arg);\n        }\n    };\n\n    private resolveArithNode = (node: ASTNode): number => {\n        if (node.op != null) {\n            const op = ops[node.op];\n            const [a, b] = assertDefInNode('operands', node)\n                .map(this.resolveArithNode);\n            const c = op(a, b);\n            return c;\n        } else {\n            return this.resolveNumberNode(node);\n        }\n    };\n\n    private resolveVarNode = (node: ASTNode): Value => {\n        const { value } = node;\n        if (typeof value === 'function') {\n            return value;\n        } else {\n            return this.resolveNumberNode(node);\n        }\n    };\n\n    private resolveNumberNode = (node: ASTNode): number => {\n        const { value } = node;\n        if (typeof value === 'number') {\n            return value;\n        } else {\n            assert.fail(`don't know how to handle number node ${pp(node)}`);\n        }\n    };\n}\n\nconst assertDefInNode = (name: string, node: ASTNode) => {\n    const x = node[name];\n    assertCondInNode(x != null, name, 'to be defined', node);\n    return x;\n};\n\nconst assertNumberInNode = (name: string, node: ASTNode): number => {\n    const x = node[name];\n    assertCondInNode(typeof x === 'number', name, 'a number', node);\n    return x as number;\n};\n\nconst assertCondInNode = (cond: boolean, name: string, expected: string, node: ASTNode) => {\n    assert(cond, `Expected ${name} to be ${expected} in ${pp(node)}`);\n};\n\nconst isNodeTemporal = (node: ASTNode): boolean => {\n    if (node.id === 't') return true;\n    else if (node.args) return node.args.some(isNodeTemporal);\n    else if (node.operands) return node.operands.some(isNodeTemporal);\n    else return false;\n};\n\nconst ops: {\n    [op: string]: (a: number, b: number) => number;\n} = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '*': (a, b) => a * b,\n    '/': (a, b) => a / b,\n    '**': (a, b) => a ** b,\n    '^': (a, b) => a ** b,\n};\n\nconst rotate = (\n    d: number,\n    theta: number,\n    d0: number,\n    d1: number,\n    f0: UnaryOperator = Math.cos,\n    f1: UnaryOperator = Math.sin,\n) => {\n    return new Rotator(d, theta, d0, d1, f0, f1);\n};\n\nconst funs: {\n    [op: string]: (d: number, ...rest) => Fn;\n} = {\n    cube: (d, l) => new Cube(d, l),\n    sphere: (d, r: number) => new Sphere(d, r),\n    spiral: (d, a: number, k: number) =>\n        new Spiral(d, new Array(d).fill(a), new Array(d - 1).fill(k)),\n    torus: (d, r: number, t: number) => new Torus(d, r, t),\n    fucked_up_torus: (d, r: number, t: number) =>\n        new FuckedUpTorus(d, r, t),\n    rotate,\n    R: rotate,\n    stereo: (d, to) => new Stereo(d, to),\n};\n\ntype Funs = typeof funs;\n\ntype Ranges = {\n    [P in keyof Funs]: (domain: number) => number;\n};\n\nconst ranges: Ranges = {\n    cube: (domain) => domain,\n    sphere: (domain) => domain + 1,\n    spiral: (domain) => domain + 1,\n    torus: (domain) => domain + 1,\n    fucked_up_torus: (domain) => domain + 1,\n    rotate: (domain) => domain,\n    R: (domain) => domain,\n    stereo: (domain) => domain,\n};\n","import * as math from 'mathjs';\nimport { Scope, Substitutions, ASTNode } from './types';\nimport assert from 'assert';\nimport { pp } from '../pp';\n\nexport class Simplifier {\n    constructor(\n        private readonly scope: Scope,\n        private readonly substitutions: Substitutions,\n    ) { }\n\n    simplify = (pipe: ASTNode): ASTNode => {\n        return this.simplifyPipeNode(pipe);\n    };\n\n    private simplifyPipeNode = (pipe: ASTNode): ASTNode => {\n        const n = assertNumberInNode('n', pipe);\n        const chain = assertDefInNode('chain', pipe);\n\n        return {\n            n,\n            chain: chain.map(this.simplifyFunNode),\n        };\n    };\n\n    private simplifyFunNode = (fun: ASTNode): ASTNode => {\n        const fn = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n\n        return {\n            fn,\n            args: args.map(this.simplifyFunArgNode),\n        };\n    };\n\n    private simplifyFunArgNode = (arg: ASTNode): ASTNode => {\n        if (arg.id) {\n            return this.simplifyVarNode(arg);\n        } else {\n            return this.simplifyArithNode(arg);\n        }\n    };\n\n    private simplifyArithNode = (arith: ASTNode): ASTNode => {\n        if (arith.op != null) {\n            const operands = assertDefInNode('operands', arith);\n            return { op: arith.op, operands: operands.map(this.simplifyArithNode) };\n        } else {\n            return this.simplifyNumberNode(arith);\n        }\n    };\n\n    private simplifyVarNode = (node: ASTNode): ASTNode => {\n        const id = node.id;\n        if (id in this.substitutions) {\n            return this.simplifyArithNode(this.substitutions[id]);\n        } else if (id in Math && typeof Math[id] === 'function') {\n            return { id, value: Math[id] };\n        } else {\n            return { id, value: math.evaluate(id, this.scope) };\n        }\n    };\n\n    private simplifyNumberNode = (scalar: ASTNode): ASTNode => {\n        const { id, value } = scalar;\n        if (value != null) {\n            return scalar;\n        } else if (id in this.substitutions) {\n            return this.simplifyArithNode(this.substitutions[id]);\n        } else if (id) {\n            const result = math.evaluate(id, this.scope);\n            assert.equal(typeof result, 'number', `Expected evaluation of ${pp(id)} to produce a number`);\n            return { id, value: result };\n        } else {\n            return scalar;\n        }\n    };\n}\n\nconst assertDefInNode = (name: string, node: ASTNode) => {\n    const x = node[name];\n    assertCondInNode(x != null, name, 'to be defined', node);\n    return x;\n};\n\nconst assertNumberInNode = (name: string, node: ASTNode): number => {\n    const x = node[name];\n    assertCondInNode(typeof x === 'number', name, 'a number', node);\n    return x as number;\n};\n\nconst assertCondInNode = (cond: boolean, name: string, expected: string, node: ASTNode) => {\n    assert(cond, `Expected ${name} to be ${expected} in ${pp(node)}`);\n};\n","import { parse } from './grammar.pegjs';\nimport { ASTNode } from './types';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\n\nconst logger = getLogger('Parser');\nlogger.setDefaultLevel('info');\n\ntype Options = {\n    startRule: 'arith';\n};\n\nconst loggingParse: typeof parse = (expr: string, options?: Options): ASTNode => {\n    try {\n        const node = parse(expr, options);\n        logger.debug(`parsed ${expr} into node ${pp(node)}`);\n        return node;\n    } catch (err) {\n        logger.error(`error parsing ${expr} at ${pp(err.location)}: ${err.message}`);\n        throw err;\n    }\n};\n\nexport class Parser {\n    static parsePipe = (pipe: string) => loggingParse(pipe);\n\n    static parseArith = (expr: string) => loggingParse(expr, { startRule: 'arith' });\n}\n","import { Scope, CompiledAST, NormalizedParams } from './types';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\nimport { Resolver } from './resolver';\nimport { Simplifier } from './simplifier';\nimport { Parser } from './parser';\n\nconst logger = getLogger('Compiler');\nlogger.setDefaultLevel('info');\n\nexport class Compiler {\n    constructor(private readonly scope: Scope) { }\n\n    compile = (params: NormalizedParams): CompiledAST => {\n        const ast = Parser.parsePipe(params.pipe);\n        logger.debug(`parsed params into ast ${pp(ast)}`);\n        const substitutions = {\n            theta: Parser.parseArith(params.theta),\n        };\n        const simplifier = new Simplifier(this.scope, substitutions);\n        const resolver = new Resolver(this.scope);\n        return resolver.resolve(simplifier.simplify(ast));\n    };\n}\n","import { CompositeFn } from \"../fn/fn\";\nimport { CompiledAST, Scope, HL, Chunk } from \"./types\";\nimport { Data, Vector } from \"../data\";\nimport { pp } from \"../pp\";\nimport { getLogger } from \"loglevel\";\nimport { round } from \"mathjs\";\nimport assert from 'assert';\nimport { Color } from \"three\";\n\nconst logger = getLogger('Evaluator');\n\nexport class Evaluator {\n    private readonly n: number;\n    private readonly init: CompositeFn;\n    private readonly iter: CompositeFn;\n    private readonly offset: number;\n    private readonly limit: number;\n\n    constructor(\n        private readonly scope: Scope,\n        ast: CompiledAST,\n        private readonly hl: HL,\n        chunk: Chunk,\n    ) {\n        const { n, init, iter } = ast;\n        const offset = chunk.offset;\n        const size = chunk.size;\n        const limit = offset + size;\n        assert(offset >= 0, `offset must be non-negative; got ${offset}`);\n        assert(limit <= n, `offset + size must be <= n; got ${offset} + ${size} = ${limit} > ${n}`);\n\n        this.n = n;\n        this.init = init;\n        this.iter = iter;\n        this.offset = offset;\n        this.limit = limit;\n    }\n\n\n    private get d() {\n        return this.iter.d;\n    }\n\n    initialize = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { n, init, offset, limit } = this;\n        const input = Data.input(data);\n        let i = offset;\n        for (const y of init.sample(n, offset, limit)) {\n            Data.set(input, y, i++, init.d);\n        }\n    };\n\n    iterate = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { init, iter, scope, n, offset, limit } = this;\n        const input = Data.input(data);\n        const position = Data.position(data);\n        const start = Date.now();\n\n        assert.equal(data[Data.nOffset], n, `n(data) != n(evaluator)`);\n        assert.equal(data[Data.inputOffset], init.d, `d0(data) != d0(evaluator)`);\n        assert.equal(data[Data.positionOffset(data)], iter.d, 'd(data) != d(evaluator)');\n\n        logger.debug(`iterating using ${pp(scope)}, ${pp(iter)}`);\n        for (let i = offset; i < limit; i++) {\n            iter.fn(Data.get(input, i, init.d), Data.get(position, i, iter.d));\n        }\n\n        this.computeColors(data);\n\n        logger.debug(`iteration complete in ${Date.now() - start}ms`);\n    };\n\n    private computeColors = (data: Vector) => {\n        logger.debug(`computing colors`);\n        const { d, scope, hl, offset, limit } = this;\n        const position = Data.position(data);\n        const color = Data.color(data);\n\n        for (let i = offset; i < limit; i++) {\n            const p = Data.get(position, i, d);\n            const colorScope = { ...scope, p, i };\n            const hue = round(hl.h.evaluate(colorScope), 0);\n            const lightness = round(hl.l.evaluate(colorScope), 0);\n            const c = new Color(`hsl(${hue}, 100%, ${lightness}%)`);\n\n            Data.set(color, [c.r, c.g, c.b], i, 3);\n        }\n\n    };\n}\n","import * as math from 'mathjs';\nimport { getLogger } from 'loglevel';\nimport { Params, Scope, NormalizedParams, CompiledAST, HL, Chunk } from './types';\nimport { Compiler } from './compiler';\nimport { Evaluator } from './evaluator';\n\nconst logger = getLogger('Pipe');\nlogger.setLevel('info');\n\nexport class Pipe {\n    static compile = (params: Params): CompiledAST => {\n        return Pipe.compileNormal(Pipe.normalized(params));\n    };\n    static evaluatorFor = (params: Params, chunk?: Chunk) => {\n        return Pipe.evaluatorForNormal(Pipe.normalized(params), chunk);\n    };\n\n    private static evaluatorForNormal = (params: NormalizedParams, chunk?: Chunk) => {\n        const ast = Pipe.compileNormal(params);\n        const scope = Pipe.finalScope(params, ast);\n        const hl = Pipe.compileHL(params);\n        return new Evaluator(scope, ast, hl, chunk);\n    };\n\n    private static compileNormal = (params: NormalizedParams): CompiledAST => {\n        const { power, chroma, t } = params;\n        return new Compiler({ t, power, chroma }).compile(params);\n\n    };\n\n    private static normalized = (params: Params): NormalizedParams => {\n        return {\n            pipe: params.pipe,\n            theta: params.theta || 't',\n            h: params.h || '1',\n            l: params.l || '0.5',\n            t: params.t || 0,\n            power: params.power || 0,\n            chroma: params.chroma || 0,\n        };\n    };\n\n    private static finalScope = (params: NormalizedParams, ast: CompiledAST): Scope => {\n        const { power, t, chroma } = params;\n        const scope: Scope = { t, power, chroma, n: ast.n };\n        scope.theta = math.evaluate(params.theta, scope);\n\n        return scope;\n    };\n\n    private static compileHL = (params: NormalizedParams): HL => {\n        return {\n            h: math.compile(`360 * (${params.h})`),\n            l: math.compile(`100 * (${params.l})`),\n        };\n    };\n}\n"],"sourceRoot":""}