{"version":3,"sources":["webpack:///./src/core/pp.ts","webpack:///./src/client/inputs.ts","webpack:///./src/core/data.ts","webpack:///./src/client/audio/graph.ts","webpack:///./src/client/audio/index.ts","webpack:///./src/client/audio/constants.ts","webpack:///./src/client/params.ts","webpack:///./src/client/constants.ts","webpack:///./src/client/data.ts","webpack:///./src/core/pipe/pool.ts","webpack:///./src/core/pipe/pipe.worker.ts","webpack:///./src/core/pipe/grammar.pegjs","webpack:///./src/client/audio/power.worklet.ts","webpack:///./src/core/fn/fn.ts","webpack:///./src/core/fn/interval.ts","webpack:///./src/core/fn/cube.ts","webpack:///./src/core/fn/rotator.ts","webpack:///./src/core/fn/sphere.ts","webpack:///./src/core/fn/spiral.ts","webpack:///./src/core/fn/torus.ts","webpack:///./src/core/fn/fucked_up_torus.ts","webpack:///./src/core/fn/stereo.ts","webpack:///./src/core/fn/identity.ts","webpack:///./src/core/pipe/resolver.ts","webpack:///./src/core/pipe/simplifier.ts","webpack:///./src/core/pipe/parser.ts","webpack:///./src/core/pipe/compiler.ts","webpack:///./src/core/pipe/evaluator.ts","webpack:///./src/core/pipe/pipe.ts"],"names":["pp","a","p","JSON","stringify","initialValues","pipe","theta","h","l","animate","sound","subjects","streams","persistence","query","URLSearchParams","window","location","search","key","get","saved","Object","entries","value","localStorage","getItem","restore","Subject","asObservable","values","Proxy","set","target","property","oldValue","success","Reflect","setItem","toString","persist","next","newValue","event","Data","constructor","n","d","position","color","buffer","data","Float32Array","nOffset","positionOffset","d0","SharedArrayBuffer","inputOffset","arr","offset","subarray","inputLength","positionLength","colorOffset","i","stride","assert","length","AudioGraph","ctx","source","subject","this","close","power","AudioWorkletNode","channelCountMode","channelCount","connect","destination","port","onmessage","msg","onprocessorerror","err","error","mediaStream","AudioContext","audioWorklet","addModule","processorUrl","MediaStreamAudioSourceNode","graph","logger","getLogger","BehaviorSubject","chroma","stream","inputs","subscribe","info","navigator","mediaDevices","getUserMedia","audio","create","warn","music","floor","fftSize","t","interval","emit","setDefaultLevel","webWorkerSource","console","startPool","hardwareConcurrency","getData","params","runPipeline","then","fromBuffer","inFlight","logged","debug","Date","now","pool","setLevel","poolSize","size","Pool","spawn","Worker","Map","promises","push","queue","Promise","all","events","initialize","timing","forkJoin","chunk","w","iterate","getOrInitialize","getKey","has","bufferFor","op","ceil","Math","min","label","start","elapsed","init","iter","Pipe","compile","slice","module","exports","peg$SyntaxError","message","expected","found","name","Error","captureStackTrace","child","parent","ctor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","escapedParts","parts","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toUpperCase","s","replace","j","descriptions","type","sort","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","peg$parsepipe","arith","peg$parsearith","peg$startRuleFunction","peg$c0","chain","parseInt","peg$c1","head","tail","peg$c2","f","peg$c3","fn","args","peg$c4","peg$c5","operands","peg$c6","peg$c7","peg$c8","id","peg$c9","parseFloat","peg$c10","peg$c11","peg$c12","peg$classExpectation","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$literalExpectation","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s3","peg$parseuint","peg$parsepipe_sep","peg$parsechain","peg$parsefun","peg$parseidentifier","peg$parselparen","peg$parsefun_args","peg$parsefun_arg","s2","peg$parse_","peg$parsefn_arg_sep","peg$parserparen","peg$parseid","peg$parsescalar","substr","substring","peg$parsearith_op","s4","s5","s6","test","charAt","peg$parsemantissa","peg$parseint","peg$parsefloat","peg$parsenumber","peg$parse__","cos","sin","exp","tan","tanh","components","from","keys","CompositeFn","fns","limit","first","rest","x","sample","apply","y","domain","equal","max","domainMax","dMax","last","reduce","Interval","b","nPerLevel","points","pop","successors","nthRoot","Cube","fill","Rotator","d1","f0","f1","cube","r0","r1","Sphere","r","tau","phi","root","map","Spiral","k","sphere","Torus","cross","rotator","FuckedUpTorus","circle","q","Stereo","to","fromTemp","toTemp","up","down","temp","n2","norm2","divisor","result","Identity","Resolver","scope","resolvePipeNode","assertDefInNode","links","fun","shift","link","resolveFirstFunNode","assertNumberInNode","resolveFunNode","buildComposites","builder","Builder","isTemporal","add","build","funs","resolveFunArgNode","some","isNodeTemporal","prev","ranges","arg","resolveVarNode","resolveArithNode","node","ops","resolveNumberNode","fail","assertCondInNode","cond","rotate","spiral","torus","fucked_up_torus","R","stereo","Simplifier","substitutions","simplifyPipeNode","simplifyFunNode","simplifyFunArgNode","simplifyVarNode","simplifyArithNode","simplifyNumberNode","math","scalar","loggingParse","expr","Parser","Compiler","ast","parsePipe","parseArith","simplifier","resolve","simplify","Evaluator","hl","computeColors","colorScope","hue","round","evaluate","lightness","c","Color","g","compileNormal","normalized","evaluatorForNormal","finalScope","compileHL"],"mappings":"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","file":"4.b23a38d80db06fdff16a.js","sourcesContent":["export const pp = (a: any, p = 2) => JSON.stringify(a, null, p);\n","import { Observable, Subject } from 'rxjs';\n\nconst initialValues = {\n    pipe: '10000->sphere(4, 1)->R(theta, 0, 1, cos, tan)->R(theta, 0, 2)->R(theta, 0, 3)->stereo(3)',\n    theta: 'pi * t / 20 + pi * power / 20',\n    h: 'chroma * i / n',\n    l: '0.2 + 0.8 * power',\n    animate: true,\n    sound: false,\n};\nexport type Inputs = typeof initialValues;\n\ntype Change<T> = {\n    newValue: T;\n    oldValue?: T;\n    event?: Event;\n};\nconst subjects: { [P in keyof Inputs]?: Subject<Change<Inputs[P]>> } = {};\n\nexport const streams: { [P in keyof Inputs]?: Observable<Change<Inputs[P]>> } = {};\n\nconst persistence: { [P in keyof Inputs]: boolean } = {\n    pipe: true,\n    theta: true,\n    h: true,\n    l: true,\n    animate: false,\n    sound: false,\n};\n\nconst persist = () => {\n    for (const [key, value] of Object.entries(values)) {\n        if (persistence[key]) {\n            localStorage.setItem(`inputs.${key}`, value.toString());\n        };\n    }\n};\n\nconst restore = () => {\n    // TODO (maybe): also support override from window.location.hash\n    for (const [key, saved] of Object.entries(persistence)) {\n        if (saved) {\n            const value = localStorage.getItem(`inputs.${key}`);\n            if (value) initialValues[key] = value;\n        };\n    }\n};\n\nconst query = new URLSearchParams(window.location.search);\nif (query.get('restore') !== '0') {\n    restore();\n}\n\nfor (const key in initialValues) {\n    subjects[key] = new Subject();\n    streams[key] = subjects[key].asObservable();\n}\n\nexport const values = new Proxy(initialValues, {\n    set(target, property, value) {\n        const oldValue = target[property];\n        const success = Reflect.set(target, property, value);\n        if (query.get('persist') !== '0') persist();\n        subjects[property].next({ newValue: value, event: window.event, oldValue });\n        return success;\n    }\n});\n","import assert from 'assert';\n\nexport type Vector = Float32Array;\n\nexport class Data {\n    constructor(\n        readonly n: number,\n        readonly d: number,\n        readonly position: Float32Array,\n        readonly color: Float32Array\n    ) { }\n\n    static fromBuffer = (buffer: ArrayBuffer) => {\n        const data = new Float32Array(buffer);\n        const n = data[Data.nOffset];\n        const d = data[Data.positionOffset(data)];\n        const position = Data.position(data);\n        const color = Data.color(data);\n        return new Data(n, d, position, color);\n    };\n\n    static bufferFor = (n: number, d0: number, d: number): SharedArrayBuffer => {\n        const bytesPerNum = 4;\n        const count = 3 + n * (d0 + d + 3);\n        const byteLength = bytesPerNum * count;\n        const buffer = new SharedArrayBuffer(byteLength);\n        const data = new Float32Array(buffer);\n        data[Data.nOffset] = n;\n        data[Data.inputOffset] = d0;\n        data[Data.positionOffset(data)] = d;\n        return buffer;\n    };\n\n    static input = (arr: Float32Array) => {\n        const offset = Data.inputOffset + 1;\n        return arr.subarray(offset, offset + Data.inputLength(arr));\n    };\n\n    static position = (arr: Float32Array) => {\n        const offset = Data.positionOffset(arr) + 1;\n        return arr.subarray(offset, offset + Data.positionLength(arr));\n    };\n\n    static color = (arr: Float32Array) => {\n        const offset = Data.colorOffset(arr);\n        return arr.subarray(offset);\n    };\n\n    static nOffset = 0;\n\n    static inputOffset = Data.nOffset + 1;\n    private static inputLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d0 = arr[Data.inputOffset];\n        return n * d0;\n    };\n\n    static positionOffset = (arr: Float32Array) =>\n        Data.inputOffset + Data.inputLength(arr) + 1;\n    private static positionLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d = arr[Data.positionOffset(arr)];\n        return n * d;\n    };\n\n    static colorOffset = (arr: Float32Array) =>\n        Data.positionOffset(arr) + Data.positionLength(arr) + 1;\n\n    static get = (arr: Vector, i: number, stride: number) => {\n        const offset = i * stride;\n        return arr.subarray(offset, offset + stride);\n    };\n\n    static set = (arr: Vector, value: ArrayLike<number>, i: number, stride: number) => {\n        assert(value.length <= stride);\n        const offset = i * stride;\n        return arr.set(value, offset);\n    };\n}\n","import { Subject } from \"rxjs\";\nimport { Audio } from './types';\nimport processorUrl from './power.worklet';\n\nexport class AudioGraph {\n\n    static create = async (mediaStream: MediaStream, subject: Subject<Audio>) => {\n        const ctx = new AudioContext();\n        await ctx.audioWorklet.addModule(processorUrl);\n        const source = new MediaStreamAudioSourceNode(ctx, { mediaStream });\n        return new AudioGraph(ctx, source, subject);\n    };\n\n    constructor(\n        private readonly ctx: AudioContext,\n        source: AudioNode,\n        subject: Subject<Audio>,\n    ) {\n        const power = new AudioWorkletNode(ctx, 'power', {\n            channelCountMode: 'explicit',\n            channelCount: 1,\n        });\n        source.connect(power).connect(ctx.destination);\n        power.port.onmessage = (msg) => subject.next(msg.data as Audio);\n        power.onprocessorerror = (err) => subject.error(err);\n    }\n\n    close = () => this.ctx.close();\n}\n","import { BehaviorSubject, interval, Observable } from 'rxjs';\nimport { getLogger } from 'loglevel';\nimport * as inputs from '../inputs';\nimport { Audio } from './types';\nimport { SILENCE } from './constants';\nimport { AudioGraph } from './graph';\n\nconst logger = getLogger('Audio');\n\nconst subject = new BehaviorSubject<Audio>(SILENCE);\nexport const stream = subject.asObservable();\nlet graph: AudioGraph;\n\ninputs.streams.sound.subscribe(async ({ newValue, event }) => {\n    if (newValue && event) {\n        logger.info('getting user media');\n        const stream = await navigator.mediaDevices\n            .getUserMedia({ audio: true });\n        logger.info('starting new audio graph');\n        graph = await AudioGraph.create(stream, subject);\n    } else if (!newValue && graph) {\n        logger.info('closing audio graph');\n        graph.close();\n    } else {\n        logger.warn(`inputs.streams.sound changed, but there was nothing to do: `, event);\n    }\n});\n","import { Audio } from \"./types\";\n\nexport const SILENCE: Audio = {\n    power: 0,\n    chroma: 0,\n};\n\nexport const chromaCount = 6;\nexport const octaveMin = 0;\nexport const octaveMax = 8;\nexport const octaveCount = octaveMax - octaveMin;\nexport const frameSize = 128;\nexport const noteCount = octaveCount * chromaCount;\n","import * as audio from './audio';\nimport { Params } from '../core/pipe/types';\nimport { Subject, interval } from 'rxjs';\nimport { values } from './inputs';\nimport { fps } from './constants';\nimport { Audio } from './audio/types';\n\nconst subject = new Subject<Params>();\nexport const stream = subject;\nlet t = 0;\n\nlet music: Audio;\naudio.stream.subscribe(\n    a => music = a,\n    err => subject.error(err),\n);\n\nconst emit = () => {\n    const { power, chroma } = music;\n    stream.next({\n        pipe: values.pipe,\n        theta: values.theta,\n        h: values.h,\n        l: values.l,\n        t,\n        power,\n        chroma,\n    });\n    t += 1 / fps;\n};\n\ninterval(1000 / fps).subscribe(\n    () => values.animate && emit(),\n    err => subject.error(err),\n);\n","import { floor } from 'mathjs';\n\n// TODO make these inputs :D\nexport const fps = 60;\nexport const dataSampleRate = fps / 1000;\nexport const audioSampleRate = 2 * dataSampleRate;\nexport const fftSize = 1024;\nexport const psdSize = floor(fftSize / 2) + 1;\n","import { Observable, timer, Subject, interval, EMPTY } from 'rxjs';\nimport { retryWhen, delayWhen, repeatWhen, tap } from 'rxjs/operators';\nimport { Data } from '../core/data';\nimport { Params } from \"../core/pipe/types\";\nimport { startPool, runPipeline } from '../core/pipe/pool';\nimport * as params from './params';\nimport { getLogger } from 'loglevel';\nimport { pp } from '../core/pp';\n\nconst logger = getLogger('Data');\nlogger.setDefaultLevel('info');\nconst subject = new Subject<Data>();\n\nexport const stream = subject.asObservable();\n\ntype Source = {\n  getData(params: Params): Promise<Data>;\n};\n\nconst webWorkerSource = async (): Promise<Source> => {\n  console.info('starting web worker data source');\n  await startPool(navigator.hardwareConcurrency);\n\n  const getData = (params: Params) =>\n    runPipeline(params).then(Data.fromBuffer);\n\n  return { getData };\n};\n\n(async () => {\n  const { getData } = await webWorkerSource();\n  let inFlight: Promise<Data> | null;\n  let logged = 0;\n\n  params.stream.subscribe(\n    async (params) => {\n      if (inFlight) return;\n      logger.debug('requesting data with params', params);\n      if (Date.now() - logged >= 1000) {\n        logger.info(`sending request for data with params ${pp(params)}`);\n        logged = Date.now();\n      }\n      // TODO i feel like there's a more rx-y way to do this\n      inFlight = getData(params);\n      try {\n        subject.next(await inFlight);\n      } catch (err) {\n        subject.error(err);\n      } finally {\n        inFlight = null;\n      }\n    },\n    err => subject.error(err),\n  );\n})();\n","import { spawn, Worker, Pool, ModuleThread } from \"threads\";\nimport { getLogger } from 'loglevel';\nimport { Params, PipelineWorker, Chunk } from './types';\nimport { Pipe } from \"./pipe\";\nimport { ceil } from \"mathjs\";\nimport { Data } from \"../data\";\n\nconst logger = getLogger('PipelinePool');\nlet pool: Pool<ModuleThread<PipelineWorker>>;\nlet data: Map<string, SharedArrayBuffer>;\nlogger.setLevel('info');\nlet poolSize = 0;\n\nexport const startPool = async (size: number) => {\n    logger.info('starting worker pool');\n    pool = Pool(() => spawn(new Worker('./pipe.worker')), size);\n    poolSize = size;\n    data = new Map();\n    let promises = [];\n    for (let i = 0; i < size; i++) {\n        // pre-load scripts so the first task doesn't take forever\n        promises.push(pool.queue(async () => { }));\n    }\n    await Promise.all(promises);\n\n    pool.events().subscribe((event: any) => {\n        if (event.error) {\n            logger.error('received error event from worker pool', event);\n        }\n    });\n};\n\nexport const stopPool = async (): Promise<void> => {\n    logger.info('waiting for pending tasks to complete before terminating pool');\n    try {\n        await pool.terminate(true);\n    } catch (err) {\n        logger.error(err);\n    } finally {\n        pool = null;\n    }\n};\n\nconst initialize = (params: Params, n: number, buffer: SharedArrayBuffer): Promise<void> => {\n    return timing('initialization')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.initialize(params, chunk, buffer));\n        });\n    });\n};\n\nconst iterate = (params: Params, n: number, buffer: SharedArrayBuffer) => {\n    return timing('iteration')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.iterate(params, chunk, buffer));\n        });\n    });\n};\n\nconst getKey = (params: Params) => JSON.stringify({\n    pipe: params.pipe,\n    theta: params.theta,\n    h: params.h,\n    l: params.l,\n});\n\nconst getOrInitialize = async (params: Params, n: number, d0: number, d: number): Promise<SharedArrayBuffer> => {\n    const key = getKey(params);\n    if (!data.has(key)) {\n        const buffer = Data.bufferFor(n, d0, d);\n        await initialize(params, n, buffer);\n        data.set(key, buffer);\n    }\n    return data.get(key);\n};\n\nconst forkJoin = async (n: number, op: (chunk: Chunk) => Promise<void>) => {\n    const size = ceil(n / poolSize);\n    let promises = [];\n    for (let offset = 0; offset < n; offset += size) {\n        const chunk = { offset, size: Math.min(n - offset, size) };\n        promises.push(op(chunk));\n    }\n    await Promise.all(promises);\n};\n\nconst timing = (label: string) => async<T>(op: () => Promise<T>) => {\n    const start = Date.now();\n    const t = await op();\n    const elapsed = Date.now() - start;\n    logger.debug(`${label} took ${elapsed}ms`);\n    return t;\n};\n\nexport const runPipeline = async (params: Params): Promise<SharedArrayBuffer> => {\n    const { n, init, iter } = Pipe.compile(params);\n    const buffer = await getOrInitialize(params, n, init.d, iter.d);\n    await iterate(params, n, buffer);\n\n    return buffer.slice(0);\n};\n","module.exports = __webpack_public_path__ + \"0.157fc31b9e72b36d6bd3.worker.js\"","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { pipe: peg$parsepipe, arith: peg$parsearith },\n      peg$startRuleFunction  = peg$parsepipe,\n\n      peg$c0 = function(n, chain) {\n        return {n: parseInt(n), chain};\n      },\n      peg$c1 = function(head, tail) { return [head, ...tail]; },\n      peg$c2 = function(f) { return [f]; },\n      peg$c3 = function(fn, args) { return {fn, args} },\n      peg$c4 = function(a) { return [a]; },\n      peg$c5 = function(s, op, a) { return {op, operands: [s, a]}; },\n      peg$c6 = function(a) { return a; },\n      peg$c7 = function(value) { return {value}; },\n      peg$c8 = function(id) { return {id}; },\n      peg$c9 = function(f) { return parseFloat(f); },\n      peg$c10 = function(i) { return parseInt(i); },\n      peg$c11 = /^[a-zA-Z]/,\n      peg$c12 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n      peg$c13 = /^[a-zA-Z0-9]/,\n      peg$c14 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n      peg$c15 = function(id) { return id; },\n      peg$c16 = /^[+\\-]/,\n      peg$c17 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c18 = /^[0-9]/,\n      peg$c19 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c20 = /^[eE]/,\n      peg$c21 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c22 = \".\",\n      peg$c23 = peg$literalExpectation(\".\", false),\n      peg$c24 = \"+\",\n      peg$c25 = peg$literalExpectation(\"+\", false),\n      peg$c26 = \"-\",\n      peg$c27 = peg$literalExpectation(\"-\", false),\n      peg$c28 = \"*\",\n      peg$c29 = peg$literalExpectation(\"*\", false),\n      peg$c30 = \"/\",\n      peg$c31 = peg$literalExpectation(\"/\", false),\n      peg$c32 = \"**\",\n      peg$c33 = peg$literalExpectation(\"**\", false),\n      peg$c34 = \"^\",\n      peg$c35 = peg$literalExpectation(\"^\", false),\n      peg$c36 = function(op) { return op; },\n      peg$c37 = \"(\",\n      peg$c38 = peg$literalExpectation(\"(\", false),\n      peg$c39 = \")\",\n      peg$c40 = peg$literalExpectation(\")\", false),\n      peg$c41 = \",\",\n      peg$c42 = peg$literalExpectation(\",\", false),\n      peg$c43 = \"->\",\n      peg$c44 = peg$literalExpectation(\"->\", false),\n      peg$c45 = \"=>\",\n      peg$c46 = peg$literalExpectation(\"=>\", false),\n      peg$c47 = /^[ \\t\\n\\r]/,\n      peg$c48 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepipe() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseuint();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsechain() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefun();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefun();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselparen();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefun_args();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserparen();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun_args() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefun_arg();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefn_arg_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefun_args();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefun_arg();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun_arg() {\n    var s0;\n\n    s0 = peg$parseid();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsearith();\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsescalar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsearith_op();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsearith();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c5(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsescalar();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parselparen();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsearith();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parserparen();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c6(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsescalar() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseid();\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c8(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefloat();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseint();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c10(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      if (peg$c11.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        if (peg$c13.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c14); }\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          if (peg$c13.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloat() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c18.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsemantissa();\n        if (s4 !== peg$FAILED) {\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseint();\n            if (s6 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5, s6];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseint();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemantissa();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseint() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseuint() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c18.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c18.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemantissa() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c22;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith_op() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s3 = peg$c24;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s3 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s3 = peg$c26;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c27); }\n        }\n        if (s3 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s3 = peg$c28;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c29); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c30;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c31); }\n            }\n            if (s3 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c32) {\n                s3 = peg$c32;\n                peg$currPos += 2;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c33); }\n              }\n              if (s3 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 94) {\n                  s3 = peg$c34;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c35); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c36(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c37;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 41) {\n        s2 = peg$c39;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefn_arg_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c41;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepipe_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c43) {\n        s3 = peg$c43;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c45) {\n            s3 = peg$c45;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c46); }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c47.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","module.exports = __webpack_public_path__ + \"6e617084a0854bd6ec19.worklet.js\";","import { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport const cos = Math.cos;\nexport const sin = Math.sin;\nexport const tan = Math.tan;\nexport const tanh = Math.tanh;\nexport const exp = Math.exp;\n\nexport const components = (d) => Array.from(new Array(d).keys());\n\nexport interface Fn {\n  readonly d: number;\n  readonly domain: number;\n  fn(x: Vector, y?: Vector): Vector;\n  sample(n: number, offset: number, limit: number): Generator<Vector>;\n}\n\nexport class CompositeFn implements Fn {\n  private readonly x: Vector;\n  private readonly y: Vector;\n  constructor(readonly fns: Fn[]) {\n    assert(fns.length, 'fns cannot be empty');\n\n    const length = Math.max(this.domainMax, this.dMax);\n    this.x = new Float32Array(length);\n    this.y = new Float32Array(length);\n\n  }\n\n  get first() {\n    return this.fns[0];\n  }\n\n  get last() {\n    return this.fns[this.fns.length - 1];\n  }\n\n  get domain() {\n    return this.first.domain;\n  }\n\n  get d() {\n    return this.last.d;\n  }\n\n  get domainMax() {\n    return this.fns.reduce((max, f) => Math.max(f.domain, max), 0);\n  }\n\n  get dMax() {\n    return this.fns.reduce((max, f) => Math.max(f.d, max), 0);\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { fns, d } = this;\n    const [first, ...rest] = fns;\n    if (fns.length == 0) return [];\n\n    for (const x of first.sample(n, offset, limit)) {\n      this.x.set(x);\n      if (rest.length) {\n        CompositeFn.apply(rest, this.x, this.y);\n      } else {\n        this.y.set(x);\n      }\n      yield this.y.subarray(0, d);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { fns, domain, d } = this;\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    this.x.set(x);\n    CompositeFn.apply(fns, this.x, this.y);\n    y.set(this.y.subarray(0, d));\n    return y;\n  };\n\n  private static apply = (fns: Fn[], x: Vector, y: Vector) => {\n    assert.equal(x.length, y.length);\n    for (const f of fns) {\n      f.fn(x.subarray(0, f.domain), y.subarray(0, f.d));\n      x.set(y);\n    }\n  };\n\n  static Builder = class {\n    private readonly fns: Fn[] = [];\n\n    get d() {\n      return this.last.d;\n    }\n\n    get last() {\n      return this.fns[this.fns.length - 1];\n    }\n\n    add = (fn: Fn) => {\n      const { fns, last } = this;\n      if (last && fn.domain !== last.d) {\n        throw new Error(\n          `Cannot add ${fn} to composite, because its domain is not ${last.d}`,\n        );\n      }\n      fns.push(fn);\n      return this;\n    };\n\n    build = () => {\n      return new CompositeFn(this.fns);\n    };\n  };\n}\n","import { floor, nthRoot } from 'mathjs';\nimport { Fn } from './fn';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Interval implements Fn {\n  readonly domain: number;\n\n  constructor(readonly d: number, readonly a: number[], readonly b: number[]) {\n    assert.equal(a.length, d);\n    assert.equal(b.length, d);\n    this.domain = d;\n  }\n\n  static nPerLevel = (d: number, n: number) => floor(nthRoot(n, d) as number);\n\n  static n = (d: number, n: number) => Interval.nPerLevel(d, n) ** d;\n\n  /**\n   * @param x A vector of length this.domain contained in the interval [0, 1].\n   * @returns A mapping of the vector into this interval.\n   */\n  fn = (x: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, b, d } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    for (let i = 0; i < d; i++) {\n      y[i] = a[i] + x[i] * (b[i] - a[i]);\n    }\n    return y;\n  };\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { d, fn } = this;\n    n = Interval.nPerLevel(d, n);\n    const points: number[][] = [[]];\n    let i = 0;\n\n    while (points.length && i < limit) {\n      const p = points.pop()!;\n      if (p.length < d) {\n        points.push(...successors(p));\n      } else if (i++ >= offset) {\n        yield fn(p);\n      }\n    }\n\n    function* successors(p: number[]): Generator<number[]> {\n      for (let i = 0; i < n; i++) {\n        yield [...p, i / n];\n      }\n    }\n  };\n}\n","import Interval from \"./interval\";\nimport { Fn } from \"./fn\";\nimport { Vector } from \"../data\";\n\nexport default class Cube implements Fn {\n  private readonly interval: Interval;\n\n  constructor(readonly d: number, readonly l: number) {\n    this.interval = new Interval(\n      d,\n      new Array(d).fill(-l / 2),\n      new Array(d).fill(l / 2)\n    );\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  fn = (x: Vector, y?: Vector) => this.interval.fn(x, y);\n\n  sample = (n: number, offset: number, limit: number) =>\n    this.interval.sample(n, offset, limit);\n}\n","import { Fn, cos, sin } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Rotator implements Fn {\n  readonly r0: number;\n  readonly r1: number;\n\n  constructor(\n    readonly d: number,\n    readonly theta: number,\n    readonly d0: number,\n    readonly d1: number,\n    readonly f0: (theta: number) => number = cos,\n    readonly f1: (theta: number) => number = sin,\n  ) {\n    this.r0 = f0(theta);\n    this.r1 = f1(theta);\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const p of cube.sample(n, offset, limit)) {\n      yield this.fn(p);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, d0, d1, r0, r1 } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    y.set(x);\n\n    const a = x[d0], b = x[d1];\n    y[d0] = a * r0 - b * r1;\n    y[d1] = a * r1 + b * r0;\n    return y;\n  };\n}\n","import { equal } from 'mathjs';\nimport Rotator from './rotator';\nimport Cube from './cube';\nimport { tau, zeros } from 'mathjs';\nimport { Fn, components, CompositeFn } from './fn';\nimport { TypedArray } from 'three';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Sphere implements Fn {\n  private readonly root: Float32Array;\n\n  constructor(readonly d: number, r: number) {\n    this.root = new Float32Array(d);\n    this.root[0] = r;\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, root } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    const r = new CompositeFn(components(d - 1).map((i) => new Rotator(d, phi[i], 0, i + 1)));\n    r.fn(root, y);\n    return y;\n  };\n}\n","import { Fn, exp, components } from './fn';\nimport Cube from './cube';\nimport Sphere from './sphere';\nimport { tau, sum, multiply } from 'mathjs';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Spiral implements Fn {\n  private readonly sphere: Sphere;\n\n  constructor(readonly d: number, readonly a: number[], readonly k: number[]) {\n    this.sphere = new Sphere(d, 1);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, k, domain, d } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    this.sphere.fn(phi, y);\n    let x = 0;\n    for (let i = 0; i < domain; i++) {\n      x += k[i] * phi[i];\n    };\n    const r = exp(x);\n    for (let i = 0; i < d; i++) {\n      y[i] = y[i] * a[i] * r;\n    }\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { tau } from 'mathjs';\nimport Rotator from './rotator';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Torus implements Fn {\n  private readonly cross: Sphere;\n\n  constructor(readonly d: number, readonly r: number, readonly t: number) {\n    assert(d > 2, `torus is only defined for d > 2; got ${d}`);\n    this.cross = new Sphere(d - 1, t);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (theta: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { cross, d, r } = this;\n    assert.equal(theta.length, d - 1, `torus expects an input of ${d - 1}; got ${theta.length}`);\n    const rotator = new Rotator(d, theta[d - 2], 0, d - 1);\n\n    cross.fn(theta.subarray(0, d - 2), y.subarray(0, d - 1));\n    y[0] += r;\n    rotator.fn(y, y);\n\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { tau } from 'mathjs';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\n// This shape does not implement a torus. It used to,\n// but then I changed the way Rotator works, which\n// changed the way that the points of the sphere are\n// distributed, making the translation step behave incorrectly\n// Still makes a cool shape though, so keeping it\nexport default class FuckedUpTorus implements Fn {\n    private readonly sphere: Sphere;\n    private readonly circle: Sphere;\n\n    constructor(readonly d: number, readonly r: number, readonly t: number) {\n        this.sphere = new Sphere(d, t);\n        this.circle = new Sphere(2, r);\n    }\n\n    get domain() {\n        return this.d - 1;\n    }\n\n    sample = function* (n: number, offset: number, limit: number) {\n        const cube = new Cube(this.domain, tau);\n        for (const phi of cube.sample(n, offset, limit)) {\n            yield this.fn(phi);\n        }\n    };\n\n    fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { domain, d, sphere, circle } = this;\n        assert.equal(phi.length, domain);\n        assert.equal(y.length, d);\n        sphere.fn(phi, y);\n        const q = circle.fn(phi.subarray(d - 2));\n        y[0] += q[0];\n        y[d - 1] += q[1];\n        return y;\n    };\n}\n","import { Fn } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Stereo implements Fn {\n  private readonly fromTemp: Vector;\n  private readonly toTemp: Vector;\n\n  constructor(private readonly from: number, private readonly to: number) {\n    this.fromTemp = new Float32Array(Math.max(from, to));\n    this.toTemp = new Float32Array(Math.max(from, to));\n  }\n\n  get domain() {\n    return this.from;\n  }\n\n  get d() {\n    return this.to;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.to)) => {\n    let { from, to, fromTemp, toTemp } = this;\n    assert.equal(x.length, from);\n    assert.equal(y.length, to);\n\n    if (from === to) {\n      y.set(x);\n      return y;\n    }\n\n    fromTemp.set(x);\n\n    while (from < to) {\n      Stereo.up(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, ++from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    while (from > to) {\n      Stereo.down(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, --from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    y.set(toTemp.subarray(0, to));\n    return y;\n  };\n\n  static up = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length + 1);\n    const n2 = norm2(x);\n    const divisor = n2 + 1;\n    temp[0] = (n2 - 1) / divisor;\n    for (let i = 1; i <= x.length; i++) {\n      temp[i] = (2 * x[i - 1]) / divisor;\n    }\n  };\n\n  static down = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length - 1);\n    for (let i = 0; i < temp.length; i++) {\n      temp[i] = x[i + 1] / (1 - x[0]);\n    }\n  };\n}\n\nconst norm2 = (x: Vector) => {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * x[i];\n  }\n  return result;\n};\n","import { Fn } from \"./fn\";\nimport Cube from \"./cube\";\nimport { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport class Identity implements Fn {\n    readonly domain: number;\n\n    constructor(readonly d: number) {\n        this.domain = d;\n    }\n\n    fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { d } = this;\n        assert.equal(x.length, d);\n        assert.equal(y.length, d);\n        y.set(x);\n        return y;\n    };\n\n    sample = function* (n: number, offset: number, limit: number) {\n        throw new Error('identity function does not support sampling');\n    };\n}\n","import { Scope, CompiledAST, Value, UnaryOperator, Link, ASTNode } from './types';\nimport assert from 'assert';\nimport { pp } from '../pp';\nimport { Fn, CompositeFn } from '../fn/fn';\nimport Cube from '../fn/cube';\nimport Spiral from '../fn/spiral';\nimport Torus from '../fn/torus';\nimport FuckedUpTorus from '../fn/fucked_up_torus';\nimport Sphere from '../fn/sphere';\nimport Stereo from '../fn/stereo';\nimport Rotator from '../fn/rotator';\nimport Interval from '../fn/interval';\nimport { Identity } from '../fn/identity';\n\nexport class Resolver {\n    constructor(private readonly scope: Scope) { }\n\n    resolve = (pipe: ASTNode): CompiledAST => {\n        return this.resolvePipeNode(pipe);\n    };\n\n    private resolvePipeNode = (pipe: ASTNode): CompiledAST => {\n        const chain = assertDefInNode('chain', pipe);\n        const links: Link[] = [];\n        const fun = chain.shift();\n        const d = fun.args.shift().value as number;\n        const link = this.resolveFirstFunNode(d, fun);\n        const n = Interval.n(link.fn.domain, assertNumberInNode('n', pipe));\n\n        links.push(link);\n\n        for (let i = 0; i < chain.length; i++) {\n            const fun = chain[i];\n            const link = this.resolveFunNode(links[i].fn, fun);\n            links.push(link);\n        }\n\n        const [init, iter] = this.buildComposites(links);\n        return { n, chain: links, init, iter };\n    };\n\n    private buildComposites = (links: Link[]) => {\n        let builder = new CompositeFn.Builder();\n        while (links.length && !links[0].isTemporal) {\n            builder.add(links.shift().fn);\n        }\n\n        const init = builder.build();\n        builder = new CompositeFn.Builder().add(new Identity(init.d));\n\n        while (links.length) {\n            builder.add(links.shift().fn);\n        }\n\n        const iter = builder.build();\n        return [init, iter];\n    };\n\n    private resolveFirstFunNode = (d: number, fun: ASTNode) => {\n        const name: string = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n        const fn = funs[name](d, ...args.map(this.resolveFunArgNode));\n        const isTemporal = args.some(isNodeTemporal);\n\n        return { fn, isTemporal };\n    };\n\n    private resolveFunNode = (prev: Fn, fun: ASTNode): Link => {\n        const name: string = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n        const d = ranges[name](prev.d);\n        const fn = funs[name](d, ...args.map(this.resolveFunArgNode));\n        const isTemporal = args.some(isNodeTemporal);\n\n        return { fn, isTemporal };\n    };\n\n    private resolveFunArgNode = (arg: ASTNode): Value => {\n        if (arg.id) {\n            return this.resolveVarNode(arg);\n        } else {\n            return this.resolveArithNode(arg);\n        }\n    };\n\n    private resolveArithNode = (node: ASTNode): number => {\n        if (node.op != null) {\n            const op = ops[node.op];\n            const [a, b] = assertDefInNode('operands', node)\n                .map(this.resolveArithNode);\n            const c = op(a, b);\n            return c;\n        } else {\n            return this.resolveNumberNode(node);\n        }\n    };\n\n    private resolveVarNode = (node: ASTNode): Value => {\n        const { value } = node;\n        if (typeof value === 'function') {\n            return value;\n        } else {\n            return this.resolveNumberNode(node);\n        }\n    };\n\n    private resolveNumberNode = (node: ASTNode): number => {\n        const { value } = node;\n        if (typeof value === 'number') {\n            return value;\n        } else {\n            assert.fail(`don't know how to handle number node ${pp(node)}`);\n        }\n    };\n}\n\nconst assertDefInNode = (name: string, node: ASTNode) => {\n    const x = node[name];\n    assertCondInNode(x != null, name, 'to be defined', node);\n    return x;\n};\n\nconst assertNumberInNode = (name: string, node: ASTNode): number => {\n    const x = node[name];\n    assertCondInNode(typeof x === 'number', name, 'a number', node);\n    return x as number;\n};\n\nconst assertCondInNode = (cond: boolean, name: string, expected: string, node: ASTNode) => {\n    assert(cond, `Expected ${name} to be ${expected} in ${pp(node)}`);\n};\n\nconst isNodeTemporal = (node: ASTNode): boolean => {\n    if (node.id === 't') return true;\n    else if (node.args) return node.args.some(isNodeTemporal);\n    else if (node.operands) return node.operands.some(isNodeTemporal);\n    else return false;\n};\n\nconst ops: {\n    [op: string]: (a: number, b: number) => number;\n} = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '*': (a, b) => a * b,\n    '/': (a, b) => a / b,\n    '**': (a, b) => a ** b,\n    '^': (a, b) => a ** b,\n};\n\nconst rotate = (\n    d: number,\n    theta: number,\n    d0: number,\n    d1: number,\n    f0: UnaryOperator = Math.cos,\n    f1: UnaryOperator = Math.sin,\n) => {\n    return new Rotator(d, theta, d0, d1, f0, f1);\n};\n\nconst funs: {\n    [op: string]: (d: number, ...rest) => Fn;\n} = {\n    cube: (d, l) => new Cube(d, l),\n    sphere: (d, r: number) => new Sphere(d, r),\n    spiral: (d, a: number, k: number) =>\n        new Spiral(d, new Array(d).fill(a), new Array(d - 1).fill(k)),\n    torus: (d, r: number, t: number) => new Torus(d, r, t),\n    fucked_up_torus: (d, r: number, t: number) =>\n        new FuckedUpTorus(d, r, t),\n    rotate,\n    R: rotate,\n    stereo: (d, to) => new Stereo(d, to),\n};\n\ntype Funs = typeof funs;\n\ntype Ranges = {\n    [P in keyof Funs]: (domain: number) => number;\n};\n\nconst ranges: Ranges = {\n    cube: (domain) => domain,\n    sphere: (domain) => domain + 1,\n    spiral: (domain) => domain + 1,\n    torus: (domain) => domain + 1,\n    fucked_up_torus: (domain) => domain + 1,\n    rotate: (domain) => domain,\n    R: (domain) => domain,\n    stereo: (domain) => domain,\n};\n","import * as math from 'mathjs';\nimport { Scope, Substitutions, ASTNode } from './types';\nimport assert from 'assert';\nimport { pp } from '../pp';\n\nexport class Simplifier {\n    constructor(\n        private readonly scope: Scope,\n        private readonly substitutions: Substitutions,\n    ) { }\n\n    simplify = (pipe: ASTNode): ASTNode => {\n        return this.simplifyPipeNode(pipe);\n    };\n\n    private simplifyPipeNode = (pipe: ASTNode): ASTNode => {\n        const n = assertNumberInNode('n', pipe);\n        const chain = assertDefInNode('chain', pipe);\n\n        return {\n            n,\n            chain: chain.map(this.simplifyFunNode),\n        };\n    };\n\n    private simplifyFunNode = (fun: ASTNode): ASTNode => {\n        const fn = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n\n        return {\n            fn,\n            args: args.map(this.simplifyFunArgNode),\n        };\n    };\n\n    private simplifyFunArgNode = (arg: ASTNode): ASTNode => {\n        if (arg.id) {\n            return this.simplifyVarNode(arg);\n        } else {\n            return this.simplifyArithNode(arg);\n        }\n    };\n\n    private simplifyArithNode = (arith: ASTNode): ASTNode => {\n        if (arith.op != null) {\n            const operands = assertDefInNode('operands', arith);\n            return { op: arith.op, operands: operands.map(this.simplifyArithNode) };\n        } else {\n            return this.simplifyNumberNode(arith);\n        }\n    };\n\n    private simplifyVarNode = (node: ASTNode): ASTNode => {\n        const id = node.id;\n        if (id in this.substitutions) {\n            return this.simplifyArithNode(this.substitutions[id]);\n        } else if (id in Math && typeof Math[id] === 'function') {\n            return { id, value: Math[id] };\n        } else {\n            return { id, value: math.evaluate(id, this.scope) };\n        }\n    };\n\n    private simplifyNumberNode = (scalar: ASTNode): ASTNode => {\n        const { id, value } = scalar;\n        if (value != null) {\n            return scalar;\n        } else if (id in this.substitutions) {\n            return this.simplifyArithNode(this.substitutions[id]);\n        } else if (id) {\n            const result = math.evaluate(id, this.scope);\n            assert.equal(typeof result, 'number', `Expected evaluation of ${pp(id)} to produce a number`);\n            return { id, value: result };\n        } else {\n            return scalar;\n        }\n    };\n}\n\nconst assertDefInNode = (name: string, node: ASTNode) => {\n    const x = node[name];\n    assertCondInNode(x != null, name, 'to be defined', node);\n    return x;\n};\n\nconst assertNumberInNode = (name: string, node: ASTNode): number => {\n    const x = node[name];\n    assertCondInNode(typeof x === 'number', name, 'a number', node);\n    return x as number;\n};\n\nconst assertCondInNode = (cond: boolean, name: string, expected: string, node: ASTNode) => {\n    assert(cond, `Expected ${name} to be ${expected} in ${pp(node)}`);\n};\n","import { parse } from './grammar.pegjs';\nimport { ASTNode } from './types';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\n\nconst logger = getLogger('Parser');\nlogger.setDefaultLevel('info');\n\ntype Options = {\n    startRule: 'arith';\n};\n\nconst loggingParse: typeof parse = (expr: string, options?: Options): ASTNode => {\n    try {\n        const node = parse(expr, options);\n        logger.debug(`parsed ${expr} into node ${pp(node)}`);\n        return node;\n    } catch (err) {\n        logger.error(`error parsing ${expr} at ${pp(err.location)}: ${err.message}`);\n        throw err;\n    }\n};\n\nexport class Parser {\n    static parsePipe = (pipe: string) => loggingParse(pipe);\n\n    static parseArith = (expr: string) => loggingParse(expr, { startRule: 'arith' });\n}\n","import { Scope, CompiledAST, NormalizedParams } from './types';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\nimport { Resolver } from './resolver';\nimport { Simplifier } from './simplifier';\nimport { Parser } from './parser';\n\nconst logger = getLogger('Compiler');\nlogger.setDefaultLevel('info');\n\nexport class Compiler {\n    constructor(private readonly scope: Scope) { }\n\n    compile = (params: NormalizedParams): CompiledAST => {\n        const ast = Parser.parsePipe(params.pipe);\n        logger.debug(`parsed params into ast ${pp(ast)}`);\n        const substitutions = {\n            theta: Parser.parseArith(params.theta),\n        };\n        const simplifier = new Simplifier(this.scope, substitutions);\n        const resolver = new Resolver(this.scope);\n        return resolver.resolve(simplifier.simplify(ast));\n    };\n}\n","import { CompositeFn } from \"../fn/fn\";\nimport { CompiledAST, Scope, HL, Chunk } from \"./types\";\nimport { Data, Vector } from \"../data\";\nimport { pp } from \"../pp\";\nimport { getLogger } from \"loglevel\";\nimport { round } from \"mathjs\";\nimport assert from 'assert';\nimport { Color } from \"three\";\n\nconst logger = getLogger('Evaluator');\n\nexport class Evaluator {\n    private readonly n: number;\n    private readonly init: CompositeFn;\n    private readonly iter: CompositeFn;\n    private readonly offset: number;\n    private readonly limit: number;\n\n    constructor(\n        private readonly scope: Scope,\n        ast: CompiledAST,\n        private readonly hl: HL,\n        chunk: Chunk,\n    ) {\n        const { n, init, iter } = ast;\n        const offset = chunk.offset;\n        const size = chunk.size;\n        const limit = offset + size;\n        assert(offset >= 0, `offset must be non-negative; got ${offset}`);\n        assert(limit <= n, `offset + size must be <= n; got ${offset} + ${size} = ${limit} > ${n}`);\n\n        this.n = n;\n        this.init = init;\n        this.iter = iter;\n        this.offset = offset;\n        this.limit = limit;\n    }\n\n\n    private get d() {\n        return this.iter.d;\n    }\n\n    initialize = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { n, init, offset, limit } = this;\n        const input = Data.input(data);\n        let i = offset;\n        for (const y of init.sample(n, offset, limit)) {\n            Data.set(input, y, i++, init.d);\n        }\n    };\n\n    iterate = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { init, iter, scope, n, offset, limit } = this;\n        const input = Data.input(data);\n        const position = Data.position(data);\n        const start = Date.now();\n\n        assert.equal(data[Data.nOffset], n, `n(data) != n(evaluator)`);\n        assert.equal(data[Data.inputOffset], init.d, `d0(data) != d0(evaluator)`);\n        assert.equal(data[Data.positionOffset(data)], iter.d, 'd(data) != d(evaluator)');\n\n        logger.debug(`iterating using ${pp(scope)}, ${pp(iter)}`);\n        for (let i = offset; i < limit; i++) {\n            iter.fn(Data.get(input, i, init.d), Data.get(position, i, iter.d));\n        }\n\n        this.computeColors(data);\n\n        logger.debug(`iteration complete in ${Date.now() - start}ms`);\n    };\n\n    private computeColors = (data: Vector) => {\n        logger.debug(`computing colors`);\n        const { d, scope, hl, offset, limit } = this;\n        const position = Data.position(data);\n        const color = Data.color(data);\n\n        for (let i = offset; i < limit; i++) {\n            const p = Data.get(position, i, d);\n            const colorScope = { ...scope, p, i };\n            const hue = round(hl.h.evaluate(colorScope), 0);\n            const lightness = round(hl.l.evaluate(colorScope), 0);\n            const c = new Color(`hsl(${hue}, 100%, ${lightness}%)`);\n\n            Data.set(color, [c.r, c.g, c.b], i, 3);\n        }\n\n    };\n}\n","import * as math from 'mathjs';\nimport { getLogger } from 'loglevel';\nimport { Params, Scope, NormalizedParams, CompiledAST, HL, Chunk } from './types';\nimport { Compiler } from './compiler';\nimport { Evaluator } from './evaluator';\n\nconst logger = getLogger('Pipe');\nlogger.setLevel('info');\n\nexport class Pipe {\n    static compile = (params: Params): CompiledAST => {\n        return Pipe.compileNormal(Pipe.normalized(params));\n    };\n    static evaluatorFor = (params: Params, chunk?: Chunk) => {\n        return Pipe.evaluatorForNormal(Pipe.normalized(params), chunk);\n    };\n\n    private static evaluatorForNormal = (params: NormalizedParams, chunk?: Chunk) => {\n        const ast = Pipe.compileNormal(params);\n        const scope = Pipe.finalScope(params, ast);\n        const hl = Pipe.compileHL(params);\n        return new Evaluator(scope, ast, hl, chunk);\n    };\n\n    private static compileNormal = (params: NormalizedParams): CompiledAST => {\n        const { power, chroma, t } = params;\n        return new Compiler({ t, power, chroma }).compile(params);\n\n    };\n\n    private static normalized = (params: Params): NormalizedParams => {\n        return {\n            pipe: params.pipe,\n            theta: params.theta || 't',\n            h: params.h || '1',\n            l: params.l || '0.5',\n            t: params.t || 0,\n            power: params.power || 0,\n            chroma: params.chroma || 0,\n        };\n    };\n\n    private static finalScope = (params: NormalizedParams, ast: CompiledAST): Scope => {\n        const { power, t, chroma } = params;\n        const scope: Scope = { t, power, chroma, n: ast.n };\n        scope.theta = math.evaluate(params.theta, scope);\n\n        return scope;\n    };\n\n    private static compileHL = (params: NormalizedParams): HL => {\n        return {\n            h: math.compile(`360 * (${params.h})`),\n            l: math.compile(`100 * (${params.l})`),\n        };\n    };\n}\n"],"sourceRoot":""}