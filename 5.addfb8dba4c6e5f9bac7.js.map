{"version":3,"sources":["webpack:///./src/web/audio/constants.ts","webpack:///./src/web/audio/spectrum.ts","webpack:///./src/web/error.ts","webpack:///./src/web/audio/graph.ts","webpack:///./src/web/audio/index.ts","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/Action.js","webpack:///./node_modules/rxjs/_esm5/internal/Scheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/async.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/interval.js","webpack:///./src/web/constants.ts","webpack:///./src/web/params.ts","webpack:///./node_modules/rxjs/_esm5/internal/util/isNumeric.js","webpack:///./src/web/data.ts","webpack:///./src/web/audio/power.worklet.ts"],"names":["NO_AUDIO","power","chroma","binCount","octaveCount","Spectrum","constructor","dbMin","dbMax","frames","map","frame","i","this","processFrame","length","Array","from","amp","ampMax","dbs","dbsm1","thresholdAndShift","Math","abs","max","log2","Infinity","min","k","floor","octave","pow","error","err","Error","log","pp","AudioGraph","ctx","source","subject","close","AudioWorkletNode","numberOfInputs","channelCountMode","channelCount","port","onmessage","msg","next","data","onprocessorerror","inputs","mic","value","connect","destination","allowedDbs","stream","subscribe","newValue","parameters","get","setValueAtTime","currentTime","f","filter","BiquadFilterNode","type","frequency","Q","mediaStream","AudioContext","audioWorklet","addModule","processorUrl","MediaStreamAudioSourceNode","graph","logger","getLogger","BehaviorSubject","audioStream","asObservable","event","info","navigator","mediaDevices","getUserMedia","audio","create","_super","AsyncAction","scheduler","work","_this","call","pending","prototype","schedule","state","delay","closed","id","recycleAsyncId","requestAsyncId","setInterval","flush","bind","clearInterval","execute","_execute","errored","errorValue","undefined","e","unsubscribe","_unsubscribe","actions","index","indexOf","splice","Action","Scheduler","SchedulerAction","now","Date","AsyncScheduler","delegate","active","scheduled","action","push","shift","dispatch","subscriber","counter","period","fftSize","params","t","pipe","theta","h","v","paramsStream","count","a","val","isArray","parseFloat","Observable","add","animate","setDefaultLevel","Subject","dataStream","webWorkerSource","console","startPool","getData","runPipeline","then","Data","fromBuffer","inFlight","logged","debug","module","exports"],"mappings":"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","file":"5.addfb8dba4c6e5f9bac7.js","sourcesContent":["import { Audio } from \"./types\";\n\n/**\n * This defines the values used for power and chroma when audio is not enabled.\n */\nexport const NO_AUDIO: Audio = {\n    power: 0.5,\n    chroma: 0.5,\n};\n\nexport const chromaCount = 12;\nexport const octaveMin = 0;\nexport const octaveMax = 8;\nexport const octaveCount = octaveMax - octaveMin;\nexport const frameSize = 128;\nexport const binCount = octaveCount * chromaCount;\n","import { chromaCount } from './constants';\n\nexport class Spectrum {\n    constructor(\n        public dbMin: number,\n        public dbMax: number,\n    ) { }\n\n    static octave = (k: number) => Math.floor(k / chromaCount);\n\n    static chroma = (k: number) => k % chromaCount;\n\n    static f = (k: number): number => {\n        const octave = Spectrum.octave(k);\n        const chroma = Spectrum.chroma(k);\n        const c0 = 16.35; // c0 per https://pages.mtu.edu/~suits/notefreqs.html\n\n        return c0 * 2 ** octave * Math.pow(2, 1 / chromaCount) ** chroma;\n    };\n\n    process = (frames: Float32Array[]): number[] => {\n        return frames.map((frame, i) => {\n            return this.processFrame(frame.length ? Array.from(frame) : [0]);\n        });\n    };\n\n    private processFrame = (frame: number[]): number => {\n        const amp = this.ampMax(frame); // silent=0, loud=1\n        const dbs = this.dbs(amp); // silent=-Infinity, loud=0\n        const dbsm1 = this.thresholdAndShift(dbs); // silent=-Infinity, loud=-1\n        return 1 / Math.abs(dbsm1); // silent=0, loud=1\n    };\n\n    private ampMax = (frame: number[]) => Math.max(...frame.map(Math.abs));\n\n    private dbs = amp => 10 * Math.log2(amp);\n\n    private thresholdAndShift = dbs => {\n        if (this.dbMax === this.dbMin) {\n            return dbs === this.dbMax ? -1 : -Infinity;\n        }\n\n        dbs = Math.min(this.dbMax, Math.max(this.dbMin, dbs));\n        return (dbs - this.dbMax) / (dbs - this.dbMin) - 1;\n    };\n}\n","import { pp } from '../core/pp';\nimport * as log from 'loglevel';\n\nexport const error = async (err: any) => {\n    if (err instanceof Error) {\n        log.error(err);\n    } else {\n        log.error(pp(err));\n    }\n};\n","import { Subject } from \"rxjs\";\nimport { Audio } from './types';\nimport { Spectrum } from \"./spectrum\";\nimport { binCount } from \"./constants\";\nimport processorUrl from './power.worklet';\nimport { error } from '../error';\nimport { inputs } from \"../inputs\";\n\nexport class AudioGraph {\n\n    static create = async (mediaStream: MediaStream, subject: Subject<Audio>) => {\n        const ctx = new AudioContext();\n        await ctx.audioWorklet.addModule(processorUrl);\n        const source = new MediaStreamAudioSourceNode(ctx, { mediaStream });\n        return new AudioGraph(ctx, source, subject);\n    };\n\n    constructor(\n        private readonly ctx: AudioContext,\n        source: AudioNode,\n        subject: Subject<Audio>,\n    ) {\n        const power = new AudioWorkletNode(ctx, 'power', {\n            numberOfInputs: binCount,\n            channelCountMode: 'explicit',\n            channelCount: 1,\n        });\n        power.port.onmessage = (msg) => subject.next(msg.data as Audio);\n        power.onprocessorerror = (err) => {\n            error(err);\n            // processor dies after an error, so close the graph\n            inputs.mic.value = false;\n        };\n        power.connect(ctx.destination);\n        inputs.allowedDbs.stream.subscribe(({ newValue: [min, max] }) => {\n            power.parameters.get('dbMin').setValueAtTime(min, ctx.currentTime);\n            power.parameters.get('dbMax').setValueAtTime(max, ctx.currentTime);\n        });\n\n        for (let k = 0; k < binCount; k++) {\n            const f = Spectrum.f(k);\n            const filter = new BiquadFilterNode(ctx, {\n                type: 'bandpass',\n                frequency: f,\n                Q: binCount / f,\n            });\n            source.connect(filter).connect(power, 0, k);\n        }\n    }\n\n    close = () => this.ctx.close();\n}\n","import { BehaviorSubject, interval, Observable } from 'rxjs';\nimport { getLogger } from 'loglevel';\nimport { inputs } from '../inputs';\nimport { Audio } from './types';\nimport { NO_AUDIO } from './constants';\nimport { AudioGraph } from './graph';\n\nconst logger = getLogger('Audio');\n\nconst subject = new BehaviorSubject<Audio>(NO_AUDIO);\nexport const audioStream = subject.asObservable();\nlet graph: AudioGraph;\n\ninputs.mic.stream.subscribe(async ({ newValue, event }) => {\n    if (newValue) {\n        logger.info('getting user media');\n        const stream = await navigator.mediaDevices\n            .getUserMedia({ audio: true });\n        logger.info('starting new audio graph');\n        graph = await AudioGraph.create(stream, subject);\n    } else {\n        logger.info('closing audio graph');\n        if (graph) await graph.close();\n        subject.next(NO_AUDIO);\n    }\n});\n","/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Action } from './Action';\nvar AsyncAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.pending = false;\n        return _this;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        clearInterval(id);\n        return undefined;\n    };\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action));\nexport { AsyncAction };\n//# sourceMappingURL=AsyncAction.js.map\n","/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscription } from '../Subscription';\nvar Action = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Action, _super);\n    function Action(scheduler, work) {\n        return _super.call(this) || this;\n    }\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return this;\n    };\n    return Action;\n}(Subscription));\nexport { Action };\n//# sourceMappingURL=Action.js.map\n","var Scheduler = /*@__PURE__*/ (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = function () { return Date.now(); };\n    return Scheduler;\n}());\nexport { Scheduler };\n//# sourceMappingURL=Scheduler.js.map\n","/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\nimport { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);\n//# sourceMappingURL=async.js.map\n","/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Scheduler } from '../Scheduler';\nvar AsyncScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncScheduler, _super);\n    function AsyncScheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        var _this = _super.call(this, SchedulerAction, function () {\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n                return AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        }) || this;\n        _this.actions = [];\n        _this.active = false;\n        _this.scheduled = undefined;\n        return _this;\n    }\n    AsyncScheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n            return AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return _super.prototype.schedule.call(this, work, delay, state);\n        }\n    };\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift());\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler));\nexport { AsyncScheduler };\n//# sourceMappingURL=AsyncScheduler.js.map\n","/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period, scheduler) {\n    if (period === void 0) {\n        period = 0;\n    }\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    if (!isNumeric(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = async;\n    }\n    return new Observable(function (subscriber) {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    var subscriber = state.subscriber, counter = state.counter, period = state.period;\n    subscriber.next(counter);\n    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);\n}\n//# sourceMappingURL=interval.js.map\n","// TODO make these inputs :D\nexport const fps = 60;\nexport const dataSampleRate = fps / 1000;\nexport const audioSampleRate = 2 * dataSampleRate;\nexport const fftSize = 1024;\nexport const psdSize = Math.floor(fftSize / 2) + 1;\n","import { audioStream } from './audio';\nimport { Params } from '../core/pipe/types';\nimport { interval, BehaviorSubject } from 'rxjs';\nimport { inputs } from './inputs';\nimport { fps } from './constants';\nimport { Audio } from './audio/types';\nimport { error } from './error';\nimport { NO_AUDIO } from './audio/constants';\n\nconst params = (t: number, { power, chroma }: Audio) => {\n    return {\n        pipe: inputs.pipe.value,\n        theta: inputs.theta.value,\n        h: inputs.h.value,\n        v: inputs.v.value,\n        t,\n        power,\n        chroma,\n    };\n};\n\nconst subject = new BehaviorSubject<Params>(params(0, NO_AUDIO));\nexport const paramsStream = subject.asObservable();\nlet count = 0;\n\nlet audio: Audio;\naudioStream.subscribe(a => audio = a, error);\n\nconst maybeEmit = () => {\n    if (inputs.animate.value) {\n        subject.next(params(count++ / fps, audio));\n    }\n};\n\ninterval(1000 / fps).subscribe(maybeEmit, error);\n","/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */\nimport { isArray } from './isArray';\nexport function isNumeric(val) {\n    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n//# sourceMappingURL=isNumeric.js.map\n","import { Observable, timer, Subject, interval, EMPTY } from 'rxjs';\nimport { retryWhen, delayWhen, repeatWhen, tap } from 'rxjs/operators';\nimport { Data } from '../core/data';\nimport { Params } from \"../core/pipe/types\";\nimport { startPool, runPipeline } from '../core/pipe/pool';\nimport * as params from './params';\nimport { getLogger } from 'loglevel';\nimport { pp } from '../core/pp';\nimport { error } from './error';\nimport debug from './debug';\n\nconst logger = getLogger('Data');\nlogger.setDefaultLevel('info');\nconst subject = new Subject<Data>();\n\nexport const dataStream = subject.asObservable();\n\ntype Source = {\n  getData(params: Params): Promise<Data>;\n};\n\nconst webWorkerSource = async (): Promise<Source> => {\n  console.info('starting web worker data source');\n  await startPool();\n\n  const getData = (params: Params) =>\n    runPipeline(params).then(Data.fromBuffer);\n\n  return { getData };\n};\n\n(async () => {\n  const { getData } = await webWorkerSource();\n  let inFlight: Promise<Data> | null;\n  let logged = 0;\n\n  params.paramsStream.subscribe(\n    async (params) => {\n      if (inFlight) return;\n      debug('params', params);\n      logger.debug('requesting data with params', params);\n      if (Date.now() - logged >= 1000) {\n        logger.debug(`sending request for data with params ${pp(params)}`);\n        logged = Date.now();\n      }\n      // TODO i feel like there's a more rx-y way to do this\n      inFlight = getData(params);\n      try {\n        subject.next(await inFlight);\n      } catch (err) {\n        error(err);\n      } finally {\n        inFlight = null;\n      }\n    },\n    err => error(err),\n  );\n})();\n","module.exports = __webpack_public_path__ + \"748f54fc65a876917a4a.worklet.js\";"],"sourceRoot":""}