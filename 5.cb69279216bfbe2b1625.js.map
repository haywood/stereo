{"version":3,"sources":["webpack:///./src/web/audio/constants.ts","webpack:///./src/web/audio/spectrum.ts","webpack:///./src/web/error.ts","webpack:///./src/web/audio/graph.ts","webpack:///./src/web/audio/index.ts","webpack:///./src/web/params.ts","webpack:///./src/web/constants.ts","webpack:///./src/web/data.ts","webpack:///./src/web/audio/power.worklet.ts","webpack:///./src/core/fn/fn.ts","webpack:///./src/core/fn/interval.ts","webpack:///./src/core/fn/cube.ts","webpack:///./src/core/fn/rotator.ts","webpack:///./src/core/fn/sphere.ts","webpack:///./src/core/fn/spiral.ts","webpack:///./src/core/fn/torus.ts","webpack:///./src/core/fn/fucked_up_torus.ts","webpack:///./src/core/fn/stereo.ts","webpack:///./src/core/fn/identity.ts","webpack:///./src/core/pipe/resolver.ts","webpack:///./src/core/pipe/simplifier.ts","webpack:///./src/core/pipe/parser.ts","webpack:///./src/core/pipe/compiler.ts","webpack:///./src/core/pipe/evaluator.ts","webpack:///./src/core/pipe/pipe.ts","webpack:///./src/core/pp.ts","webpack:///./src/web/inputs.ts","webpack:///./src/core/data.ts","webpack:///./src/core/pipe/pool.ts","webpack:///./src/core/pipe/pipe.worker.ts","webpack:///./src/core/pipe/grammar.pegjs"],"names":["NO_AUDIO","power","chroma","binCount","octaveCount","Spectrum","constructor","dbMin","dbMax","frames","map","frame","i","this","processFrame","length","Array","from","amp","ampMax","dbs","dbsm1","thresholdAndShift","math","Infinity","k","octave","error","err","Error","log","pp","AudioGraph","ctx","source","subject","close","AudioWorkletNode","numberOfInputs","channelCountMode","channelCount","port","onmessage","msg","next","data","onprocessorerror","inputs","mic","value","connect","destination","allowedDbs","stream","subscribe","newValue","min","max","parameters","get","setValueAtTime","currentTime","f","filter","BiquadFilterNode","type","frequency","Q","mediaStream","AudioContext","audioWorklet","addModule","processorUrl","MediaStreamAudioSourceNode","graph","logger","getLogger","BehaviorSubject","audioStream","asObservable","event","info","navigator","mediaDevices","getUserMedia","audio","create","params","floor","fftSize","t","pipe","theta","h","v","count","a","interval","animate","setDefaultLevel","Subject","webWorkerSource","console","startPool","hardwareConcurrency","getData","runPipeline","then","Data","fromBuffer","inFlight","logged","debug","Date","now","module","exports","cos","Math","sin","exp","tan","tanh","components","d","keys","CompositeFn","fns","n","offset","limit","first","rest","x","sample","set","apply","y","subarray","Float32Array","domain","assert","equal","domainMax","dMax","last","reduce","fn","push","Interval","b","nPerLevel","points","p","pop","successors","nthRoot","Cube","l","fill","Rotator","d0","d1","f0","f1","cube","r0","r1","Sphere","r","tau","phi","root","Spiral","sphere","Torus","cross","rotator","FuckedUpTorus","circle","q","Stereo","to","fromTemp","toTemp","up","down","temp","n2","norm2","divisor","result","Identity","Resolver","scope","resolvePipeNode","chain","assertDefInNode","links","fun","shift","args","link","resolveFirstFunNode","assertNumberInNode","resolveFunNode","init","iter","buildComposites","builder","Builder","isTemporal","add","build","name","funs","resolveFunArgNode","some","isNodeTemporal","prev","ranges","arg","id","resolveVarNode","resolveArithNode","node","op","ops","resolveNumberNode","fail","assertCondInNode","cond","expected","operands","rotate","spiral","torus","fucked_up_torus","R","stereo","Simplifier","substitutions","simplifyPipeNode","simplifyFunNode","simplifyFunArgNode","simplifyVarNode","simplifyArithNode","arith","simplifyNumberNode","scalar","loggingParse","expr","options","parse","location","message","Parser","startRule","Compiler","ast","parsePipe","parseArith","simplifier","resolve","simplify","Evaluator","hv","chunk","buffer","input","position","start","nOffset","inputOffset","positionOffset","computeColors","color","colorScope","s","hsv","hsl","round","evaluate","c","Color","g","size","setLevel","Pipe","compileNormal","normalized","evaluatorForNormal","finalScope","hl","compileHL","compile","JSON","stringify","persistenceEnabled","URLSearchParams","window","search","hash","substr","atob","Input","_value","persistent","has","updateHash","str","document","btoa","toString","initFromOrWriteToHash","newSubject","oldValue","localStorage","setItem","TextInput","super","text","ToggleInput","on","off","disabled","test","bool","RangeInput","split","parseInt","fullscreen","fullscreenEnabled","SharedArrayBuffer","arr","inputLength","positionLength","colorOffset","stride","pool","poolSize","Pool","spawn","Worker","Map","promises","queue","Promise","all","initialize","timing","forkJoin","w","iterate","getOrInitialize","key","getKey","bufferFor","ceil","label","elapsed","slice","peg$SyntaxError","found","captureStackTrace","child","parent","ctor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toUpperCase","replace","j","descriptions","sort","join","describeExpected","describeFound","SyntaxError","peg$result","peg$FAILED","peg$startRuleFunctions","peg$parsepipe","peg$parsearith","peg$startRuleFunction","peg$c0","peg$c1","head","tail","peg$c2","peg$c3","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","parseFloat","peg$c10","peg$c11","peg$c12","peg$classExpectation","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$literalExpectation","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","ignoreCase","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s3","peg$parseuint","peg$parsepipe_sep","peg$parsechain","peg$parsefun","peg$parseidentifier","peg$parselparen","peg$parsefun_args","peg$parsefun_arg","s2","peg$parse_","peg$parsefn_arg_sep","peg$parserparen","peg$parseid","peg$parsescalar","substring","peg$parsearith_op","s4","s5","s6","charAt","peg$parsemantissa","peg$parseint","peg$parsefloat","peg$parsenumber","peg$parse__"],"mappings":"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","file":"5.cb69279216bfbe2b1625.js","sourcesContent":["import { Audio } from \"./types\";\n\n/**\n * This defines the values used for power and chroma when audio is not enabled.\n */\nexport const NO_AUDIO: Audio = {\n    power: 0.5,\n    chroma: 0.5,\n};\n\nexport const chromaCount = 12;\nexport const octaveMin = 0;\nexport const octaveMax = 8;\nexport const octaveCount = octaveMax - octaveMin;\nexport const frameSize = 128;\nexport const binCount = octaveCount * chromaCount;\n","import { chromaCount } from './constants';\nimport * as math from 'mathjs';\n\nexport class Spectrum {\n    constructor(\n        public dbMin: number,\n        public dbMax: number,\n    ) { }\n\n    static octave = (k: number) => math.floor(k / chromaCount);\n\n    static chroma = (k: number) => k % chromaCount;\n\n    static f = (k: number): number => {\n        const octave = Spectrum.octave(k);\n        const chroma = Spectrum.chroma(k);\n        const c0 = 16.35; // c0 per https://pages.mtu.edu/~suits/notefreqs.html\n\n        return c0 * 2 ** octave * math.nthRoot(2, chromaCount) ** chroma;\n    };\n\n    process = (frames: Float32Array[]): number[] => {\n        return frames.map((frame, i) => {\n            return this.processFrame(frame.length ? Array.from(frame) : [0]);\n        });\n    };\n\n    private processFrame = (frame: number[]): number => {\n        const amp = this.ampMax(frame); // silent=0, loud=1\n        const dbs = this.dbs(amp); // silent=-Infinity, loud=0\n        const dbsm1 = this.thresholdAndShift(dbs); // silent=-Infinity, loud=-1\n        return 1 / math.abs(dbsm1); // silent=0, loud=1\n    };\n\n    private ampMax = (frame: number[]) => math.max(math.abs(frame));\n\n    private dbs = amp => 10 * math.log2(amp);\n\n    private thresholdAndShift = dbs => {\n        if (this.dbMax === this.dbMin) {\n            return dbs === this.dbMax ? -1 : -Infinity;\n        }\n\n        dbs = math.min(this.dbMax, math.max(this.dbMin, dbs));\n        return (dbs - this.dbMax) / (dbs - this.dbMin) - 1;\n    };\n}\n","import { pp } from '../core/pp';\nimport * as log from 'loglevel';\n\nexport const error = async (err: any) => {\n    if (err instanceof Error) {\n        log.error(err);\n    } else {\n        log.error(pp(err));\n    }\n};\n","import { Subject } from \"rxjs\";\nimport { Audio } from './types';\nimport { Spectrum } from \"./spectrum\";\nimport { binCount } from \"./constants\";\nimport processorUrl from './power.worklet';\nimport { error } from '../error';\nimport { inputs } from \"../inputs\";\n\nexport class AudioGraph {\n\n    static create = async (mediaStream: MediaStream, subject: Subject<Audio>) => {\n        const ctx = new AudioContext();\n        await ctx.audioWorklet.addModule(processorUrl);\n        const source = new MediaStreamAudioSourceNode(ctx, { mediaStream });\n        return new AudioGraph(ctx, source, subject);\n    };\n\n    constructor(\n        private readonly ctx: AudioContext,\n        source: AudioNode,\n        subject: Subject<Audio>,\n    ) {\n        const power = new AudioWorkletNode(ctx, 'power', {\n            numberOfInputs: binCount,\n            channelCountMode: 'explicit',\n            channelCount: 1,\n        });\n        power.port.onmessage = (msg) => subject.next(msg.data as Audio);\n        power.onprocessorerror = (err) => {\n            error(err);\n            // processor dies after an error, so close the graph\n            inputs.mic.value = false;\n        };\n        power.connect(ctx.destination);\n        inputs.allowedDbs.stream.subscribe(({ newValue: [min, max] }) => {\n            power.parameters.get('dbMin').setValueAtTime(min, ctx.currentTime);\n            power.parameters.get('dbMax').setValueAtTime(max, ctx.currentTime);\n        });\n\n        for (let k = 0; k < binCount; k++) {\n            const f = Spectrum.f(k);\n            const filter = new BiquadFilterNode(ctx, {\n                type: 'bandpass',\n                frequency: f,\n                Q: binCount / f,\n            });\n            source.connect(filter).connect(power, 0, k);\n        }\n    }\n\n    close = () => this.ctx.close();\n}\n","import { BehaviorSubject, interval, Observable } from 'rxjs';\nimport { getLogger } from 'loglevel';\nimport { inputs } from '../inputs';\nimport { Audio } from './types';\nimport { NO_AUDIO } from './constants';\nimport { AudioGraph } from './graph';\n\nconst logger = getLogger('Audio');\n\nconst subject = new BehaviorSubject<Audio>(NO_AUDIO);\nexport const audioStream = subject.asObservable();\nlet graph: AudioGraph;\n\ninputs.mic.stream.subscribe(async ({ newValue, event }) => {\n    if (newValue) {\n        logger.info('getting user media');\n        const stream = await navigator.mediaDevices\n            .getUserMedia({ audio: true });\n        logger.info('starting new audio graph');\n        graph = await AudioGraph.create(stream, subject);\n    } else {\n        logger.info('closing audio graph');\n        if (graph) await graph.close();\n        subject.next(NO_AUDIO);\n    }\n});\n","import { audioStream } from './audio';\nimport { Params } from '../core/pipe/types';\nimport { interval, BehaviorSubject } from 'rxjs';\nimport { inputs } from './inputs';\nimport { fps } from './constants';\nimport { Audio } from './audio/types';\nimport { error } from './error';\nimport { NO_AUDIO } from './audio/constants';\n\nconst params = (t: number, { power, chroma }: Audio) => {\n    return {\n        pipe: inputs.pipe.value,\n        theta: inputs.theta.value,\n        h: inputs.h.value,\n        v: inputs.v.value,\n        t,\n        power,\n        chroma,\n    };\n};\n\nconst subject = new BehaviorSubject<Params>(params(0, NO_AUDIO));\nexport const stream = subject;\nlet count = 0;\n\nlet audio: Audio;\naudioStream.subscribe(a => audio = a, error);\n\nconst maybeEmit = () => {\n    if (inputs.animate.value) {\n        stream.next(params(count++ / fps, audio));\n    }\n};\n\ninterval(1000 / fps).subscribe(maybeEmit, error);\n","import { floor } from 'mathjs';\n\n// TODO make these inputs :D\nexport const fps = 60;\nexport const dataSampleRate = fps / 1000;\nexport const audioSampleRate = 2 * dataSampleRate;\nexport const fftSize = 1024;\nexport const psdSize = floor(fftSize / 2) + 1;\n","import { Observable, timer, Subject, interval, EMPTY } from 'rxjs';\nimport { retryWhen, delayWhen, repeatWhen, tap } from 'rxjs/operators';\nimport { Data } from '../core/data';\nimport { Params } from \"../core/pipe/types\";\nimport { startPool, runPipeline } from '../core/pipe/pool';\nimport * as params from './params';\nimport { getLogger } from 'loglevel';\nimport { pp } from '../core/pp';\nimport { error } from './error';\n\nconst logger = getLogger('Data');\nlogger.setDefaultLevel('info');\nconst subject = new Subject<Data>();\n\nexport const stream = subject.asObservable();\n\ntype Source = {\n  getData(params: Params): Promise<Data>;\n};\n\nconst webWorkerSource = async (): Promise<Source> => {\n  console.info('starting web worker data source');\n  await startPool(navigator.hardwareConcurrency);\n\n  const getData = (params: Params) =>\n    runPipeline(params).then(Data.fromBuffer);\n\n  return { getData };\n};\n\n(async () => {\n  const { getData } = await webWorkerSource();\n  let inFlight: Promise<Data> | null;\n  let logged = 0;\n\n  params.stream.subscribe(\n    async (params) => {\n      if (inFlight) return;\n      logger.debug('requesting data with params', params);\n      if (Date.now() - logged >= 1000) {\n        logger.debug(`sending request for data with params ${pp(params)}`);\n        logged = Date.now();\n      }\n      // TODO i feel like there's a more rx-y way to do this\n      inFlight = getData(params);\n      try {\n        subject.next(await inFlight);\n      } catch (err) {\n        error(err);\n      } finally {\n        inFlight = null;\n      }\n    },\n    err => error(err),\n  );\n})();\n","module.exports = __webpack_public_path__ + \"fd57ad67d7c9a0e94cf8.worklet.js\";","import { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport const cos = Math.cos;\nexport const sin = Math.sin;\nexport const tan = Math.tan;\nexport const tanh = Math.tanh;\nexport const exp = Math.exp;\n\nexport const components = (d) => Array.from(new Array(d).keys());\n\nexport interface Fn {\n  readonly d: number;\n  readonly domain: number;\n  fn(x: Vector, y?: Vector): Vector;\n  sample(n: number, offset: number, limit: number): Generator<Vector>;\n}\n\nexport class CompositeFn implements Fn {\n  private readonly x: Vector;\n  private readonly y: Vector;\n  constructor(readonly fns: Fn[]) {\n    assert(fns.length, 'fns cannot be empty');\n\n    const length = Math.max(this.domainMax, this.dMax);\n    this.x = new Float32Array(length);\n    this.y = new Float32Array(length);\n\n  }\n\n  get first() {\n    return this.fns[0];\n  }\n\n  get last() {\n    return this.fns[this.fns.length - 1];\n  }\n\n  get domain() {\n    return this.first.domain;\n  }\n\n  get d() {\n    return this.last.d;\n  }\n\n  get domainMax() {\n    return this.fns.reduce((max, f) => Math.max(f.domain, max), 0);\n  }\n\n  get dMax() {\n    return this.fns.reduce((max, f) => Math.max(f.d, max), 0);\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { fns, d } = this;\n    const [first, ...rest] = fns;\n    if (fns.length == 0) return [];\n\n    for (const x of first.sample(n, offset, limit)) {\n      this.x.set(x);\n      if (rest.length) {\n        CompositeFn.apply(rest, this.x, this.y);\n      } else {\n        this.y.set(x);\n      }\n      yield this.y.subarray(0, d);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { fns, domain, d } = this;\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    this.x.set(x);\n    CompositeFn.apply(fns, this.x, this.y);\n    y.set(this.y.subarray(0, d));\n    return y;\n  };\n\n  private static apply = (fns: Fn[], x: Vector, y: Vector) => {\n    assert.equal(x.length, y.length);\n    for (const f of fns) {\n      f.fn(x.subarray(0, f.domain), y.subarray(0, f.d));\n      x.set(y);\n    }\n  };\n\n  static Builder = class {\n    private readonly fns: Fn[] = [];\n\n    get d() {\n      return this.last.d;\n    }\n\n    get last() {\n      return this.fns[this.fns.length - 1];\n    }\n\n    add = (fn: Fn) => {\n      const { fns, last } = this;\n      if (last && fn.domain !== last.d) {\n        throw new Error(\n          `Cannot add ${fn} to composite, because its domain is not ${last.d}`,\n        );\n      }\n      fns.push(fn);\n      return this;\n    };\n\n    build = () => {\n      return new CompositeFn(this.fns);\n    };\n  };\n}\n","import { floor, nthRoot } from 'mathjs';\nimport { Fn } from './fn';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Interval implements Fn {\n  readonly domain: number;\n\n  constructor(readonly d: number, readonly a: number[], readonly b: number[]) {\n    assert.equal(a.length, d);\n    assert.equal(b.length, d);\n    this.domain = d;\n  }\n\n  static nPerLevel = (d: number, n: number) => floor(nthRoot(n, d) as number);\n\n  static n = (d: number, n: number) => Interval.nPerLevel(d, n) ** d;\n\n  /**\n   * @param x A vector of length this.domain contained in the interval [0, 1].\n   * @returns A mapping of the vector into this interval.\n   */\n  fn = (x: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, b, d } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    for (let i = 0; i < d; i++) {\n      y[i] = a[i] + x[i] * (b[i] - a[i]);\n    }\n    return y;\n  };\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { d, fn } = this;\n    n = Interval.nPerLevel(d, n);\n    const points: number[][] = [[]];\n    let i = 0;\n\n    while (points.length && i < limit) {\n      const p = points.pop()!;\n      if (p.length < d) {\n        points.push(...successors(p));\n      } else if (i++ >= offset) {\n        yield fn(p);\n      }\n    }\n\n    function* successors(p: number[]): Generator<number[]> {\n      for (let i = 0; i < n; i++) {\n        yield [...p, i / n];\n      }\n    }\n  };\n}\n","import Interval from \"./interval\";\nimport { Fn } from \"./fn\";\nimport { Vector } from \"../data\";\n\nexport default class Cube implements Fn {\n  private readonly interval: Interval;\n\n  constructor(readonly d: number, readonly l: number) {\n    this.interval = new Interval(\n      d,\n      new Array(d).fill(-l / 2),\n      new Array(d).fill(l / 2)\n    );\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  fn = (x: Vector, y?: Vector) => this.interval.fn(x, y);\n\n  sample = (n: number, offset: number, limit: number) =>\n    this.interval.sample(n, offset, limit);\n}\n","import { Fn, cos, sin } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Rotator implements Fn {\n  readonly r0: number;\n  readonly r1: number;\n\n  constructor(\n    readonly d: number,\n    readonly theta: number,\n    readonly d0: number,\n    readonly d1: number,\n    readonly f0: (theta: number) => number = cos,\n    readonly f1: (theta: number) => number = sin,\n  ) {\n    this.r0 = f0(theta);\n    this.r1 = f1(theta);\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const p of cube.sample(n, offset, limit)) {\n      yield this.fn(p);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, d0, d1, r0, r1 } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    y.set(x);\n\n    const a = x[d0], b = x[d1];\n    y[d0] = a * r0 - b * r1;\n    y[d1] = a * r1 + b * r0;\n    return y;\n  };\n}\n","import { equal } from 'mathjs';\nimport Rotator from './rotator';\nimport Cube from './cube';\nimport { tau, zeros } from 'mathjs';\nimport { Fn, components, CompositeFn } from './fn';\nimport { TypedArray } from 'three';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Sphere implements Fn {\n  private readonly root: Float32Array;\n\n  constructor(readonly d: number, r: number) {\n    this.root = new Float32Array(d);\n    this.root[0] = r;\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, root } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    const r = new CompositeFn(components(d - 1).map((i) => new Rotator(d, phi[i], 0, i + 1)));\n    r.fn(root, y);\n    return y;\n  };\n}\n","import { Fn, exp, components } from './fn';\nimport Cube from './cube';\nimport Sphere from './sphere';\nimport { tau, sum, multiply } from 'mathjs';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Spiral implements Fn {\n  private readonly sphere: Sphere;\n\n  constructor(readonly d: number, readonly a: number[], readonly k: number[]) {\n    this.sphere = new Sphere(d, 1);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, k, domain, d } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    this.sphere.fn(phi, y);\n    let x = 0;\n    for (let i = 0; i < domain; i++) {\n      x += k[i] * phi[i];\n    };\n    const r = exp(x);\n    for (let i = 0; i < d; i++) {\n      y[i] = y[i] * a[i] * r;\n    }\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { tau } from 'mathjs';\nimport Rotator from './rotator';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Torus implements Fn {\n  private readonly cross: Sphere;\n\n  constructor(readonly d: number, readonly r: number, readonly t: number) {\n    assert(d > 2, `torus is only defined for d > 2; got ${d}`);\n    this.cross = new Sphere(d - 1, t);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, tau);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (theta: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { cross, d, r } = this;\n    assert.equal(theta.length, d - 1, `torus expects an input of ${d - 1}; got ${theta.length}`);\n    const rotator = new Rotator(d, theta[d - 2], 0, d - 1);\n\n    cross.fn(theta.subarray(0, d - 2), y.subarray(0, d - 1));\n    y[0] += r;\n    rotator.fn(y, y);\n\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { tau } from 'mathjs';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\n// This shape does not implement a torus. It used to,\n// but then I changed the way Rotator works, which\n// changed the way that the points of the sphere are\n// distributed, making the translation step behave incorrectly\n// Still makes a cool shape though, so keeping it\nexport default class FuckedUpTorus implements Fn {\n    private readonly sphere: Sphere;\n    private readonly circle: Sphere;\n\n    constructor(readonly d: number, readonly r: number, readonly t: number) {\n        this.sphere = new Sphere(d, t);\n        this.circle = new Sphere(2, r);\n    }\n\n    get domain() {\n        return this.d - 1;\n    }\n\n    sample = function* (n: number, offset: number, limit: number) {\n        const cube = new Cube(this.domain, tau);\n        for (const phi of cube.sample(n, offset, limit)) {\n            yield this.fn(phi);\n        }\n    };\n\n    fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { domain, d, sphere, circle } = this;\n        assert.equal(phi.length, domain);\n        assert.equal(y.length, d);\n        sphere.fn(phi, y);\n        const q = circle.fn(phi.subarray(d - 2));\n        y[0] += q[0];\n        y[d - 1] += q[1];\n        return y;\n    };\n}\n","import { Fn } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Stereo implements Fn {\n  private readonly fromTemp: Vector;\n  private readonly toTemp: Vector;\n\n  constructor(private readonly from: number, private readonly to: number) {\n    this.fromTemp = new Float32Array(Math.max(from, to));\n    this.toTemp = new Float32Array(Math.max(from, to));\n  }\n\n  get domain() {\n    return this.from;\n  }\n\n  get d() {\n    return this.to;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.to)) => {\n    let { from, to, fromTemp, toTemp } = this;\n    assert.equal(x.length, from);\n    assert.equal(y.length, to);\n\n    if (from === to) {\n      y.set(x);\n      return y;\n    }\n\n    fromTemp.set(x);\n\n    while (from < to) {\n      Stereo.up(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, ++from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    while (from > to) {\n      Stereo.down(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, --from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    y.set(toTemp.subarray(0, to));\n    return y;\n  };\n\n  static up = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length + 1);\n    const n2 = norm2(x);\n    const divisor = n2 + 1;\n    temp[0] = (n2 - 1) / divisor;\n    for (let i = 1; i <= x.length; i++) {\n      temp[i] = (2 * x[i - 1]) / divisor;\n    }\n  };\n\n  static down = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length - 1);\n    for (let i = 0; i < temp.length; i++) {\n      temp[i] = x[i + 1] / (1 - x[0]);\n    }\n  };\n}\n\nconst norm2 = (x: Vector) => {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * x[i];\n  }\n  return result;\n};\n","import { Fn } from \"./fn\";\nimport Cube from \"./cube\";\nimport { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport class Identity implements Fn {\n    readonly domain: number;\n\n    constructor(readonly d: number) {\n        this.domain = d;\n    }\n\n    fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { d } = this;\n        assert.equal(x.length, d);\n        assert.equal(y.length, d);\n        y.set(x);\n        return y;\n    };\n\n    sample = function* (n: number, offset: number, limit: number) {\n        throw new Error('identity function does not support sampling');\n    };\n}\n","import { Scope, CompiledAST, Value, UnaryOperator, Link, ASTNode } from './types';\nimport assert from 'assert';\nimport { pp } from '../pp';\nimport { Fn, CompositeFn } from '../fn/fn';\nimport Cube from '../fn/cube';\nimport Spiral from '../fn/spiral';\nimport Torus from '../fn/torus';\nimport FuckedUpTorus from '../fn/fucked_up_torus';\nimport Sphere from '../fn/sphere';\nimport Stereo from '../fn/stereo';\nimport Rotator from '../fn/rotator';\nimport Interval from '../fn/interval';\nimport { Identity } from '../fn/identity';\n\nexport class Resolver {\n    constructor(private readonly scope: Scope) { }\n\n    resolve = (pipe: ASTNode): CompiledAST => {\n        return this.resolvePipeNode(pipe);\n    };\n\n    private resolvePipeNode = (pipe: ASTNode): CompiledAST => {\n        const chain = assertDefInNode('chain', pipe);\n        const links: Link[] = [];\n        const fun = chain.shift();\n        const d = fun.args.shift().value as number;\n        const link = this.resolveFirstFunNode(d, fun);\n        const n = Interval.n(link.fn.domain, assertNumberInNode('n', pipe));\n\n        links.push(link);\n\n        for (let i = 0; i < chain.length; i++) {\n            const fun = chain[i];\n            const link = this.resolveFunNode(links[i].fn, fun);\n            links.push(link);\n        }\n\n        const [init, iter] = this.buildComposites(links);\n        return { n, init, iter };\n    };\n\n    private buildComposites = (links: Link[]) => {\n        let builder = new CompositeFn.Builder();\n        while (links.length && !links[0].isTemporal) {\n            builder.add(links.shift().fn);\n        }\n\n        const init = builder.build();\n        builder = new CompositeFn.Builder().add(new Identity(init.d));\n\n        while (links.length) {\n            builder.add(links.shift().fn);\n        }\n\n        const iter = builder.build();\n        return [init, iter];\n    };\n\n    private resolveFirstFunNode = (d: number, fun: ASTNode) => {\n        const name: string = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n        const fn = funs[name](d, ...args.map(this.resolveFunArgNode));\n        const isTemporal = args.some(isNodeTemporal);\n\n        return { fn, isTemporal };\n    };\n\n    private resolveFunNode = (prev: Fn, fun: ASTNode): Link => {\n        const name: string = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n        const d = ranges[name](prev.d);\n        const fn = funs[name](d, ...args.map(this.resolveFunArgNode));\n        const isTemporal = args.some(isNodeTemporal);\n\n        return { fn, isTemporal };\n    };\n\n    private resolveFunArgNode = (arg: ASTNode): Value => {\n        if (arg.id) {\n            return this.resolveVarNode(arg);\n        } else {\n            return this.resolveArithNode(arg);\n        }\n    };\n\n    private resolveArithNode = (node: ASTNode): number => {\n        if (node.op != null) {\n            const op = ops[node.op];\n            const [a, b] = assertDefInNode('operands', node)\n                .map(this.resolveArithNode);\n            const c = op(a, b);\n            return c;\n        } else {\n            return this.resolveNumberNode(node);\n        }\n    };\n\n    private resolveVarNode = (node: ASTNode): Value => {\n        const { value } = node;\n        if (typeof value === 'function') {\n            return value;\n        } else {\n            return this.resolveNumberNode(node);\n        }\n    };\n\n    private resolveNumberNode = (node: ASTNode): number => {\n        const { value } = node;\n        if (typeof value === 'number') {\n            return value;\n        } else {\n            assert.fail(`don't know how to handle number node ${pp(node)}`);\n        }\n    };\n}\n\nconst assertDefInNode = (name: string, node: ASTNode) => {\n    const x = node[name];\n    assertCondInNode(x != null, name, 'to be defined', node);\n    return x;\n};\n\nconst assertNumberInNode = (name: string, node: ASTNode): number => {\n    const x = node[name];\n    assertCondInNode(typeof x === 'number', name, 'a number', node);\n    return x as number;\n};\n\nconst assertCondInNode = (cond: boolean, name: string, expected: string, node: ASTNode) => {\n    assert(cond, `Expected ${name} to be ${expected} in ${pp(node)}`);\n};\n\nconst isNodeTemporal = (node: ASTNode): boolean => {\n    if (node.id === 't') return true;\n    else if (node.args) return node.args.some(isNodeTemporal);\n    else if (node.operands) return node.operands.some(isNodeTemporal);\n    else return false;\n};\n\nconst ops: {\n    [op: string]: (a: number, b: number) => number;\n} = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '*': (a, b) => a * b,\n    '/': (a, b) => a / b,\n    '**': (a, b) => a ** b,\n    '^': (a, b) => a ** b,\n};\n\nconst rotate = (\n    d: number,\n    theta: number,\n    d0: number,\n    d1: number,\n    f0: UnaryOperator = Math.cos,\n    f1: UnaryOperator = Math.sin,\n) => {\n    return new Rotator(d, theta, d0, d1, f0, f1);\n};\n\nconst funs: {\n    [op: string]: (d: number, ...rest) => Fn;\n} = {\n    cube: (d, l) => new Cube(d, l),\n    sphere: (d, r: number) => new Sphere(d, r),\n    spiral: (d, a: number, k: number) =>\n        new Spiral(d, new Array(d).fill(a), new Array(d - 1).fill(k)),\n    torus: (d, r: number, t: number) => new Torus(d, r, t),\n    fucked_up_torus: (d, r: number, t: number) =>\n        new FuckedUpTorus(d, r, t),\n    rotate,\n    R: rotate,\n    stereo: (d, to) => new Stereo(d, to),\n};\n\ntype Funs = typeof funs;\n\ntype Ranges = {\n    [P in keyof Funs]: (domain: number) => number;\n};\n\nconst ranges: Ranges = {\n    cube: (domain) => domain,\n    sphere: (domain) => domain + 1,\n    spiral: (domain) => domain + 1,\n    torus: (domain) => domain + 1,\n    fucked_up_torus: (domain) => domain + 1,\n    rotate: (domain) => domain,\n    R: (domain) => domain,\n    stereo: (domain) => domain,\n};\n","import * as math from 'mathjs';\nimport { Scope, Substitutions, ASTNode } from './types';\nimport assert from 'assert';\nimport { pp } from '../pp';\n\nexport class Simplifier {\n    constructor(\n        private readonly scope: Scope,\n        private readonly substitutions: Substitutions,\n    ) { }\n\n    simplify = (pipe: ASTNode): ASTNode => {\n        return this.simplifyPipeNode(pipe);\n    };\n\n    private simplifyPipeNode = (pipe: ASTNode): ASTNode => {\n        const n = assertNumberInNode('n', pipe);\n        const chain = assertDefInNode('chain', pipe);\n\n        return {\n            n,\n            chain: chain.map(this.simplifyFunNode),\n        };\n    };\n\n    private simplifyFunNode = (fun: ASTNode): ASTNode => {\n        const fn = assertDefInNode('fn', fun);\n        const args = assertDefInNode('args', fun);\n\n        return {\n            fn,\n            args: args.map(this.simplifyFunArgNode),\n        };\n    };\n\n    private simplifyFunArgNode = (arg: ASTNode): ASTNode => {\n        if (arg.id) {\n            return this.simplifyVarNode(arg);\n        } else {\n            return this.simplifyArithNode(arg);\n        }\n    };\n\n    private simplifyArithNode = (arith: ASTNode): ASTNode => {\n        if (arith.op != null) {\n            const operands = assertDefInNode('operands', arith);\n            return { op: arith.op, operands: operands.map(this.simplifyArithNode) };\n        } else {\n            return this.simplifyNumberNode(arith);\n        }\n    };\n\n    private simplifyVarNode = (node: ASTNode): ASTNode => {\n        const id = node.id;\n        if (id in this.substitutions) {\n            return this.simplifyArithNode(this.substitutions[id]);\n        } else if (id in Math && typeof Math[id] === 'function') {\n            return { id, value: Math[id] };\n        } else {\n            return { id, value: math.evaluate(id, this.scope) };\n        }\n    };\n\n    private simplifyNumberNode = (scalar: ASTNode): ASTNode => {\n        const { id, value } = scalar;\n        if (value != null) {\n            return scalar;\n        } else if (id in this.substitutions) {\n            return this.simplifyArithNode(this.substitutions[id]);\n        } else if (id) {\n            const result = math.evaluate(id, this.scope);\n            assert.equal(typeof result, 'number', `Expected evaluation of ${pp(id)} to produce a number`);\n            return { id, value: result };\n        } else {\n            return scalar;\n        }\n    };\n}\n\nconst assertDefInNode = (name: string, node: ASTNode) => {\n    const x = node[name];\n    assertCondInNode(x != null, name, 'to be defined', node);\n    return x;\n};\n\nconst assertNumberInNode = (name: string, node: ASTNode): number => {\n    const x = node[name];\n    assertCondInNode(typeof x === 'number', name, 'a number', node);\n    return x as number;\n};\n\nconst assertCondInNode = (cond: boolean, name: string, expected: string, node: ASTNode) => {\n    assert(cond, `Expected ${name} to be ${expected} in ${pp(node)}`);\n};\n","import { parse } from './grammar.pegjs';\nimport { ASTNode } from './types';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\n\nconst logger = getLogger('Parser');\nlogger.setDefaultLevel('info');\n\ntype Options = {\n    startRule: 'arith';\n};\n\nconst loggingParse: typeof parse = (expr: string, options?: Options): ASTNode => {\n    try {\n        const node = parse(expr, options);\n        logger.debug(`parsed ${expr} into node ${pp(node)}`);\n        return node;\n    } catch (err) {\n        logger.error(`error parsing ${expr} at ${pp(err.location)}: ${err.message}`);\n        throw err;\n    }\n};\n\nexport class Parser {\n    static parsePipe = (pipe: string) => loggingParse(pipe);\n\n    static parseArith = (expr: string) => loggingParse(expr, { startRule: 'arith' });\n}\n","import { Scope, CompiledAST, NormalizedParams } from './types';\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\nimport { Resolver } from './resolver';\nimport { Simplifier } from './simplifier';\nimport { Parser } from './parser';\n\nconst logger = getLogger('Compiler');\nlogger.setDefaultLevel('info');\n\nexport class Compiler {\n    constructor(private readonly scope: Scope) { }\n\n    compile = (params: NormalizedParams): CompiledAST => {\n        const ast = Parser.parsePipe(params.pipe);\n        logger.debug(`parsed params into ast ${pp(ast)}`);\n        const substitutions = {\n            theta: Parser.parseArith(params.theta),\n        };\n        const simplifier = new Simplifier(this.scope, substitutions);\n        const resolver = new Resolver(this.scope);\n        return resolver.resolve(simplifier.simplify(ast));\n    };\n}\n","import { CompositeFn } from \"../fn/fn\";\nimport { CompiledAST, Scope, HV, Chunk } from \"./types\";\nimport { Data, Vector } from \"../data\";\nimport { pp } from \"../pp\";\nimport { getLogger } from \"loglevel\";\nimport { round } from \"mathjs\";\nimport assert from 'assert';\nimport { Color } from \"three\";\nimport { hsv } from 'color-convert';\n\nconst logger = getLogger('Evaluator');\n\nexport class Evaluator {\n    private readonly n: number;\n    private readonly init: CompositeFn;\n    private readonly iter: CompositeFn;\n    private readonly offset: number;\n    private readonly limit: number;\n\n    constructor(\n        private readonly scope: Scope,\n        ast: CompiledAST,\n        private readonly hv: HV,\n        chunk: Chunk,\n    ) {\n        const { n, init, iter } = ast;\n        const offset = chunk.offset;\n        const size = chunk.size;\n        const limit = offset + size;\n        assert(offset >= 0, `offset must be non-negative; got ${offset}`);\n        assert(limit <= n, `offset + size must be <= n; got ${offset} + ${size} = ${limit} > ${n}`);\n\n        this.n = n;\n        this.init = init;\n        this.iter = iter;\n        this.offset = offset;\n        this.limit = limit;\n    }\n\n\n    private get d() {\n        return this.iter.d;\n    }\n\n    initialize = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { n, init, offset, limit } = this;\n        const input = Data.input(data);\n        let i = offset;\n        for (const y of init.sample(n, offset, limit)) {\n            Data.set(input, y, i++, init.d);\n        }\n    };\n\n    iterate = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { init, iter, scope, n, offset, limit } = this;\n        const input = Data.input(data);\n        const position = Data.position(data);\n        const start = Date.now();\n\n        assert.equal(data[Data.nOffset], n, `n(data) != n(evaluator)`);\n        assert.equal(data[Data.inputOffset], init.d, `d0(data) != d0(evaluator)`);\n        assert.equal(data[Data.positionOffset(data)], iter.d, 'd(data) != d(evaluator)');\n\n        logger.debug(`iterating using ${pp(scope)}, ${pp(iter)}`);\n        for (let i = offset; i < limit; i++) {\n            iter.fn(Data.get(input, i, init.d), Data.get(position, i, iter.d));\n        }\n\n        this.computeColors(data);\n\n        logger.debug(`iteration complete in ${Date.now() - start}ms`);\n    };\n\n    private computeColors = (data: Vector) => {\n        logger.debug(`computing colors`);\n        const { d, scope, hv, offset, limit } = this;\n        const position = Data.position(data);\n        const color = Data.color(data);\n\n        for (let i = offset; i < limit; i++) {\n            const p = Data.get(position, i, d);\n            const colorScope = { ...scope, p, i };\n            const [h, s, l] = hsv.hsl([\n                round(hv.h.evaluate(colorScope), 0),\n                100,\n                round(hv.v.evaluate(colorScope), 0),\n            ]);\n            const c = new Color(`hsl(${h}, ${s}%, ${l}%)`);\n\n            Data.set(color, [c.r, c.g, c.b], i, 3);\n        }\n\n    };\n}\n","import * as math from 'mathjs';\nimport { getLogger } from 'loglevel';\nimport { Params, Scope, NormalizedParams, CompiledAST, HV, Chunk } from './types';\nimport { Compiler } from './compiler';\nimport { Evaluator } from './evaluator';\n\nconst logger = getLogger('Pipe');\nlogger.setLevel('info');\n\nexport class Pipe {\n    static compile = (params: Params): CompiledAST => {\n        return Pipe.compileNormal(Pipe.normalized(params));\n    };\n    static evaluatorFor = (params: Params, chunk?: Chunk) => {\n        return Pipe.evaluatorForNormal(Pipe.normalized(params), chunk);\n    };\n\n    private static evaluatorForNormal = (params: NormalizedParams, chunk?: Chunk) => {\n        const ast = Pipe.compileNormal(params);\n        const scope = Pipe.finalScope(params, ast);\n        const hl = Pipe.compileHL(params);\n        return new Evaluator(scope, ast, hl, chunk);\n    };\n\n    private static compileNormal = (params: NormalizedParams): CompiledAST => {\n        const { power, chroma, t } = params;\n        return new Compiler({ t, power, chroma }).compile(params);\n\n    };\n\n    private static normalized = (params: Params): NormalizedParams => {\n        return {\n            pipe: params.pipe,\n            theta: params.theta || 't',\n            h: params.h || '1',\n            v: params.v || '0.5',\n            t: params.t || 0,\n            power: params.power || 0,\n            chroma: params.chroma || 0,\n        };\n    };\n\n    private static finalScope = (params: NormalizedParams, ast: CompiledAST): Scope => {\n        const { power, t, chroma } = params;\n        const scope: Scope = { t, power, chroma, n: ast.n };\n        scope.theta = math.evaluate(params.theta, scope);\n\n        return scope;\n    };\n\n    private static compileHL = (params: NormalizedParams): HV => {\n        return {\n            h: math.compile(`359 * (${params.h})`),\n            v: math.compile(`100 * (${params.v})`),\n        };\n    };\n}\n","export const pp = (a: any, p = 2) => JSON.stringify(a, null, p);\n","import { Subject, BehaviorSubject } from 'rxjs';\n\ntype Change<T> = {\n    newValue: T;\n    oldValue?: T;\n    event?: Event;\n};\n\nconst query = new URLSearchParams(window.location.search);\nconst persistenceEnabled = query.get('p') != '0';\nconst hash = (() => {\n    const temp = window.location.hash.substr(1);\n    return new URLSearchParams(temp ? atob(temp) : '');\n})();\n\nexport abstract class Input<T> {\n    private readonly subject: Subject<Change<T>>;\n\n    constructor(\n        readonly id: string,\n        private _value: T,\n        private readonly persistent: boolean\n    ) {\n        if (persistenceEnabled) {\n            this.initFromOrWriteToHash();\n        } else {\n            this.persistent = false;\n        }\n        this.subject = this.newSubject();\n    }\n\n    initFromOrWriteToHash = () => {\n        if (this.persistent && hash.has(this.id)) {\n            this._value = this.parse(hash.get(this.id));\n        } else if (this.persistent) {\n            this.updateHash();\n        }\n    };\n\n    newSubject = () => new BehaviorSubject({ newValue: this._value });\n\n    protected abstract parse(str: string): T;\n    protected abstract stringify(value: T): string;\n\n    get stream() {\n        return this.subject.asObservable();\n    }\n\n    get value() {\n        return this._value;\n    }\n\n    set value(newValue: T) {\n        const oldValue = this.value;\n        this._value = newValue;\n        this.subject.next({ newValue, oldValue, event: window.event });\n        if (this.persistent) {\n            const str = this.stringify(newValue);\n            localStorage.setItem(`inputs.${this.id}`, str);\n            this.updateHash();\n        }\n    }\n\n    private updateHash = () => {\n        const str = this.stringify(this.value);\n        hash.set(this.id, str);\n        document.location.hash = btoa(hash.toString());\n\n    };\n}\n\ntype TextInputId = 'pipe' | 'theta' | 'h' | 'v';\n\nexport class TextInput extends Input<string> {\n    readonly disabled = false;\n\n    constructor(\n        readonly id: TextInputId,\n        _value: string,\n        persistent: boolean = true,\n    ) {\n        super(id, _value, persistent);\n    }\n\n    protected parse(str: string) {\n        return str;\n    }\n\n    protected stringify(text: string) {\n        return text;\n    }\n}\n\ntype ToggleInputId = 'animate' | 'mic' | 'fullscreen';\n\nexport class ToggleInput extends Input<boolean> {\n    constructor(\n        readonly id: ToggleInputId,\n        _value: boolean,\n        readonly on: string,\n        readonly off: string,\n        readonly disabled: boolean = false,\n        persistent: boolean = true,\n    ) {\n        super(id, _value, persistent);\n    }\n\n    protected parse(str: string) {\n        if (/1|true/i.test(str)) return true;\n        else if (/0|false/i.test(str)) return false;\n        else throw new Error(`invalid boolean value for input ${this.id}: ${str}`);\n    };\n\n    protected stringify(bool: boolean) {\n        return bool ? '1' : '0';\n    }\n}\n\n\ntype RangeInputId = 'allowed_dbs';\n\nexport class RangeInput extends Input<[number, number]> {\n    constructor(\n        readonly id: RangeInputId,\n        _value: [number, number],\n        readonly disabled: boolean = false,\n        persistent: boolean = true,\n    ) {\n        super(id, _value, persistent);\n    }\n\n    parse(str: string): [number, number] {\n        const [min, max] = str.split(/,/);\n        return [parseInt(min), parseInt(max)];\n    }\n\n    stringify([min, max]) {\n        return `${min},${max}`;\n    }\n}\n\nexport const inputs = {\n    pipe: new TextInput(\n        'pipe',\n        '10000->sphere(4, 1)->R(theta, 0, 1, cos, tan)->R(theta, 0, 2)->R(theta, 0, 3)->stereo(3)',\n    ),\n    theta: new TextInput('theta', 'pi * (t + power) / 20'),\n    h: new TextInput('h', 'chroma * (i + 1) / n'),\n    v: new TextInput('v', 'power'),\n    animate: new ToggleInput('animate', true, 'play', 'pause', false, true),\n    mic: new ToggleInput('mic', false, 'mic', 'mic_off', false, false),\n    fullscreen: new ToggleInput(\n        'fullscreen',\n        false,\n        'enter_fullscreen',\n        'exit_fullscreen',\n        !document.fullscreenEnabled,\n        false,\n    ),\n    allowedDbs: new RangeInput('allowed_dbs', [-70, -30]),\n};\nexport type Inputs = typeof inputs;\n\nwindow.inputs = inputs;\n","import assert from 'assert';\n\nexport type Vector = Float32Array;\n\nexport class Data {\n    constructor(\n        readonly n: number,\n        readonly d: number,\n        readonly position: Float32Array,\n        readonly color: Float32Array\n    ) { }\n\n    static fromBuffer = (buffer: ArrayBuffer) => {\n        const data = new Float32Array(buffer);\n        const n = data[Data.nOffset];\n        const d = data[Data.positionOffset(data)];\n        const position = Data.position(data);\n        const color = Data.color(data);\n        return new Data(n, d, position, color);\n    };\n\n    static bufferFor = (n: number, d0: number, d: number): SharedArrayBuffer => {\n        const bytesPerNum = 4;\n        const count = 3 + n * (d0 + d + 3);\n        const byteLength = bytesPerNum * count;\n        const buffer = new SharedArrayBuffer(byteLength);\n        const data = new Float32Array(buffer);\n        data[Data.nOffset] = n;\n        data[Data.inputOffset] = d0;\n        data[Data.positionOffset(data)] = d;\n        return buffer;\n    };\n\n    static input = (arr: Float32Array) => {\n        const offset = Data.inputOffset + 1;\n        return arr.subarray(offset, offset + Data.inputLength(arr));\n    };\n\n    static position = (arr: Float32Array) => {\n        const offset = Data.positionOffset(arr) + 1;\n        return arr.subarray(offset, offset + Data.positionLength(arr));\n    };\n\n    static color = (arr: Float32Array) => {\n        const offset = Data.colorOffset(arr);\n        return arr.subarray(offset);\n    };\n\n    static nOffset = 0;\n\n    static inputOffset = Data.nOffset + 1;\n    private static inputLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d0 = arr[Data.inputOffset];\n        return n * d0;\n    };\n\n    static positionOffset = (arr: Float32Array) =>\n        Data.inputOffset + Data.inputLength(arr) + 1;\n    private static positionLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d = arr[Data.positionOffset(arr)];\n        return n * d;\n    };\n\n    static colorOffset = (arr: Float32Array) =>\n        Data.positionOffset(arr) + Data.positionLength(arr) + 1;\n\n    static get = (arr: Vector, i: number, stride: number) => {\n        const offset = i * stride;\n        return arr.subarray(offset, offset + stride);\n    };\n\n    static set = (arr: Vector, value: ArrayLike<number>, i: number, stride: number) => {\n        assert(value.length <= stride);\n        const offset = i * stride;\n        return arr.set(value, offset);\n    };\n}\n","import { spawn, Worker, Pool, ModuleThread } from \"threads\";\nimport { getLogger } from 'loglevel';\nimport { Params, PipelineWorker, Chunk } from './types';\nimport { Pipe } from \"./pipe\";\nimport { ceil } from \"mathjs\";\nimport { Data } from \"../data\";\n\nconst logger = getLogger('PipelinePool');\nlet pool: Pool<ModuleThread<PipelineWorker>>;\nlet data: Map<string, SharedArrayBuffer>;\nlogger.setLevel('info');\nlet poolSize = 0;\n\nexport const startPool = async (size: number) => {\n    logger.info('starting worker pool');\n    pool = Pool(() => spawn(new Worker('./pipe.worker')), size);\n    poolSize = size;\n    data = new Map();\n    let promises = [];\n    for (let i = 0; i < size; i++) {\n        // pre-load scripts so the first task doesn't take forever\n        promises.push(pool.queue(async () => { }));\n    }\n    await Promise.all(promises);\n};\n\nexport const stopPool = async (): Promise<void> => {\n    logger.info('waiting for pending tasks to complete before terminating pool');\n    try {\n        await pool.terminate(true);\n    } catch (err) {\n        logger.error(err);\n    } finally {\n        pool = null;\n    }\n};\n\nconst initialize = (params: Params, n: number, buffer: SharedArrayBuffer): Promise<void> => {\n    return timing('initialization')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.initialize(params, chunk, buffer));\n        });\n    });\n};\n\nconst iterate = (params: Params, n: number, buffer: SharedArrayBuffer) => {\n    return timing('iteration')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.iterate(params, chunk, buffer));\n        });\n    });\n};\n\nconst getKey = (params: Params) => JSON.stringify({\n    pipe: params.pipe,\n    theta: params.theta,\n    h: params.h,\n    l: params.v,\n});\n\nconst getOrInitialize = async (params: Params, n: number, d0: number, d: number): Promise<SharedArrayBuffer> => {\n    const key = getKey(params);\n    if (!data.has(key)) {\n        const buffer = Data.bufferFor(n, d0, d);\n        await initialize(params, n, buffer);\n        data.set(key, buffer);\n    }\n    return data.get(key);\n};\n\nconst forkJoin = async (n: number, op: (chunk: Chunk) => Promise<void>) => {\n    const size = ceil(n / poolSize);\n    let promises = [];\n    for (let offset = 0; offset < n; offset += size) {\n        const chunk = { offset, size: Math.min(n - offset, size) };\n        promises.push(op(chunk));\n    }\n    await Promise.all(promises);\n};\n\nconst timing = (label: string) => async<T>(op: () => Promise<T>) => {\n    const start = Date.now();\n    const t = await op();\n    const elapsed = Date.now() - start;\n    logger.debug(`${label} took ${elapsed}ms`);\n    return t;\n};\n\nexport const runPipeline = async (params: Params): Promise<SharedArrayBuffer> => {\n    const { n, init, iter } = Pipe.compile(params);\n    const buffer = await getOrInitialize(params, n, init.d, iter.d);\n    await iterate(params, n, buffer);\n\n    return buffer.slice(0);\n};\n","module.exports = __webpack_public_path__ + \"0.2d91cad08687f855c757.worker.js\"","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { pipe: peg$parsepipe, arith: peg$parsearith },\n      peg$startRuleFunction  = peg$parsepipe,\n\n      peg$c0 = function(n, chain) {\n        return {n: parseInt(n), chain};\n      },\n      peg$c1 = function(head, tail) { return [head, ...tail]; },\n      peg$c2 = function(f) { return [f]; },\n      peg$c3 = function(fn, args) { return {fn, args} },\n      peg$c4 = function(a) { return [a]; },\n      peg$c5 = function(s, op, a) { return {op, operands: [s, a]}; },\n      peg$c6 = function(value) { return {value}; },\n      peg$c7 = function(a) { return a; },\n      peg$c8 = function(id) { return {id}; },\n      peg$c9 = function(f) { return parseFloat(f); },\n      peg$c10 = function(i) { return parseInt(i); },\n      peg$c11 = /^[a-zA-Z]/,\n      peg$c12 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n      peg$c13 = /^[a-zA-Z0-9]/,\n      peg$c14 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n      peg$c15 = function(id) { return id; },\n      peg$c16 = /^[+\\-]/,\n      peg$c17 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c18 = /^[0-9]/,\n      peg$c19 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c20 = /^[eE]/,\n      peg$c21 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c22 = \".\",\n      peg$c23 = peg$literalExpectation(\".\", false),\n      peg$c24 = \"+\",\n      peg$c25 = peg$literalExpectation(\"+\", false),\n      peg$c26 = \"-\",\n      peg$c27 = peg$literalExpectation(\"-\", false),\n      peg$c28 = \"*\",\n      peg$c29 = peg$literalExpectation(\"*\", false),\n      peg$c30 = \"/\",\n      peg$c31 = peg$literalExpectation(\"/\", false),\n      peg$c32 = \"**\",\n      peg$c33 = peg$literalExpectation(\"**\", false),\n      peg$c34 = \"^\",\n      peg$c35 = peg$literalExpectation(\"^\", false),\n      peg$c36 = function(op) { return op; },\n      peg$c37 = \"(\",\n      peg$c38 = peg$literalExpectation(\"(\", false),\n      peg$c39 = \")\",\n      peg$c40 = peg$literalExpectation(\")\", false),\n      peg$c41 = \",\",\n      peg$c42 = peg$literalExpectation(\",\", false),\n      peg$c43 = \"->\",\n      peg$c44 = peg$literalExpectation(\"->\", false),\n      peg$c45 = \"=>\",\n      peg$c46 = peg$literalExpectation(\"=>\", false),\n      peg$c47 = /^[ \\t\\n\\r]/,\n      peg$c48 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepipe() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseuint();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsechain() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefun();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefun();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselparen();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefun_args();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserparen();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun_args() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefun_arg();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefn_arg_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefun_args();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefun_arg();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefun_arg() {\n    var s0;\n\n    s0 = peg$parseid();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsearith();\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsescalar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsearith_op();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsearith();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c5(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsescalar();\n    }\n\n    return s0;\n  }\n\n  function peg$parsescalar() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c6(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseid();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parselparen();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsearith();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parserparen();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c7(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c8(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefloat();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseint();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c10(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      if (peg$c11.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        if (peg$c13.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c14); }\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          if (peg$c13.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloat() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c18.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsemantissa();\n        if (s4 !== peg$FAILED) {\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseint();\n            if (s6 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5, s6];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseint();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemantissa();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseint() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseuint() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c18.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c18.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemantissa() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c22;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith_op() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s3 = peg$c24;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s3 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s3 = peg$c26;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c27); }\n        }\n        if (s3 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s3 = peg$c28;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c29); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c30;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c31); }\n            }\n            if (s3 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c32) {\n                s3 = peg$c32;\n                peg$currPos += 2;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c33); }\n              }\n              if (s3 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 94) {\n                  s3 = peg$c34;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c35); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c36(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c37;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 41) {\n        s2 = peg$c39;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefn_arg_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c41;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepipe_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c43) {\n        s3 = peg$c43;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c45) {\n            s3 = peg$c45;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c46); }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c47.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n"],"sourceRoot":""}