{"version":3,"sources":["../../src/comlink.ts","constants.ts","fn/index.ts","fn/interval.ts","fn/lattice.ts","fn/cube.ts","fn/polar.ts","fn/sphere.ts","fn/fucked_up_torus.ts","fn/rotator.ts","reducable.ts","fn/spiral.ts","fn/stereo.ts","fn/torus.ts","pp.ts","pipe/resolver.ts","pipe/evaluator.ts","pipe/worker.ts"],"names":[],"mappings":"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","file":"worker.de81ab89.js","sourceRoot":"../src","sourcesContent":["/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst throwSet = new WeakSet();\n\n// prettier-ignore\ntype Promisify<T> =\n  T extends { [proxyMarker]: boolean }\n    ? Promise<Remote<T>>\n    : T extends (...args: infer R1) => infer R2\n        ? (...args: R1) => Promisify<R2>\n        : Promise<T>;\n\n// prettier-ignore\nexport type Remote<T> =\n  (\n    T extends (...args: infer R1) => infer R2\n      ? (...args: R1) => Promisify<R2>\n      : unknown\n  ) &\n  (\n    T extends { new (...args: infer R1): infer R2 }\n      ? { new (...args: R1): Promise<Remote<R2>> }\n      : unknown\n  ) &\n  (\n    T extends Object\n      ? { [K in keyof T]: Remote<T[K]> }\n      : unknown\n  ) &\n  (\n    T extends string\n      ? Promise<string>\n      : unknown\n  ) &\n  (\n    T extends number\n      ? Promise<number>\n      : unknown\n  ) &\n  (\n    T extends boolean\n      ? Promise<boolean>\n      : unknown\n  ) & {\n    [createEndpoint]: MessagePort;\n    [releaseProxy]: () => void;\n  };\n\ndeclare var x: Remote<number>;\n\ndeclare var y: PromiseLike<number>;\n\nexport interface TransferHandler {\n  canHandle(obj: any): boolean;\n  serialize(obj: any): [any, Transferable[]];\n  deserialize(obj: any): any;\n}\n\nexport const transferHandlers = new Map<string, TransferHandler>([\n  [\n    \"proxy\",\n    {\n      canHandle: obj => obj && obj[proxyMarker],\n      serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n      },\n      deserialize: (port: MessagePort) => {\n        port.start();\n        return wrap(port);\n      }\n    }\n  ],\n  [\n    \"throw\",\n    {\n      canHandle: obj => throwSet.has(obj),\n      serialize(obj) {\n        const isError = obj instanceof Error;\n        let serialized = obj;\n        if (isError) {\n          serialized = {\n            isError,\n            message: obj.message,\n            stack: obj.stack\n          };\n        }\n        return [serialized, []];\n      },\n      deserialize(obj) {\n        if ((obj as any).isError) {\n          throw Object.assign(new Error(), obj);\n        }\n        throw obj;\n      }\n    }\n  ]\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message)\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n      }\n    } catch (e) {\n      returnValue = e;\n      throwSet.add(e);\n    }\n    Promise.resolve(returnValue)\n      .catch(e => {\n        throwSet.add(e);\n        return e;\n      })\n      .then(returnValue => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function() {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map(p => p.toString())\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map(p => p.toString())\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map(p => p.toString()),\n          value\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn’t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map(p => p.toString()),\n          argumentList\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map(p => p.toString()),\n          argumentList\n        },\n        transferables\n      ).then(fromWireValue);\n    }\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map(v => v[0]), myFlat(processed.map(v => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer(obj: any, transfers: Transferable[]) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & { [proxyMarker]: true } {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context)\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue\n        },\n        transferables\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value\n    },\n    transferCache.get(value) || []\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise(resolve => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n","export const inf = 2 ** 32 - 1;\n","import assert from 'assert';\n\nimport { inf } from '../constants';\nimport { Vector } from '../types';\n\nexport interface Fn {\n  readonly d: number;\n  readonly domain: number;\n  fn(x: Vector, y?: Vector): Vector;\n  sample(n: number, offset: number, limit: number): Generator<Vector>;\n}\n\nexport class CompositeFn implements Fn {\n  private readonly x: Vector;\n  private readonly y: Vector;\n  constructor(readonly fns: Fn[]) {\n    assert(fns.length, 'fns cannot be empty');\n\n    const length = Math.max(this.domainMax, this.dMax);\n    this.x = new Float32Array(length);\n    this.y = new Float32Array(length);\n  }\n\n  get first() {\n    return this.fns[0];\n  }\n\n  get last() {\n    return this.fns[this.fns.length - 1];\n  }\n\n  get domain() {\n    return this.first.domain;\n  }\n\n  get d() {\n    return this.last.d;\n  }\n\n  get domainMax() {\n    return this.fns.reduce((max, f) => Math.max(f.domain, max), 0);\n  }\n\n  get dMax() {\n    return this.fns.reduce((max, f) => Math.max(f.d, max), 0);\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const { fns, d } = this;\n    const [first, ...rest] = fns;\n    if (fns.length == 0) return [];\n\n    for (const x of first.sample(n, offset, limit)) {\n      this.x.set(x);\n      if (rest.length) {\n        CompositeFn.apply(rest, this.x, this.y);\n      } else {\n        this.y.set(x);\n      }\n      yield this.y.subarray(0, d);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { fns, domain, d } = this;\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    this.x.set(x);\n    CompositeFn.apply(fns, this.x, this.y);\n    y.set(this.y.subarray(0, d));\n    return y;\n  };\n\n  private static apply = (fns: Fn[], x: Vector, y: Vector) => {\n    assert.equal(x.length, y.length);\n    for (const f of fns) {\n      f.fn(x.subarray(0, f.domain), y.subarray(0, f.d));\n      for (let i = 0; i < y.length; i++) {\n        if (!isFinite(y[i])) y[i] = Math.sign(y[i]) * inf;\n        if (isNaN(y[i])) y[i] = 0;\n      }\n      x.set(y);\n    }\n  };\n\n  static Builder = class {\n    private readonly fns: Fn[] = [];\n\n    get d() {\n      return this.last.d;\n    }\n\n    get last() {\n      return this.fns[this.fns.length - 1];\n    }\n\n    add = (fn: Fn) => {\n      const { fns, last } = this;\n      if (last && fn.domain !== last.d) {\n        throw new Error(\n          `Cannot add ${fn} to composite, because its domain is not ${last.d}`\n        );\n      }\n      fns.push(fn);\n      return this;\n    };\n\n    build = () => {\n      return new CompositeFn(this.fns);\n    };\n  };\n}\n","import assert from 'assert';\n\nimport { Vector } from '../types';\nimport { Fn } from '.';\n\nexport default class Interval implements Fn {\n  readonly domain: number;\n\n  constructor(readonly d: number, readonly a: number[], readonly b: number[]) {\n    assert.equal(a.length, d);\n    assert.equal(b.length, d);\n    this.domain = d;\n  }\n\n  static nPerLevel = (d: number, n: number) => {\n    return Math.round(Math.pow(n, 1 / d));\n  };\n\n  /**\n   * @param x A vector of length this.domain contained in the interval [0, 1].\n   * @returns A mapping of the vector into this interval.\n   */\n  fn = (x: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { domain, d, a, b } = this;\n\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    for (let i = 0; i < d; i++) {\n      y[i] = a[i] + x[i] * (b[i] - a[i]);\n    }\n\n    return y;\n  };\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const { d, fn } = this;\n    // b needs to be an integer or the shape is distorted\n    const b = Math.round(n ** (1 / d));\n    const x = new Float32Array(d);\n    for (let i = offset; i < limit; i++) {\n      for (let k = 0; k < d; k++) {\n        const exp = d - k - 1;\n        const n = Math.round(i / b ** exp);\n        x[k] = (n % b) / (b - 1);\n      }\n      yield fn(x);\n    }\n  };\n}\n","import { Vector } from '../types';\nimport Interval from './interval';\nimport { Fn } from '.';\n\nexport default class Lattice implements Fn {\n  private readonly interval: Interval;\n  readonly sample: (\n    n: number,\n    offset: number,\n    limit: number\n  ) => Generator<Float32Array>;\n\n  constructor(readonly d: number, readonly l: number) {\n    this.interval = new Interval(\n      d,\n      new Array(d).fill(-l / 2),\n      new Array(d).fill(l / 2)\n    );\n\n    this.sample = this.interval.sample;\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  fn = (x: Vector, y?: Vector) => this.interval.fn(x, y);\n}\n","import assert from 'assert';\n\nimport { Vector } from '../types';\nimport Lattice from './lattice';\nimport { Fn } from '.';\n\nexport default class Cube implements Fn {\n  constructor(readonly d: number, readonly l: number) {}\n\n  get domain() {\n    return this.d;\n  }\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { domain, d, l } = this;\n\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    for (let i = 0; i < d; i++) {\n      y[i] = l * (x[i] - 0.5);\n    }\n\n    return y;\n  };\n\n  sample = function*(n: number, offset: number, limit: number) {\n    // TODO: This algorithm produces lots of duplicate points.\n    // It looks good enough, but could be better.\n    const { d } = this;\n    const scale = 1 / d / 2;\n    const faceN = Math.round(n * scale);\n    const faceOffset = Math.round(offset * scale);\n    const faceSize = Math.round((limit - offset) * scale);\n    let count = 0;\n\n    for (let k = 0; k < d; k++) {\n      for (const sign of [1, -1]) {\n        const faceLimit = faceOffset + Math.min(faceSize, n - count);\n        yield* this.sampleFace(k, sign, faceN, faceOffset, faceLimit);\n        count += faceLimit - faceOffset;\n      }\n    }\n  };\n\n  private sampleFace = function*(\n    k: number,\n    sign: number,\n    n: number,\n    offset: number,\n    limit: number\n  ) {\n    const { d, l } = this;\n    const lattice = new Lattice(d - 1, l);\n    const lhalf = l / 2;\n\n    for (const y0 of lattice.sample(n, offset, limit)) {\n      const y = new Float32Array(d);\n      y.set(y0.subarray(0, k));\n      y.set(y0.subarray(k), k + 1);\n\n      y[k] = sign * lhalf;\n      yield y;\n    }\n  };\n}\n","import assert from 'assert';\n\nexport class Polar {\n  static from(\n    r: number,\n    phi: Float32Array,\n    y = new Float32Array(phi.length + 1)\n  ) {\n    assert.equal(y.length, phi.length + 1);\n\n    y[0] = r;\n    for (let i = 1; i < y.length; i++) {\n      const sin = Math.sin(phi[i - 1]);\n      const cos = Math.cos(phi[i - 1]);\n      y[i] = y[0] * sin;\n      y[0] *= cos;\n    }\n    return y;\n  }\n}\n","import assert from 'assert';\n\nimport { Vector } from '../types';\nimport Lattice from './lattice';\nimport { Polar } from './polar';\nimport { Fn } from '.';\n\nexport default class Sphere implements Fn {\n  private readonly root: Float32Array;\n\n  constructor(readonly d: number, private readonly r: number) {}\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const lattice = new Lattice(this.domain, 2 * Math.PI);\n    for (const phi of lattice.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, r } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    return Polar.from(r, phi, y);\n  };\n}\n","import assert from 'assert';\n\nimport { Vector } from '../types';\nimport Lattice from './lattice';\nimport Sphere from './sphere';\nimport { Fn } from '.';\n\n// This shape does not implement a torus. It used to,\n// but then I changed the way Rotator works, which\n// changed the way that the points of the sphere are\n// distributed, making the translation step behave incorrectly\n// Still makes a cool shape though, so keeping it\nexport default class FuckedUpTorus implements Fn {\n  private readonly sphere: Sphere;\n  private readonly circle: Sphere;\n\n  constructor(readonly d: number, readonly r: number, readonly t: number) {\n    this.sphere = new Sphere(d, t);\n    this.circle = new Sphere(2, r);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const lattice = new Lattice(this.domain, 2 * Math.PI);\n    for (const phi of lattice.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { domain, d, sphere, circle } = this;\n    assert.equal(phi.length, domain);\n    assert.equal(y.length, d);\n    sphere.fn(phi, y);\n    const q = circle.fn(phi.subarray(d - 2));\n    y[0] += q[0];\n    y[d - 1] += q[1];\n    return y;\n  };\n}\n","import assert from 'assert';\n\nimport { Vector } from '../types';\nimport Lattice from './lattice';\nimport { Fn } from '.';\n\nexport default class Rotator implements Fn {\n  readonly r0: number;\n  readonly r1: number;\n\n  constructor(\n    readonly d: number,\n    readonly theta: number,\n    readonly d0: number,\n    readonly d1: number,\n    readonly f0: (theta: number) => number = Math.cos,\n    readonly f1: (theta: number) => number = Math.sin\n  ) {\n    this.r0 = f0(theta);\n    this.r1 = f1(theta);\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const lattice = new Lattice(this.domain, 2);\n    for (const p of lattice.sample(n, offset, limit)) {\n      yield this.fn(p);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, d0, d1, r0, r1 } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    y.set(x);\n\n    const a = x[d0],\n      b = x[d1];\n    y[d0] = a * r0 - b * r1;\n    y[d1] = a * r1 + b * r0;\n    return y;\n  };\n}\n","import { inf } from './constants';\n\ninterface Reducable<T> {\n  reduce<M>(cb: (memo: M, t: T, i: number) => M, m0?: M): M;\n  slice(start?: number): this;\n  sort(cb?: (a: T, b: T) => number): this;\n  length: number;\n  [index: number]: T;\n}\n\nconst identity = (x: number) => x;\n\nexport const argmax = <T>(xs: Reducable<T>, mapper = (t: T) => Number(t)) => {\n  if (!xs.length) return 0;\n  return xs.reduce(\n    (memo, t, arg) => {\n      const x = mapper(t);\n      return x > memo.x ? { x, arg } : memo;\n    },\n    { x: -inf, arg: -1 }\n  ).arg;\n};\n\nexport const dot = (as: Reducable<number>, bs: Reducable<number>) =>\n  sum(as, (ai, i) => ai + bs[i]);\n\nexport const max = (xs: Reducable<number>, mapper = identity) =>\n  xs[argmax(xs, mapper)];\n\nexport const min = (xs: Reducable<number>, mapper = identity) =>\n  xs.length ? xs.reduce<number>((m, x) => Math.min(m, mapper(x))) : 0;\n\nexport const mean = (xs: Reducable<number>, mapper = identity) =>\n  sum(xs, mapper) / xs.length;\n\nexport const mad = (xs: Reducable<number>) => {\n  const m = mean(xs);\n  return mean(xs, x => Math.abs(x - m));\n};\n\nexport const norm = (xs: Reducable<number>) => {\n  return Math.sqrt(sum(xs, x => x * x));\n};\n\nexport const std = (xs: Reducable<number>) => Math.sqrt(variance(xs));\n\nexport const variance = (xs: Reducable<number>) => {\n  const m = mean(xs);\n  return mean(xs, x => (x - m) ** 2);\n};\n\nexport const sum = (\n  xs: Reducable<number>,\n  mapper = (x: number, i: number) => x\n) => xs.reduce((memo, x, i) => memo + mapper(x, i), 0);\n\nexport const median = (xs: Reducable<number>) => {\n  const sorted = xs.slice().sort((a, b) => a - b);\n  return sorted[Math.round(xs.length / 2)];\n};\n","import assert from 'assert';\n\nimport { norm } from '../reducable';\nimport { Vector } from '../types';\nimport Interval from './interval';\nimport { Polar } from './polar';\nimport { Fn } from '.';\n\nexport default class Spiral implements Fn {\n  private readonly interval: Interval;\n\n  constructor(\n    /**\n     * The dimension of the spiral.\n     */\n    readonly d: number,\n    /**\n     * The extent of curl of the spiral, i.e. the max angle in each\n     * dimension.\n     */\n    readonly theta: number,\n    /**\n     * The radial factor. This is multiplied by the magnitude\n     * of the input angle vector to determine the magnitude\n     * of the output.\n     */\n    readonly r: number\n  ) {\n    this.interval = new Interval(\n      this.domain,\n      new Array(this.domain).fill(0),\n      new Array(this.domain).fill(theta)\n    );\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    for (const x of this.interval.sample(n, offset, limit)) {\n      yield this.fn(x);\n    }\n  };\n\n  fn = (phi: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { domain, d, r } = this;\n    assert.equal(phi.length, domain);\n    assert.equal(y.length, d);\n\n    return Polar.from(r * norm(phi), phi, y);\n  };\n}\n","import assert from 'assert';\n\nimport { Vector } from '../types';\nimport Lattice from './lattice';\nimport { Fn } from '.';\n\nexport default class Stereo implements Fn {\n  private readonly fromTemp: Vector;\n  private readonly toTemp: Vector;\n\n  constructor(private readonly from: number, private readonly to: number) {\n    this.fromTemp = new Float32Array(Math.max(from, to));\n    this.toTemp = new Float32Array(Math.max(from, to));\n  }\n\n  get domain() {\n    return this.from;\n  }\n\n  get d() {\n    return this.to;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const lattice = new Lattice(this.domain, 2);\n    for (const phi of lattice.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.to)) => {\n    let { from, to, fromTemp, toTemp } = this;\n    assert.equal(x.length, from);\n    assert.equal(y.length, to);\n\n    if (from === to) {\n      y.set(x);\n      return y;\n    }\n\n    fromTemp.set(x);\n\n    while (from < to) {\n      Stereo.up(fromTemp.subarray(0, from), toTemp.subarray(0, ++from));\n      fromTemp.set(toTemp);\n    }\n\n    while (from > to) {\n      Stereo.down(fromTemp.subarray(0, from), toTemp.subarray(0, --from));\n      fromTemp.set(toTemp);\n    }\n\n    y.set(toTemp.subarray(0, to));\n    return y;\n  };\n\n  static up = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length + 1);\n    const n2 = norm2(x);\n    const divisor = n2 + 1;\n    temp[0] = (n2 - 1) / divisor;\n    for (let i = 1; i <= x.length; i++) {\n      temp[i] = (2 * x[i - 1]) / divisor;\n    }\n  };\n\n  static down = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length - 1);\n    for (let i = 0; i < temp.length; i++) {\n      temp[i] = x[i + 1] / (1 - x[0]);\n    }\n  };\n}\n\nconst norm2 = (x: Vector) => {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * x[i];\n  }\n  return result;\n};\n","import assert from 'assert';\n\nimport { Vector } from '../types';\nimport Lattice from './lattice';\nimport Rotator from './rotator';\nimport Sphere from './sphere';\nimport { Fn } from '.';\n\nexport default class Torus implements Fn {\n  constructor(readonly d: number, readonly r: Float32Array) {\n    assert(d > 2, `torus: expected d = ${d} > 2`);\n    assert(\n      r.length == this.domain,\n      `torus: expected r.length = ${r.length} == ${this.domain}`\n    );\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function*(n: number, offset: number, limit: number) {\n    const lattice = new Lattice(this.domain, 2 * Math.PI);\n    for (const phi of lattice.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (theta: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, domain, r } = this;\n    const circle = new Sphere(2, r[0]);\n    circle.fn(theta.subarray(0, 1), y.subarray(0, 2));\n    for (let i = 1; i < domain; i++) {\n      y[0] += r[i];\n      const rotator = new Rotator(d, theta[i], i - 1, i + 1);\n      rotator.fn(y, y);\n    }\n    return y;\n  };\n}\n","export const pp = (a: any, p = 2) => JSON.stringify(a, null, p);\n","import { CompositeFn, Fn } from '../fn';\nimport Cube from '../fn/cube';\nimport FuckedUpTorus from '../fn/fucked_up_torus';\nimport Lattice from '../fn/lattice';\nimport Rotator from '../fn/rotator';\nimport Sphere from '../fn/sphere';\nimport Spiral from '../fn/spiral';\nimport Stereo from '../fn/stereo';\nimport Torus from '../fn/torus';\nimport { Scope } from '../params/scope';\nimport { pp } from '../pp';\nimport {\n  AccessNode,\n  ArithNode,\n  FnNode,\n  PipeNode,\n  Scalar,\n  StepNode,\n  Value\n} from './grammar.pegjs';\nimport { UnaryOperator } from './types';\n\ntype Resolution = {\n  n: number;\n  fn: CompositeFn;\n};\n\nfunction assert(cond: boolean, scope: Scope, msg: () => string) {\n  if (!cond) throw { message: msg(), scope };\n}\n\nexport class Resolver {\n  constructor(private readonly scope: Scope) {}\n\n  resolve(node: PipeNode): Resolution;\n  resolve(node: Scalar, hint: 'number'): number;\n  resolve(node: Scalar, hint: 'function'): Function;\n  resolve(node: Scalar): Value;\n  resolve(node: any, hint?: any): any {\n    let value;\n    switch (node.kind) {\n      case 'pipe':\n        value = this.resolvePipe(node);\n        break;\n      case 'arith':\n        value = this.resolveArith(node);\n        break;\n      case 'number':\n        value = node.value;\n        break;\n      case 'fn':\n        value = this.resolveFn(node);\n        break;\n      case 'access':\n        value = this.resolveAccess(node);\n        break;\n      case 'id':\n        value = this.resolveId(node.id);\n        break;\n      case 'paren':\n        value = this.resolve(node.scalar);\n        break;\n    }\n\n    if (hint) {\n      const actual = typeof value;\n      this.expect(actual === hint, node, `be a ${hint}`, `was ${actual}`);\n    }\n\n    if (hint === 'number') {\n      this.expect(!isNaN(value), node, 'be a number', 'was NaN');\n    }\n\n    return value;\n  }\n\n  private resolvePipe = (pipe: PipeNode): Resolution => {\n    const [head, ...tail] = pipe.steps;\n    const n = this.resolve(pipe.n, 'number');\n    this.expect(n > 0, 'n', 'be positive', `was ${n}`);\n\n    const fn = new CompositeFn.Builder().add(this.resolveStep(pipe.d0, head));\n\n    for (let i = 0; i < tail.length; i++) {\n      const step = tail[i];\n      const d0 = fn.d;\n      const d = ranges[step.type](d0);\n      fn.add(this.resolveStep(d, step));\n    }\n\n    return { n, fn: fn.build() };\n  };\n\n  private resolveStep = (d: number, { type, args }: StepNode): Fn => {\n    return funs[type](d, ...args.map(a => this.resolve(a)));\n  };\n\n  private resolveFn = ({ name, args }: FnNode): number => {\n    const fn = Math[name];\n    const type = typeof fn;\n    this.expect(\n      type === 'function',\n      name,\n      `resolve to a function`,\n      `was ${type}`\n    );\n    return fn(...args.map(a => this.resolve(a)));\n  };\n\n  private resolveAccess = ({ id, index }: AccessNode): number => {\n    const scope = this.scope;\n    const target = scope[id];\n    this.assert(target, () => `failed to resolve access target ${id}`);\n    if (index.kind === 'id' && index.id in target) {\n      // TODO works in practice, but not sure if corret\n      return target[index.id];\n    } else {\n      return target[this.resolve(index)];\n    }\n  };\n\n  private resolveId = (id: string): Value => {\n    let value;\n    if (id in this.scope) {\n      value = this.scope[id];\n    } else if (id in Math) {\n      value = Math[id];\n    } else {\n      const idu = id.toUpperCase();\n      if (idu in Math) value = Math[idu];\n    }\n\n    this.assert(value, () => `failed to resolve id ${id}`);\n\n    return value;\n  };\n\n  private resolveArith = ({ op, operands }: ArithNode) => {\n    const [a, b] = operands.map(a => this.resolve(a, 'number'));\n    return ops[op](a, b);\n  };\n\n  private isNodeDynamic = (node: Scalar): boolean => {\n    switch (node.kind) {\n      case 'fn':\n        return node.args.some(this.isNodeDynamic);\n      case 'id':\n        return typeof this.resolve(node) === 'number';\n      case 'arith':\n        return node.operands.some(this.isNodeDynamic);\n      default:\n        return false;\n    }\n  };\n\n  private assert(cond: boolean, msg: () => string) {\n    assert(cond, this.scope, msg);\n  }\n\n  private expect(cond: boolean, node: any, expected: string, actual: string) {\n    this.assert(\n      cond,\n      () => `Expected ${pp(node, 0)} to ${expected}, but ${actual}`\n    );\n  }\n}\n\nconst ops: { [op: string]: (a: number, b: number) => number } = {\n  '+': (a, b) => a + b,\n  '-': (a, b) => (b == null ? -a : a - b),\n  '*': (a, b) => a * b,\n  '/': (a, b) => a / b,\n  '**': (a, b) => a ** b,\n  '^': (a, b) => a ** b\n};\n\nconst funs: { [op: string]: (d: number, ...rest: any) => Fn } = {\n  cube: (d, l) => new Cube(d, l),\n  lattice: (d, l) => new Lattice(d, l),\n  sphere: (d, r: number) => new Sphere(d, r),\n  spiral: (d, theta: number, r: number) => new Spiral(d, theta, r),\n  torus: (d, ...r: number[]) => new Torus(d, new Float32Array(r)),\n  fucked_up_torus: (d, r: number, t: number) => new FuckedUpTorus(d, r, t),\n  rotate: (\n    d: number,\n    theta: number,\n    d0: number,\n    d1: number,\n    f0: UnaryOperator = Math.cos,\n    f1: UnaryOperator = Math.sin\n  ) => {\n    assert(\n      0 <= d0 && d0 < d,\n      null,\n      () => `rotate: Expected 0 <= d0 = ${d0} < d = ${d}`\n    );\n    assert(\n      0 <= d1 && d1 < d,\n      null,\n      () => `rotate: Expected 0 <= d1 = ${d1} < d = ${d}`\n    );\n    return new Rotator(d, theta, d0, d1, f0, f1);\n  },\n  stereo: (d, to) => new Stereo(d, to)\n};\n\ntype Funs = typeof funs;\n\ntype Ranges = {\n  [P in keyof Funs]: (domain: number) => number;\n};\n\nconst ranges: Ranges = {\n  cube: domain => domain,\n  lattice: domain => domain,\n  sphere: domain => domain + 1,\n  spiral: domain => domain + 1,\n  torus: domain => domain + 1,\n  fucked_up_torus: domain => domain + 1,\n  rotate: domain => domain,\n  r: domain => domain,\n  stereo: domain => domain\n};\n","import assert from 'assert';\n\nimport { CompositeFn } from '../fn';\nimport { HSV } from '../params';\nimport { Scope } from '../params/scope';\nimport { Chunk, DataChunk, Vector } from '../types';\nimport { PipeNode, Scalar } from './grammar.pegjs';\nimport { Resolver } from './resolver';\n\nconst { abs, min, sign } = Math;\n\nexport class EvaluationError extends Error {\n  constructor(readonly context: string, readonly cause: Error) {\n    super(cause?.message);\n  }\n\n  get name() {\n    return 'EvaluationError';\n  }\n}\n\nexport class Evaluator {\n  private readonly n: number;\n  private readonly fn: CompositeFn;\n  private readonly offset: number;\n  private readonly size: number;\n  private readonly resolver: Resolver;\n\n  constructor(\n    private readonly scope: Scope,\n    ast: PipeNode,\n    private readonly hsv: HSV,\n    chunk: Chunk\n  ) {\n    this.resolver = new Resolver(scope);\n    const { n, fn } = this.resolvePipe(ast);\n    const offset = chunk.offset;\n    const size = chunk.size;\n    const limit = offset + size;\n    assert(offset >= 0, `offset must be non-negative; got ${offset}`);\n    assert(\n      limit <= n,\n      `offset + size must be <= n; got ${offset} + ${size} = ${limit} > ${n}`\n    );\n\n    this.n = n;\n    this.fn = fn;\n    this.offset = offset;\n    this.size = limit - offset;\n  }\n\n  private get d() {\n    return this.fn.d;\n  }\n\n  private resolvePipe(node: PipeNode) {\n    try {\n      return this.resolver.resolve(node);\n    } catch ({ message, scope }) {\n      throw { context: 'pipe', message, scope };\n    }\n  }\n\n  private resolveNumber(context: string, node: Scalar) {\n    try {\n      return this.resolver.resolve(node, 'number');\n    } catch ({ message, scope }) {\n      throw { context, message, scope };\n    }\n  }\n\n  iterate = (): DataChunk => {\n    const { n, offset, size } = this;\n    const position = this.computePosition();\n    const color = this.computeColor(position);\n\n    return {\n      n,\n      d: this.d,\n      position,\n      color,\n      offset,\n      size\n    };\n  };\n\n  private computePosition = () => {\n    const { fn, n, d, offset, size } = this;\n    const position = new Float32Array(d * size);\n\n    let i = 0;\n    for (const y of fn.sample(n, offset, offset + size)) {\n      position.set(y, d * i++);\n    }\n\n    return position;\n  };\n\n  private computeColor = (position: Vector) => {\n    const { d, hsv, size } = this;\n    const color = new Float32Array(3 * size);\n    const { extent } = this.scope;\n\n    for (let i = 0; i < size; i++) {\n      const p = position.subarray(i * d, (i + 1) * d);\n      this.scope.p = p.map((pk, k) => {\n        const m = extent[k];\n        return m ? sign(pk) * min(1, abs(pk) / m) : 0;\n      });\n      const h = 360 * this.resolveNumber('h', hsv.h);\n      const s = this.resolveNumber('s', hsv.s);\n      const v = this.resolveNumber('v', hsv.v);\n      const rgb = hsv2rgb(h, s, v);\n\n      color.set(rgb, i * 3);\n    }\n\n    return color;\n  };\n}\n\nfunction hsv2rgb(h: number, s: number, v: number): [number, number, number] {\n  // source: https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB\n  h = Math.max(0, Math.min(360, h));\n  s = Math.max(0, Math.min(1, s));\n  v = Math.max(0, Math.min(1, v));\n\n  const hprime = h / 60;\n  const c = v * s;\n  const x = c * (1 - abs((hprime % 2) - 1));\n  const m = v - c;\n  let rgb: [number, number, number];\n\n  if (hprime <= 1) {\n    rgb = [c, x, 0];\n  } else if (hprime <= 2) {\n    rgb = [x, c, 0];\n  } else if (hprime <= 3) {\n    rgb = [0, c, x];\n  } else if (hprime <= 4) {\n    rgb = [0, x, c];\n  } else if (hprime <= 5) {\n    rgb = [x, 0, c];\n  } else if (hprime <= 6) {\n    rgb = [c, 0, x];\n  } else {\n    rgb = [0, 0, 0];\n  }\n\n  rgb.forEach((vi, i) => (rgb[i] = vi + m));\n\n  return rgb;\n}\n","import { expose } from 'comlink';\n\nimport { Params } from '../params';\nimport { Chunk, DataChunk } from '../types';\nimport { Evaluator } from './evaluator';\n\nconst worker = {\n  iterate: (params: Params, chunk: Chunk): DataChunk => {\n    const evaluator = new Evaluator(\n      params.scope,\n      params.pipe,\n      params.hsv,\n      chunk\n    );\n    return evaluator.iterate();\n  }\n};\n\nexport type PipeWorker = typeof worker;\n\nexpose(worker);\n"]}