{"version":3,"sources":["webpack:///./src/core/pp.ts","webpack:///./src/web/inputs/index.ts","webpack:///./src/core/data.ts","webpack:///./src/core/pipe/pool.ts","webpack:///./src/core/constants.ts","webpack:///./src/core/fn/fn.ts","webpack:///./src/core/fn/interval.ts","webpack:///./src/core/fn/cube.ts","webpack:///./src/core/fn/rotator.ts","webpack:///./src/core/fn/sphere.ts","webpack:///./src/core/fn/spiral.ts","webpack:///./src/core/fn/torus.ts","webpack:///./src/core/fn/fucked_up_torus.ts","webpack:///./src/core/fn/stereo.ts","webpack:///./src/core/fn/identity.ts","webpack:///./src/core/pipe/resolver.ts","webpack:///./src/core/pipe/pipe.worker.ts","webpack:///./src/core/pipe/grammar.pegjs","webpack:///./src/core/pipe/parser.ts","webpack:///./src/core/pipe/compiler.ts","webpack:///./src/core/pipe/evaluator.ts","webpack:///./src/core/pipe/pipe.ts","webpack:///./src/web/renderer.ts"],"names":["pp","a","p","JSON","stringify","temp","persistenceEnabled","URLSearchParams","window","location","search","get","hash","substr","atob","AbstractInput","constructor","id","_value","persistent","this","has","parse","updateHash","BehaviorSubject","newValue","el","_setup","str","value","set","document","btoa","toString","initFromOrWriteToHash","subject","newSubject","Error","asObservable","oldValue","next","event","TextInput","super","onchange","oninput","size","length","stream","subscribe","text","ToggleInput","disabled","on","querySelector","onclick","off","style","display","test","bool","n","poolSize","inputs","pipe","theta","h","v","animate","mic","fullscreen","fullscreenEnabled","allowedDbs","input","multirange","minEl","maxEl","valueLow","valueHigh","innerText","min","max","split","parseInt","save","action","ev","_","canvas","renderer","domElement","render","blob","Promise","resolve","toBlob","url","URL","createObjectURL","createElement","download","href","click","revokeObjectURL","debug","Data","d","position","color","buffer","data","Float32Array","nOffset","positionOffset","d0","SharedArrayBuffer","inputOffset","arr","offset","subarray","inputLength","positionLength","colorOffset","i","stride","assert","pool","logger","getLogger","setLevel","navigator","hardwareConcurrency","startPool","info","Pool","spawn","Worker","name","Map","promises","push","queue","all","initialize","params","timing","forkJoin","chunk","w","iterate","getOrInitialize","key","l","getKey","bufferFor","op","Math","round","label","start","Date","now","t","elapsed","runPipeline","ast","Pipe","compile","resolver","Resolver","scopeFor","staticFn","dynamicFn","slice","inf","cos","sin","exp","tan","tanh","components","Array","from","keys","CompositeFn","fns","limit","first","rest","x","sample","apply","y","domain","equal","domainMax","dMax","last","reduce","f","fn","isFinite","sign","Interval","b","nPerLevel","points","pop","successors","pow","Cube","interval","fill","Rotator","d1","f0","f1","cube","r0","r1","Sphere","r","PI","phi","root","map","Spiral","k","sphere","Torus","cross","rotator","FuckedUpTorus","circle","q","Stereo","to","fromTemp","toTemp","up","down","n2","norm2","divisor","result","Identity","scope","node","extraScope","kind","resolvePipe","resolveFn","resolveAccess","resolveIdToNumber","resolveArith","chain","links","fun","shift","args","link","resolveFirstStep","resolveStep","buildComposites","builder","Builder","isDynamic","add","init","build","type","funs","resolveScalar","some","isNodeDynamic","prev","ranges","arg","resolveId","index","target","idu","toUpperCase","fail","operands","ops","includes","rotate","spiral","torus","fucked_up_torus","stereo","module","exports","peg$SyntaxError","message","expected","found","captureStackTrace","child","parent","ctor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","s","replace","j","descriptions","sort","join","describeExpected","describeFound","SyntaxError","options","peg$result","peg$FAILED","peg$startRuleFunctions","peg$parsepipe","arith","peg$parsearith","peg$startRuleFunction","peg$c0","peg$c1","head","tail","peg$c2","peg$c3","toLowerCase","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$literalExpectation","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","parseFloat","peg$c16","peg$c17","peg$c18","peg$classExpectation","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s3","peg$parseuint","peg$parsepipe_sep","peg$parsechain","peg$parsestep","peg$parseidentifier","peg$parselparen","peg$parsestep_args","peg$parsecomma","peg$parserparen","s2","peg$parsescalar","peg$parse_","substring","peg$parsearith_op","s4","s5","s6","charAt","peg$parsemantissa","peg$parseint","peg$parsefloat","peg$parsenumber","peg$parsefn_args","peg$parse__","setDefaultLevel","loggingParse","expr","err","error","Parser","Compiler","parsePipe","simplifier","simplify","parseArith","simplifyArithNode","Simplifier","substitutions","simplifyStepNode","simplifyScalar","simplifyFnNode","simplifyAccessNode","simplifyIdNode","Evaluator","hv","dynaicFn","iter","computeColors","hsv","hsl","c","Color","g","normalized","compilePipe","evaluatorForNormal","scopeForNormal","compiler","compileHV","power","chroma","onset","compileArith","width","innerWidth","height","innerHeight","aspect","setSize","camera","PerspectiveCamera","z","scene","geometry","forEach","isNaN","console","warn","setAttribute","BufferAttribute","computeBoundingSphere","boundingSphere","center","radius","requestAnimationFrame","WebGLRenderer","onresize","Points","BufferGeometry","PointsMaterial","vertexColors","VertexColors","Scene"],"mappings":"uFAAA,kCAAO,IAAMA,EAAK,SAACC,GAAD,IAASC,EAAT,uDAAa,EAAb,OAAmBC,KAAKC,UAAUH,EAAG,KAAMC,K,sWCa7D,IAGQG,EAFFC,EAAuC,KAD/B,IAAIC,gBAAgBC,OAAOC,SAASC,QACjBC,IAAI,KAC/BC,GACEP,EAAOG,OAAOC,SAASG,KAAKC,OAAO,GAClC,IAAIN,gBAAgBF,EAAOS,KAAKT,GAAQ,KAG1C,MAAeU,EAIpBC,YACaC,EAAoBC,EACZC,GAAqB,KAD7BF,KAC6B,KADTC,SACS,KAArBC,aAAqB,4EASlB,KAClBC,KAAKD,YAAcP,EAAKS,IAAID,KAAKH,IACnCG,KAAKF,OAASE,KAAKE,MAAMV,EAAKD,IAAIS,KAAKH,KAC9BG,KAAKD,YACdC,KAAKG,eAbiC,oBAiB7B,IAAM,IAAIC,IAAgB,CAACC,SAAUL,KAAKF,UAjBb,eAmBjCQ,IACPN,KAAKM,GAAKA,EACVN,KAAKO,WArBmC,oBAgDrB,KACnB,IAAMC,EAAMR,KAAKhB,UAAUgB,KAAKS,OAChCjB,EAAKkB,IAAIV,KAAKH,GAAIW,GAClBG,SAAStB,SAASG,KAAOoB,KAAKpB,EAAKqB,cAlD/B3B,EACFc,KAAKc,wBAELd,KAAKD,YAAa,EAEpBC,KAAKe,QAAUf,KAAKgB,aAoBZd,MAAMM,GACd,MAAM,IAAIS,MAAM,qBAERjC,UAAUyB,GAClB,MAAM,IAAIQ,MAAM,yBAGlB,aACE,OAAOjB,KAAKe,QAAQG,eAGtB,YACE,OAAOlB,KAAKF,OAGd,UAAUO,GACR,IAAMc,EAAWnB,KAAKS,MACtBT,KAAKF,OAASO,EACdL,KAAKe,QAAQK,KAAK,CAACf,WAAUc,WAAUE,MAAOjC,OAAOiC,QACjDrB,KAAKD,YAAYC,KAAKG,cAYvB,MAAMmB,UAAkB3B,EAG7BC,YACaC,EACTC,GAGFyB,MAAM1B,EAAIC,IADV,+DAHWD,KAGX,mBANkB,GAMlB,gBAIiB,KACjBG,KAAKM,GAAGkB,SAAW,IAAMxB,KAAKS,MAAQT,KAAKM,GAAGG,MAC9CT,KAAKM,GAAGmB,QAAU,IAAMzB,KAAKM,GAAGoB,KAAO1B,KAAKM,GAAGG,MAAMkB,OAErD3B,KAAK4B,OAAOC,UAAW,IAAe,IAAf,SAACxB,GAAc,EACpCL,KAAKM,GAAGG,MAAQJ,EAChBL,KAAKM,GAAGoB,KAAOrB,EAASsB,WAIlBzB,MAAMM,GACd,OAAOA,EAGCxB,UAAU8C,GAClB,OAAOA,GAMJ,MAAMC,UAAoBpC,EAC/BC,YACaC,EACTC,GAGF,IAFWkC,EAEX,wDACAT,MAAM1B,EAAIC,IADV,+DAJWD,KAIX,KAFWmC,WAEX,gBAIiB,KACjB,IAAMC,EAAKjC,KAAKM,GAAG4B,cAAgC,OACnDD,EAAGE,QAAU,IAAMnC,KAAKS,OAAQ,EAEhC,IAAM2B,EAAMpC,KAAKM,GAAG4B,cAAgC,QACpDE,EAAID,QAAU,IAAMnC,KAAKS,OAAQ,EAEjCT,KAAK4B,OAAOC,UAAW,IAAe,IAAf,SAACxB,GAAc,EAChCA,GACF4B,EAAGI,MAAMC,QAAU,OACnBF,EAAIC,MAAMC,QAAU,WAEpBL,EAAGI,MAAMC,QAAU,SACnBF,EAAIC,MAAMC,QAAU,YAKhBpC,MAAMM,GACd,GAAI,UAAU+B,KAAK/B,GACjB,OAAO,EACJ,GAAI,WAAW+B,KAAK/B,GACvB,OAAO,EAEP,MAAM,IAAIS,MAAJ,0CAA6CjB,KAAKH,GAAlD,aAAyDW,IAGzDxB,UAAUwD,GAClB,OAAOA,EAAO,IAAM,KAiExB,IAAMC,EAAI,IAAOC,IAEJC,EAAS,CACpBC,KAAM,IAAItB,EACN,OADE,UAECmB,EAFD,0FAINI,MAAO,IAAIvB,EAAU,QAAS,yBAC9BwB,EAAG,IAAIxB,EAAU,IAAK,sBACtByB,EAAG,IAAIzB,EAAU,IAAK,SACtB0B,QAAS,IAAIjB,EAAY,WAAW,GAAM,GAAO,GACjDkB,IAAK,IAAIlB,EAAY,OAAO,GAAO,GAAO,GAC1CmB,WAAY,IAAInB,EACZ,cACA,GACCpB,SAASwC,mBACV,GAEJC,WAAY,IA7EP,cAAyBzD,EAC9BC,YACaC,EACTC,GAGF,IAFWkC,EAEX,wDACAT,MAAM1B,EAAIC,IADV,+DAJWD,KAIX,KAFWmC,WAEX,gBAIiB,KACjB,IAAMqB,EAAQrD,KAAKM,GAAG4B,cAA0C,SAChEoB,IAAWD,GACX,IAAME,EAAQvD,KAAKM,GAAG4B,cAA2B,QAC3CsB,EAAQxD,KAAKM,GAAG4B,cAA2B,QAEjDmB,EAAM7B,SAAW,KACfxB,KAAKS,MAAQ,EAAE4C,EAAMI,UAAWJ,EAAMK,YAGxC1D,KAAKM,GAAG4B,cAAgC,eAAeT,QACnD4B,EAAM5B,QAAU,KACd8B,EAAMI,UAAYN,EAAMI,SAAS5C,WACjC2C,EAAMG,UAAYN,EAAMK,UAAU7C,YAGxCb,KAAK4B,OAAOC,UAAW,IAAe,IAAf,SAACxB,GAAc,EACpCgD,EAAM5C,MAAQT,KAAKhB,UAAUqB,GAC7BkD,EAAMI,UAAYN,EAAMI,SAAS5C,WACjC2C,EAAMG,UAAYN,EAAMK,UAAU7C,eAI5BX,MAAMM,GACd,IAAOoD,EAAKC,GAAOrD,EAAIsD,MAAM,KAC7B,MAAO,CAACC,SAASH,GAAMG,SAASF,IAGxB7E,UAAV,GAAgC,IAAX4E,EAAKC,GAAM,EAC9B,gBAAUD,EAAV,YAAiBC,KAsCQ,mBAAoB,EAAE,KAAM,KACvDG,KAAM,IAnCD,cAA0BrE,EAC/BC,YACIC,EACiBoE,GAEnB,IADWjC,EACX,wDACAT,MAAM1B,EAAI,MAAM,GADhB,KAFmBoE,SAEnB,KADWjC,WACX,gBAIiB,KACjBhC,KAAKM,GAAG6B,QAAW+B,GAAOlE,KAAKiE,OAAOC,EAAIlE,KAAKM,QA0B7C,OADE,e,EAAA,G,EAEF,UAAO6D,EAAG7D,GACR,IAAM8D,EAASC,WAASC,WACxBD,WAASE,SACT,IAAMC,QAAa,IAAIC,QAAQC,GAAWN,EAAOO,OAAOD,IAClDE,EAAMC,IAAIC,gBAAgBN,GAChC,IACE,IAAM3F,EAAI8B,SAASoE,cAAc,KACjClG,EAAEmG,SAAF,gBAAsBrE,SAAStB,SAASG,MACxCX,EAAEoG,KAAOL,EACT/F,EAAEqG,QAJJ,QAMEL,IAAIM,gBAAgBP,K,+KAbtB,0DAmBRQ,YAAM,SAAUzC,I,+MC5PT,MAAM0C,EACTzF,YACa6C,EACA6C,EACAC,EACAC,GACX,KAJW/C,IAIX,KAHW6C,IAGX,KAFWC,WAEX,KADWC,S,EALJH,E,aAQYI,IACjB,IAAMC,EAAO,IAAIC,aAAaF,GACxBhD,EAAIiD,EAAKL,EAAKO,SACdN,EAAII,EAAKL,EAAKQ,eAAeH,IAC7BH,EAAWF,EAAKE,SAASG,GACzBF,EAAQH,EAAKG,MAAME,GACzB,OAAO,IAAIL,EAAK5C,EAAG6C,EAAGC,EAAUC,K,EAd3BH,E,YAiBU,CAAC5C,EAAWqD,EAAYR,KACvC,IAGMG,EAAS,IAAIM,kBAHC,GACN,EAAItD,GAAKqD,EAAKR,EAAI,KAG1BI,EAAO,IAAIC,aAAaF,GAI9B,OAHAC,EAAKL,EAAKO,SAAWnD,EACrBiD,EAAKL,EAAKW,aAAeF,EACzBJ,EAAKL,EAAKQ,eAAeH,IAASJ,EAC3BG,I,EA1BFJ,E,QA6BOY,IACZ,IAAMC,EAASb,EAAKW,YAAc,EAClC,OAAOC,EAAIE,SAASD,EAAQA,EAASb,EAAKe,YAAYH,M,EA/BjDZ,E,WAkCUY,IACf,IAAMC,EAASb,EAAKQ,eAAeI,GAAO,EAC1C,OAAOA,EAAIE,SAASD,EAAQA,EAASb,EAAKgB,eAAeJ,M,EApCpDZ,E,QAuCOY,IACZ,IAAMC,EAASb,EAAKiB,YAAYL,GAChC,OAAOA,EAAIE,SAASD,K,EAzCfb,E,UA4CQ,G,EA5CRA,E,cA8CYA,EAAKO,QAAU,G,EA9C3BP,E,cA+CqBY,IAG1B,OAFUA,EAAIZ,EAAKO,SACRK,EAAIZ,EAAKW,e,EAjDfX,E,iBAqDgBY,GACrBZ,EAAKW,YAAcX,EAAKe,YAAYH,GAAO,G,EAtDtCZ,E,iBAuDwBY,IAG7B,OAFUA,EAAIZ,EAAKO,SACTK,EAAIZ,EAAKQ,eAAeI,M,EAzD7BZ,E,cA6DaY,GAClBZ,EAAKQ,eAAeI,GAAOZ,EAAKgB,eAAeJ,GAAO,G,EA9DjDZ,E,MAgEI,CAACY,EAAaM,EAAWC,KAClC,IAAMN,EAASK,EAAIC,EACnB,OAAOP,EAAIE,SAASD,EAAQA,EAASM,K,EAlEhCnB,E,MAqEI,CAACY,EAAaxF,EAA0B8F,EAAWC,KAC5DC,IAAOhG,EAAMkB,QAAU6E,GACvB,IAAMN,EAASK,EAAIC,EACnB,OAAOP,EAAIvF,IAAID,EAAOyF,M,0fCrE9B,IACIQ,EACAhB,EAFEiB,EAASC,oBAAU,gBAGzBD,EAAOE,SAAS,QAET,IAAMnE,EAAW,EAAIoE,UAAUC,oBAEzBC,EAAS,oBAAG,YACrBL,EAAOM,KAAK,wBACZ,IAAIV,EAAI,EACRG,EAAOQ,eAAK,IAAMC,gBAAM,IAAIC,SAAO,EAAiB,CAAEC,KAAM,OAAF,OAASd,QAAW7D,GAC9EgD,EAAO,IAAI4B,IAEX,IADA,IAAIC,EAAW,GACNhB,EAAI,EAAGA,EAAI7D,EAAU6D,IAE1BgB,EAASC,KAAKd,EAAKe,MAAL,GAAW,wBAEvBhD,QAAQiD,IAAIH,MAVA,qDAwBhBI,EAAa,CAACC,EAAgBnF,EAAWgD,IACpCoC,EAAO,iBAAPA,CAAA,GAAyB,YAC5B,OAAOC,EAASrF,EAAD,oBAAI,UAAOsF,GACtB,OAAOrB,EAAKe,MAAMO,GAAKA,EAAEL,WAAWC,EAAQG,EAAOtC,OADxC,2DAMjBwC,EAAU,CAACL,EAAgBnF,EAAWgD,IACjCoC,EAAO,YAAPA,CAAA,GAAoB,YACvB,OAAOC,EAASrF,EAAD,oBAAI,UAAOsF,GACtB,OAAOrB,EAAKe,MAAMO,GAAKA,EAAEC,QAAQL,EAAQG,EAAOtC,OADrC,2DAajByC,EAAe,oBAAG,UAAON,EAAgBnF,EAAWqD,EAAYR,GAClE,IAAM6C,EARMP,IAAmB7I,KAAKC,UAAU,CAC9C4D,KAAMgF,EAAOhF,KACbC,MAAO+E,EAAO/E,MACdC,EAAG8E,EAAO9E,EACVsF,EAAGR,EAAO7E,IAIEsF,CAAOT,GACnB,IAAKlC,EAAKzF,IAAIkI,GAAM,CAChB,IAAM1C,EAASJ,IAAKiD,UAAU7F,EAAGqD,EAAIR,SAC/BqC,EAAWC,EAAQnF,EAAGgD,GAC5BC,EAAKhF,IAAIyH,EAAK1C,GAElB,OAAOC,EAAKnG,IAAI4I,MAPC,4DAUfL,EAAQ,oBAAG,UAAOrF,EAAW8F,GAG/B,IAFA,IAAM7G,EAAO8G,KAAKC,MAAMhG,EAAIC,GACxB6E,EAAW,GACNrB,EAAS,EAAGA,EAASzD,EAAGyD,GAAUxE,EAAM,CAC7C,IAAMqG,EAAQ,CAAE7B,SAAQxE,KAAM8G,KAAK5E,IAAInB,EAAIyD,EAAQxE,IACnD6F,EAASC,KAAKe,EAAGR,UAEftD,QAAQiD,IAAIH,MAPR,wDAURM,EAAUa,IAAD,oBAAmB,UAASH,GACvC,IAAMI,EAAQC,KAAKC,MACbC,QAAUP,IACVQ,EAAUH,KAAKC,MAAQF,EAE7B,OADAhC,EAAOvB,MAAP,UAAgBsD,EAAhB,iBAA8BK,EAA9B,OACOD,KALI,uDAQFE,EAAW,oBAAG,UAAOpB,GAC9B,IAAMqB,EAAMC,IAAKC,QAAQvB,GACnBwB,EAAW,IAAIC,IAASH,IAAKI,SAAS1B,EAAQqB,EAAIxG,KAClD,EAAEA,EAAF,SAAK8G,EAAL,UAAeC,GAAcJ,EAAS1E,QAAQuE,GAC9CxD,QAAeyC,EAAgBN,EAAQnF,EAAG8G,EAASjE,EAAGkE,EAAUlE,GAGtE,aAFM2C,EAAQL,EAAQnF,EAAGgD,GAElBA,EAAOgE,MAAM,MAPA,wD,kDCzFxB,kCAAO,IAAMC,EAAM,GAAK,GAAK,G,6LCItB,IAAMC,EAAMnB,KAAKmB,IACXC,EAAMpB,KAAKoB,IAGXC,GAFMrB,KAAKsB,IACJtB,KAAKuB,KACNvB,KAAKqB,KAEXG,EAAc1E,GAAM2E,MAAMC,KAAK,IAAID,MAAM3E,GAAG6E,QASlD,MAAMC,EAGXxK,YAAqByK,GAAW,gBAAXA,MAAW,uDAiCvB,UAAW5H,EAAWyD,EAAgBoE,GAC7C,IAAM,IAAED,EAAF,EAAO/E,GAAMtF,MACZuK,KAAUC,GAAQH,EACzB,GAAkB,GAAdA,EAAI1I,OAAa,MAAO,GAE5B,IAAK,IAAM8I,KAAKF,EAAMG,OAAOjI,EAAGyD,EAAQoE,GACtCtK,KAAKyK,EAAE/J,IAAI+J,GACPD,EAAK7I,OACPyI,EAAYO,MAAMH,EAAMxK,KAAKyK,EAAGzK,KAAK4K,GAErC5K,KAAK4K,EAAElK,IAAI+J,SAEPzK,KAAK4K,EAAEzE,SAAS,EAAGb,MA7CG,aAiD3B,SAACmF,GAAoD,IAAzCG,EAAyC,uDAA7B,IAAIjF,aAAa,EAAKL,IAC3C,IAAE+E,EAAF,OAAOQ,EAAP,EAAevF,GAAM,EAO3B,OANAmB,IAAOqE,MAAML,EAAE9I,OAAQkJ,GACvBpE,IAAOqE,MAAMF,EAAEjJ,OAAQ2D,GAEvB,EAAKmF,EAAE/J,IAAI+J,GACXL,EAAYO,MAAMN,EAAK,EAAKI,EAAG,EAAKG,GACpCA,EAAElK,IAAI,EAAKkK,EAAEzE,SAAS,EAAGb,IAClBsF,KAxDPnE,IAAO4D,EAAI1I,OAAQ,uBAEnB,IAAMA,EAAS6G,KAAK3E,IAAI7D,KAAK+K,UAAW/K,KAAKgL,MAC7ChL,KAAKyK,EAAI,IAAI9E,aAAahE,GAC1B3B,KAAK4K,EAAI,IAAIjF,aAAahE,GAI5B,YACE,OAAO3B,KAAKqK,IAAI,GAGlB,WACE,OAAOrK,KAAKqK,IAAIrK,KAAKqK,IAAI1I,OAAS,GAGpC,aACE,OAAO3B,KAAKuK,MAAMM,OAGpB,QACE,OAAO7K,KAAKiL,KAAK3F,EAGnB,gBACE,OAAOtF,KAAKqK,IAAIa,OAAO,CAACrH,EAAKsH,IAAM3C,KAAK3E,IAAIsH,EAAEN,OAAQhH,GAAM,GAG9D,WACE,OAAO7D,KAAKqK,IAAIa,OAAO,CAACrH,EAAKsH,IAAM3C,KAAK3E,IAAIsH,EAAE7F,EAAGzB,GAAM,I,0HAjC9CuG,E,QA+DY,CAACC,EAAWI,EAAWG,KAE5C,IAAK,IAAMO,KADX1E,IAAOqE,MAAML,EAAE9I,OAAQiJ,EAAEjJ,QACT0I,GACdc,EAAEC,GAAGX,EAAEtE,SAAS,EAAGgF,EAAEN,QAASD,EAAEzE,SAAS,EAAGgF,EAAE7F,IAC9CmF,EAAE/J,IAAIkK,GAER,IAAK,IAAIrE,EAAI,EAAGA,EAAIqE,EAAEjJ,OAAQ4E,IACvB8E,SAAST,EAAErE,MAAKqE,EAAErE,GAAKiC,KAAK8C,KAAKV,EAAErE,IAAMmD,O,EAtEvCU,E,UA0EM,MAAM,2BACQ,IADR,aAWdgB,IACL,IAAM,IAAEf,EAAF,KAAOY,GAASjL,KACtB,GAAIiL,GAAQG,EAAGP,SAAWI,EAAK3F,EAC7B,MAAM,IAAIrE,MAAJ,qBACUmK,EADV,oDACwDH,EAAK3F,IAIrE,OADA+E,EAAI7C,KAAK4D,GACFpL,OAnBY,eAsBb,IACC,IAAIoK,EAAYpK,KAAKqK,MApB9B,QACE,OAAOrK,KAAKiL,KAAK3F,EAGnB,WACE,OAAOtF,KAAKqK,IAAIrK,KAAKqK,IAAI1I,OAAS,MCjGzB,MAAM4J,EAGnB3L,YAAqB0F,EAAoBzG,EAAsB2M,GAAa,gBAAvDlG,IAAuD,KAAnCzG,IAAmC,KAAb2M,IAAa,qCAgBvE,SAACf,GAA0D,IAAzCG,EAAyC,uDAA7B,IAAIjF,aAAa,EAAKL,IACjD,EAAEzG,EAAF,EAAK2M,EAAL,EAAQlG,GAAM,EACpBmB,IAAOqE,MAAML,EAAE9I,OAAQ2D,GACvBmB,IAAOqE,MAAMF,EAAEjJ,OAAQ2D,GACvB,IAAK,IAAIiB,EAAI,EAAGA,EAAIjB,EAAGiB,IACrBqE,EAAErE,GAAK1H,EAAE0H,GAAKkE,EAAElE,IAAMiF,EAAEjF,GAAK1H,EAAE0H,IAEjC,OAAOqE,KAvBmE,iBA0BnE,UAAWnI,EAAWyD,EAAgBoE,GAC7C,IAAM,EAAEhF,EAAF,GAAK8F,GAAOpL,KAClByC,EAAI8I,EAASE,UAAUnG,EAAG7C,GAI1B,IAHA,IAAMiJ,EAAqB,CAAC,IACxBnF,EAAI,EAEDmF,EAAO/J,QAAU4E,EAAI+D,GAAO,CACjC,IAAMxL,EAAI4M,EAAOC,MACb7M,EAAE6C,OAAS2D,EACboG,EAAOlE,QAAQoE,EAAW9M,IACjByH,KAAOL,UACVkF,EAAGtM,IAIb,SAAU8M,EAAW9M,GACnB,IAAK,IAAIyH,EAAI,EAAGA,EAAI9D,EAAG8D,SACf,IAAIzH,EAAGyH,EAAI9D,OA1CrBgE,IAAOqE,MAAMjM,EAAE8C,OAAQ2D,GACvBmB,IAAOqE,MAAMU,EAAE7J,OAAQ2D,GACvBtF,KAAK6K,OAASvF,G,0HANGiG,E,YASA,CAACjG,EAAW7C,IACtB+F,KAAKC,MAAMD,KAAKqD,IAAIpJ,EAAG,EAAI6C,K,EAVjBiG,E,IAaR,CAACjG,EAAW7C,IAAc8I,EAASE,UAAUnG,EAAG7C,IAAM6C,GCbpD,MAAMwG,EAGnBlM,YAAqB0F,EAAoB8C,GAAW,KAA/B9C,IAA+B,KAAX8C,IAAW,sCAY/C,CAACqC,EAAWG,IAAe5K,KAAK+L,SAASX,GAAGX,EAAGG,IAZA,gBAc3C,CAACnI,EAAWyD,EAAgBoE,IACnCtK,KAAK+L,SAASrB,OAAOjI,EAAGyD,EAAQoE,IAdhCtK,KAAK+L,SAAW,IAAIR,EAClBjG,EACA,IAAI2E,MAAM3E,GAAG0G,MAAM5D,EAAI,GACvB,IAAI6B,MAAM3E,GAAG0G,KAAK5D,EAAI,IAI1B,aACE,OAAOpI,KAAKsF,G,wHCXD,MAAM2G,EAInBrM,YACW0F,EACAzC,EACAiD,EACAoG,GAGT,WAFSC,EAET,uDAFyCxC,EAChCyC,EACT,uDADyCxC,EACzC,KANStE,IAMT,KALSzC,QAKT,KAJSiD,KAIT,KAHSoG,KAGT,KAFSC,KAET,KADSC,KACT,yDASO,UAAW3J,EAAWyD,EAAgBoE,GAC7C,IAAM+B,EAAO,IAAIP,EAAK9L,KAAK6K,OAAQ,GACnC,IAAK,IAAM/L,KAAKuN,EAAK3B,OAAOjI,EAAGyD,EAAQoE,SAC/BtK,KAAKoL,GAAGtM,MAZhB,aAgBG,SAAC2L,GAAoD,IAAzCG,EAAyC,uDAA7B,IAAIjF,aAAa,EAAKL,IAC3C,EAAEA,EAAF,GAAKQ,EAAL,GAASoG,EAAT,GAAaI,EAAb,GAAiBC,GAAO,EAC9B9F,IAAOqE,MAAML,EAAE9I,OAAQ2D,GACvBmB,IAAOqE,MAAMF,EAAEjJ,OAAQ2D,GACvBsF,EAAElK,IAAI+J,GAEN,IAAM5L,EAAI4L,EAAE3E,GAAK0F,EAAIf,EAAEyB,GAGvB,OAFAtB,EAAE9E,GAAMjH,EAAIyN,EAAKd,EAAIe,EACrB3B,EAAEsB,GAAMrN,EAAI0N,EAAKf,EAAIc,EACd1B,KAxBP5K,KAAKsM,GAAKH,EAAGtJ,GACb7C,KAAKuM,GAAKH,EAAGvJ,GAGf,aACE,OAAO7C,KAAKsF,G,wHCfD,MAAMkH,EAGnB5M,YAAqB0F,EAAWmH,GAAW,gBAAtBnH,IAAsB,uCASlC,UAAW7C,EAAWyD,EAAgBoE,GAC7C,IAAM+B,EAAO,IAAIP,EAAK9L,KAAK6K,OAAQ,EAAIrC,KAAKkE,IAC5C,IAAK,IAAMC,KAAON,EAAK3B,OAAOjI,EAAGyD,EAAQoE,SACjCtK,KAAKoL,GAAGuB,MAZyB,aAgBtC,SAACA,GAAsD,IAAzC/B,EAAyC,uDAA7B,IAAIjF,aAAa,EAAKL,IAC7C,EAAEA,EAAF,KAAKsH,GAAS,EACpBnG,IAAOqE,MAAM6B,EAAIhL,OAAQ2D,EAAI,GAC7BmB,IAAOqE,MAAMF,EAAEjJ,OAAQ2D,GAEvB,IAAMmH,EAAI,IAAIrC,EAAYJ,EAAW1E,EAAI,GAAGuH,IAAKtG,GAAM,IAAI0F,EAAQ3G,EAAGqH,EAAIpG,GAAI,EAAGA,EAAI,KAErF,OADAkG,EAAErB,GAAGwB,EAAMhC,GACJA,KAtBP5K,KAAK4M,KAAO,IAAIjH,aAAaL,GAC7BtF,KAAK4M,KAAK,GAAKH,EAGjB,aACE,OAAOzM,KAAKsF,EAAI,G,wHCVL,MAAMwH,EAGnBlN,YAAqB0F,EAAoBzG,EAAsBkO,GAAa,gBAAvDzH,IAAuD,KAAnCzG,IAAmC,KAAbkO,IAAa,yCAQnE,UAAWtK,EAAWyD,EAAgBoE,GAC7C,IAAM+B,EAAO,IAAIP,EAAK9L,KAAK6K,OAAQ,EAAIrC,KAAKkE,IAC5C,IAAK,IAAMC,KAAON,EAAK3B,OAAOjI,EAAGyD,EAAQoE,SACjCtK,KAAKoL,GAAGuB,MAX0D,aAevE,SAACA,GAA4D,IAAzC/B,EAAyC,uDAA7B,IAAIjF,aAAa,EAAKL,IACnD,EAAEzG,EAAF,EAAKkO,EAAL,OAAQlC,EAAR,EAAgBvF,GAAM,EAC5BmB,IAAOqE,MAAM6B,EAAIhL,OAAQ2D,EAAI,GAC7BmB,IAAOqE,MAAMF,EAAEjJ,OAAQ2D,GAEvB,EAAK0H,OAAO5B,GAAGuB,EAAK/B,GAEpB,IADA,IAAIH,EAAI,EACClE,EAAI,EAAGA,EAAIsE,EAAQtE,IAC1BkE,GAAKsC,EAAExG,GAAKoG,EAAIpG,GAGlB,IADA,IAAMkG,EAAI5C,EAAIY,GACLlE,EAAI,EAAGA,EAAIjB,EAAGiB,IACrBqE,EAAErE,GAAKqE,EAAErE,GAAK1H,EAAE0H,GAAKkG,EAEvB,OAAO7B,KA5BP5K,KAAKgN,OAAS,IAAIR,EAAOlH,EAAG,GAG9B,aACE,OAAOtF,KAAKsF,EAAI,G,wHCPL,MAAM2H,EAGnBrN,YAAqB0F,EAAoBmH,EAAoB3D,GAAW,gBAAnDxD,IAAmD,KAA/BmH,IAA+B,KAAX3D,IAAW,wCAS/D,UAAWrG,EAAWyD,EAAgBoE,GAC7C,IAAM+B,EAAO,IAAIP,EAAK9L,KAAK6K,OAAQ,EAAIrC,KAAKkE,IAC5C,IAAK,IAAMC,KAAON,EAAK3B,OAAOjI,EAAGyD,EAAQoE,SACjCtK,KAAKoL,GAAGuB,MAZsD,aAgBnE,SAAC9J,GAAwD,IAAzC+H,EAAyC,uDAA7B,IAAIjF,aAAa,EAAKL,IAC/C,MAAE4H,EAAF,EAAS5H,EAAT,EAAYmH,GAAM,EACxBhG,IAAOqE,MAAMjI,EAAMlB,OAAQ2D,EAAI,EAA/B,oCAA+DA,EAAI,EAAnE,iBAA6EzC,EAAMlB,SACnF,IAAMwL,EAAU,IAAIlB,EAAQ3G,EAAGzC,EAAMyC,EAAI,GAAI,EAAGA,EAAI,GAMpD,OAJA4H,EAAM9B,GAAGvI,EAAMsD,SAAS,EAAGb,EAAI,GAAIsF,EAAEzE,SAAS,EAAGb,EAAI,IACrDsF,EAAE,IAAM6B,EACRU,EAAQ/B,GAAGR,EAAGA,GAEPA,KAxBPnE,IAAOnB,EAAI,EAAL,+CAAgDA,IACtDtF,KAAKkN,MAAQ,IAAIV,EAAOlH,EAAI,EAAGwD,GAGjC,aACE,OAAO9I,KAAKsF,EAAI,G,wHCLL,MAAM8H,EAIjBxN,YAAqB0F,EAAoBmH,EAAoB3D,GAAW,gBAAnDxD,IAAmD,KAA/BmH,IAA+B,KAAX3D,IAAW,iEAS/D,UAAWrG,EAAWyD,EAAgBoE,GAC3C,IAAM+B,EAAO,IAAIP,EAAK9L,KAAK6K,OAAQ,EAAIrC,KAAKkE,IAC5C,IAAK,IAAMC,KAAON,EAAK3B,OAAOjI,EAAGyD,EAAQoE,SAC/BtK,KAAKoL,GAAGuB,MAZkD,aAgBnE,SAACA,GAAsD,IAAzC/B,EAAyC,uDAA7B,IAAIjF,aAAa,EAAKL,IAC3C,OAAEuF,EAAF,EAAUvF,EAAV,OAAa0H,EAAb,OAAqBK,GAAW,EACtC5G,IAAOqE,MAAM6B,EAAIhL,OAAQkJ,GACzBpE,IAAOqE,MAAMF,EAAEjJ,OAAQ2D,GACvB0H,EAAO5B,GAAGuB,EAAK/B,GACf,IAAM0C,EAAID,EAAOjC,GAAGuB,EAAIxG,SAASb,EAAI,IAGrC,OAFAsF,EAAE,IAAM0C,EAAE,GACV1C,EAAEtF,EAAI,IAAMgI,EAAE,GACP1C,KAvBP5K,KAAKgN,OAAS,IAAIR,EAAOlH,EAAGwD,GAC5B9I,KAAKqN,OAAS,IAAIb,EAAO,EAAGC,GAGhC,aACI,OAAOzM,KAAKsF,EAAI,G,wHChBT,MAAMiI,EAInB3N,YAA6BsK,EAA+BsD,GAAY,gBAA3CtD,OAA2C,KAAZsD,KAAY,mEAa/D,UAAW/K,EAAWyD,EAAgBoE,GAC7C,IAAM+B,EAAO,IAAIP,EAAK9L,KAAK6K,OAAQ,GACnC,IAAK,IAAM8B,KAAON,EAAK3B,OAAOjI,EAAGyD,EAAQoE,SACjCtK,KAAKoL,GAAGuB,MAhBsD,aAoBnE,SAAClC,GAAqD,IAA1CG,EAA0C,uDAA9B,IAAIjF,aAAa,EAAK6H,KAC7C,KAAEtD,EAAF,GAAQsD,EAAR,SAAYC,EAAZ,OAAsBC,GAAW,EAIrC,GAHAjH,IAAOqE,MAAML,EAAE9I,OAAQuI,GACvBzD,IAAOqE,MAAMF,EAAEjJ,OAAQ6L,GAEnBtD,IAASsD,EAEX,OADA5C,EAAElK,IAAI+J,GACCG,EAKT,IAFA6C,EAAS/M,IAAI+J,GAENP,EAAOsD,GACZD,EAAOI,GACLF,EAAStH,SAAS,EAAG+D,GACrBwD,EAAOvH,SAAS,IAAK+D,IAEvBuD,EAAS/M,IAAIgN,GAGf,KAAOxD,EAAOsD,GACZD,EAAOK,KACLH,EAAStH,SAAS,EAAG+D,GACrBwD,EAAOvH,SAAS,IAAK+D,IAEvBuD,EAAS/M,IAAIgN,GAIf,OADA9C,EAAElK,IAAIgN,EAAOvH,SAAS,EAAGqH,IAClB5C,KAhDP5K,KAAKyN,SAAW,IAAI9H,aAAa6C,KAAK3E,IAAIqG,EAAMsD,IAChDxN,KAAK0N,OAAS,IAAI/H,aAAa6C,KAAK3E,IAAIqG,EAAMsD,IAGhD,aACE,OAAOxN,KAAKkK,KAGd,QACE,OAAOlK,KAAKwN,I,EAdKD,E,KAwDP,CAAC9C,EAAWxL,KACtBwH,IAAOqE,MAAM7L,EAAK0C,OAAQ8I,EAAE9I,OAAS,GACrC,IAAMkM,EAAKC,EAAMrD,GACXsD,EAAUF,EAAK,EACrB5O,EAAK,IAAM4O,EAAK,GAAKE,EACrB,IAAK,IAAIxH,EAAI,EAAGA,GAAKkE,EAAE9I,OAAQ4E,IAC7BtH,EAAKsH,GAAM,EAAIkE,EAAElE,EAAI,GAAMwH,I,EA9DZR,E,OAkEL,CAAC9C,EAAWxL,KACxBwH,IAAOqE,MAAM7L,EAAK0C,OAAQ8I,EAAE9I,OAAS,GACrC,IAAK,IAAI4E,EAAI,EAAGA,EAAItH,EAAK0C,OAAQ4E,IAC/BtH,EAAKsH,GAAKkE,EAAElE,EAAI,IAAM,EAAIkE,EAAE,MAKlC,IAAMqD,EAASrD,IAEb,IADA,IAAIuD,EAAS,EACJzH,EAAI,EAAGA,EAAIkE,EAAE9I,OAAQ4E,IAC5ByH,GAAUvD,EAAElE,GAAKkE,EAAElE,GAErB,OAAOyH,G,wHC/EF,MAAMC,EAGTrO,YAAqB0F,GAAW,gBAAXA,IAAW,qCAI3B,SAACmF,GAAoD,IAAzCG,EAAyC,uDAA7B,IAAIjF,aAAa,EAAKL,IACzC,EAAEA,GAAM,EAId,OAHAmB,IAAOqE,MAAML,EAAE9I,OAAQ2D,GACvBmB,IAAOqE,MAAMF,EAAEjJ,OAAQ2D,GACvBsF,EAAElK,IAAI+J,GACCG,KATqB,iBAYvB,UAAWnI,EAAWyD,EAAgBoE,GAC3C,MAAM,IAAIrJ,MAAM,kDAZhBjB,KAAK6K,OAASvF,G,ytBCYf,MAAM+D,EACTzJ,YAA6BsO,GAAc,gBAAdA,QAAc,kBAEjC,SAACC,GAAqD,IAA5BC,EAA4B,uDAAP,GACrD,OAAQD,EAAKE,MACT,IAAK,OAAQ,OAAO,EAAKC,YAAYH,GACrC,IAAK,SAAU,OAAOA,EAAK1N,MAC3B,IAAK,KAAM,OAAO,EAAK8N,UAAUJ,EAAMC,GACvC,IAAK,SAAU,OAAO,EAAKI,cAAcL,EAAMC,GAC/C,IAAK,KAAM,OAAO,EAAKK,kBAAkBN,EAAKtO,GAAIuO,GAClD,IAAK,QAAS,OAAO,EAAKM,aAAaP,EAAMC,OATV,qBAa5BxL,IACX,IAAM+L,EAAQ/L,EAAK+L,MACbC,EAAgB,GAChBC,EAAMF,EAAMG,QACZxJ,EAAKuJ,EAAIE,KAAKD,QAAuBrO,MACrCuO,EAAOhP,KAAKiP,iBAAiB3J,EAAGuJ,GAChCpM,EAAI8I,EAAS9I,EAAEuM,EAAK5D,GAAGP,OAAQjI,EAAKH,GAE1CmM,EAAMpH,KAAKwH,GAEX,IAAK,IAAIzI,EAAI,EAAGA,EAAIoI,EAAMhN,OAAQ4E,IAAK,CACnC,IAAMsI,EAAMF,EAAMpI,GACZyI,EAAOhP,KAAKkP,YAAYN,EAAMrI,GAAG6E,GAAIyD,GAC3CD,EAAMpH,KAAKwH,GAGf,IAAOzF,EAAUC,GAAaxJ,KAAKmP,gBAAgBP,GACnD,MAAO,CAAEnM,IAAG8G,WAAUC,eA9BiB,yBAiChBoF,IAEvB,IADA,IAAIQ,EAAU,IAAIhF,EAAYiF,QACvBT,EAAMjN,SAAWiN,EAAM,GAAGU,WAC7BF,EAAQG,IAAIX,EAAME,QAAQ1D,IAG9B,IAAMoE,EAAOJ,EAAQK,QAGrB,IAFAL,GAAU,IAAIhF,EAAYiF,SAAUE,IAAI,IAAItB,EAASuB,EAAKlK,IAEnDsJ,EAAMjN,QACTyN,EAAQG,IAAIX,EAAME,QAAQ1D,IAI9B,MAAO,CAACoE,EADKJ,EAAQK,WA9CkB,0BAkDhB,CAACnK,EAAD,KAAyC,IAA7B,KAAEoK,EAAF,KAAQX,GAAqB,EAIhE,MAAO,CAAE3D,GAHEuE,EAAKD,GAAMpK,KAAMyJ,EAAKlC,IAAIhO,GAAKmB,KAAK4P,cAAc/Q,KAGhDyQ,UAFKP,EAAKc,KAAKC,MApDW,qBAyDrB,CAACC,EAAD,KAA8C,IAAnC,KAAEL,EAAF,KAAQX,GAA2B,EAC1DzJ,EAAI0K,EAAON,GAAMK,EAAKzK,GAI5B,MAAO,CAAE8F,GAHEuE,EAAKD,GAAMpK,KAAMyJ,EAAKlC,IAAIhO,GAAKmB,KAAK4P,cAAc/Q,KAGhDyQ,UAFKP,EAAKc,KAAKC,MA5DW,wBAiEnB,SAACG,GAAgD,IAAnC7B,EAAmC,uDAAd,GACvD,OAAQ6B,EAAI5B,MACR,IAAK,SAAU,OAAO4B,EAAIxP,MAC1B,IAAK,KAAM,OAAO,EAAK8N,UAAU0B,EAAK7B,GACtC,IAAK,SAAU,OAAO,EAAKI,cAAcyB,EAAK7B,GAC9C,IAAK,KAAM,OAAO,EAAK8B,UAAUD,EAAIpQ,GAAIuO,GACzC,IAAK,QAAS,OAAO,EAAKM,aAAauB,EAAK7B,OAvET,mBA2EvB,CAAC,EAAwBA,KAA+B,IAAvD,KAAE/G,EAAF,KAAQ0H,GAA+C,EAClE3D,EAAK5C,KAAKnB,GAEhB,OADAZ,IAAqB,mBAAP2E,EAAR,mBAAuC/D,EAAvC,qCAAwEzI,YAAG,CAAEyI,OAAM0H,WAClF3D,KAAM2D,EAAKlC,IAAIhO,GAAKmB,KAAK4P,cAAc/Q,EAAGuP,OA9EV,uBAiFnB,CAAC,EAA2BA,KAA+B,IAA1D,GAAEvO,EAAF,MAAMsQ,GAAoD,EACzEjC,EAAQ,EAAH,GAAQlO,KAAKkO,MAAb,GAAuBE,GAC5BgC,EAASlC,EAAMrO,GAErB,OADA4G,IAAO2J,EAAD,4BAA8BvQ,EAA9B,qBAA6CjB,YAAGsP,EAAO,KACtDkC,EAAOpQ,KAAK4P,cAAcO,EAAO/B,MArFD,mBAwFvB,CAACvO,EAAYuO,IACzBvO,KAAM2I,MAA4B,mBAAbA,KAAK3I,GACnB2I,KAAK3I,GAELG,KAAKyO,kBAAkB5O,EAAIuO,IA5FC,2BAgGf,CAACvO,EAAYuO,KACrC,IAAMiC,EAAMxQ,EAAGyQ,cACf,OAAIzQ,KAAMuO,EACCA,EAAWvO,GACXA,KAAMG,KAAKkO,MACXlO,KAAKkO,MAAMrO,GACXwQ,KAAO7H,MAA6B,iBAAdA,KAAK6H,GAC3B7H,KAAK6H,QAEZ5J,IAAO8J,KAAP,+BAAoC1Q,EAApC,qBAAmDjB,YAAG,EAAD,GAAMoB,KAAKkO,MAAX,GAAqBE,GAAc,OAzGrD,sBA6GpB,CAAC,EAA6BA,KAAuB,IAApD,GAAE7F,EAAF,SAAMiI,GAA8C,GACjE3R,EAAG2M,GAAKgF,EAAS3D,IAAIhO,GAAKmB,KAAK4P,cAAc/Q,EAAGuP,IACvD,GAAiB,iBAANvP,GAA+B,iBAAN2M,EAChC,OAAOiF,EAAIlI,GAAI1J,EAAG2M,GAEtB/E,IAAO8J,KAAP,sEAA2E3R,YAAG,CAAE2J,KAAIiI,YAAY,QAKxG,IAAMV,EAAiB3B,IACnB,OAAQA,EAAKE,MACT,IAAK,KAAM,OAAOF,EAAKY,KAAKc,KAAKC,GACjC,IAAK,KAAM,MAAO,CAAC,IAAK,QAAS,SAAU,SAASY,SAASvC,EAAKtO,IAClE,IAAK,QAAS,OAAOsO,EAAKqC,SAASX,KAAKC,GACxC,QAAS,OAAO,IAIlBW,EAEF,CACA,IAAK,CAAC5R,EAAG2M,IAAM3M,EAAI2M,EACnB,IAAK,CAAC3M,EAAG2M,IAAM3M,EAAI2M,EACnB,IAAK,CAAC3M,EAAG2M,IAAM3M,EAAI2M,EACnB,IAAK,CAAC3M,EAAG2M,IAAM3M,EAAI2M,EACnB,KAAM,CAAC3M,EAAG2M,IAAM3M,GAAK2M,EACrB,IAAK,CAAC3M,EAAG2M,IAAM3M,GAAK2M,GAGlBmF,EAAS,SACXrL,EACAzC,EACAiD,EACAoG,GAGC,IAFDC,EAEC,uDAFmB3D,KAAKmB,IACzByC,EACC,uDADmB5D,KAAKoB,IAEzB,OAAO,IAAIqC,EAAQ3G,EAAGzC,EAAOiD,EAAIoG,EAAIC,EAAIC,IAGvCuD,EAEF,CACAtD,KAAM,CAAC/G,EAAG8C,IAAM,IAAI0D,EAAKxG,EAAG8C,GAC5B4E,OAAQ,CAAC1H,EAAGmH,IAAc,IAAID,EAAOlH,EAAGmH,GACxCmE,OAAQ,CAACtL,EAAGzG,EAAWkO,IACnB,IAAID,EAAOxH,EAAG,IAAI2E,MAAM3E,GAAG0G,KAAKnN,GAAI,IAAIoL,MAAM3E,EAAI,GAAG0G,KAAKe,IAC9D8D,MAAO,CAACvL,EAAGmH,EAAW3D,IAAc,IAAImE,EAAM3H,EAAGmH,EAAG3D,GACpDgI,gBAAiB,CAACxL,EAAGmH,EAAW3D,IAC5B,IAAIsE,EAAc9H,EAAGmH,EAAG3D,GAC5B6H,OARA,EASAlE,EAAGkE,EACHI,OAAQ,CAACzL,EAAGkI,IAAO,IAAID,EAAOjI,EAAGkI,IAS/BwC,EAAiB,CACnB3D,KAAOxB,GAAWA,EAClBmC,OAASnC,GAAWA,EAAS,EAC7B+F,OAAS/F,GAAWA,EAAS,EAC7BgG,MAAQhG,GAAWA,EAAS,EAC5BiG,gBAAkBjG,GAAWA,EAAS,EACtC8F,OAAS9F,GAAWA,EACpB4B,EAAI5B,GAAWA,EACfkG,OAASlG,GAAWA,I,mBCzMxBmG,EAAOC,QAAU,IAA0B,oC,gCCc3C,SAASC,EAAgBC,EAASC,EAAUC,EAAOhS,GACjDW,KAAKmR,QAAWA,EAChBnR,KAAKoR,SAAWA,EAChBpR,KAAKqR,MAAWA,EAChBrR,KAAKX,SAAWA,EAChBW,KAAKqH,KAAW,cAEuB,mBAA5BpG,MAAMqQ,mBACfrQ,MAAMqQ,kBAAkBtR,KAAMkR,IAdlC,SAAsBK,EAAOC,GAC3B,SAASC,IAASzR,KAAKJ,YAAc2R,EACrCE,EAAKC,UAAYF,EAAOE,UACxBH,EAAMG,UAAY,IAAID,EAexBE,CAAaT,EAAiBjQ,OAE9BiQ,EAAgBU,aAAe,SAASR,EAAUC,GAChD,IAAIQ,EAA2B,CACzBC,QAAS,SAASC,GAChB,MAAO,IAAOC,EAAcD,EAAYjQ,MAAQ,KAGlD,MAAS,SAASiQ,GAChB,IACIxL,EADA0L,EAAe,GAGnB,IAAK1L,EAAI,EAAGA,EAAIwL,EAAYG,MAAMvQ,OAAQ4E,IACxC0L,GAAgBF,EAAYG,MAAM3L,aAAc0D,MAC5CkI,EAAYJ,EAAYG,MAAM3L,GAAG,IAAM,IAAM4L,EAAYJ,EAAYG,MAAM3L,GAAG,IAC9E4L,EAAYJ,EAAYG,MAAM3L,IAGpC,MAAO,KAAOwL,EAAYK,SAAW,IAAM,IAAMH,EAAe,KAGlEI,IAAK,SAASN,GACZ,MAAO,iBAGTO,IAAK,SAASP,GACZ,MAAO,gBAGTQ,MAAO,SAASR,GACd,OAAOA,EAAYS,cAI3B,SAASC,EAAIC,GACX,OAAOA,EAAGC,WAAW,GAAG9R,SAAS,IAAIyP,cAGvC,SAAS0B,EAAcY,GACrB,OAAOA,EACJC,QAAQ,MAAO,QACfA,QAAQ,KAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,gBAAyB,SAASH,GAAM,MAAO,OAASD,EAAIC,MACpEG,QAAQ,yBAAyB,SAASH,GAAM,MAAO,MAASD,EAAIC,MAGzE,SAASP,EAAYS,GACnB,OAAOA,EACJC,QAAQ,MAAO,QACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,KAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,gBAAyB,SAASH,GAAM,MAAO,OAASD,EAAIC,MACpEG,QAAQ,yBAAyB,SAASH,GAAM,MAAO,MAASD,EAAIC,MA6CzE,MAAO,YAtCP,SAA0BtB,GACxB,IACI7K,EAAGuM,EANoBf,EAKvBgB,EAAe,IAAI9I,MAAMmH,EAASzP,QAGtC,IAAK4E,EAAI,EAAGA,EAAI6K,EAASzP,OAAQ4E,IAC/BwM,EAAaxM,IATYwL,EASaX,EAAS7K,GAR1CsL,EAAyBE,EAAYrC,MAAMqC,IAalD,GAFAgB,EAAaC,OAETD,EAAapR,OAAS,EAAG,CAC3B,IAAK4E,EAAI,EAAGuM,EAAI,EAAGvM,EAAIwM,EAAapR,OAAQ4E,IACtCwM,EAAaxM,EAAI,KAAOwM,EAAaxM,KACvCwM,EAAaD,GAAKC,EAAaxM,GAC/BuM,KAGJC,EAAapR,OAASmR,EAGxB,OAAQC,EAAapR,QACnB,KAAK,EACH,OAAOoR,EAAa,GAEtB,KAAK,EACH,OAAOA,EAAa,GAAK,OAASA,EAAa,GAEjD,QACE,OAAOA,EAAatJ,MAAM,GAAI,GAAGwJ,KAAK,MAClC,QACAF,EAAaA,EAAapR,OAAS,IAQxBuR,CAAiB9B,GAAY,QAJlD,SAAuBC,GACrB,OAAOA,EAAQ,IAAOW,EAAcX,GAAS,IAAO,eAGM8B,CAAc9B,GAAS,WA+pCrFL,EAAOC,QAAU,CACfmC,YAAalC,EACbhR,MA9pCF,SAAmBmD,EAAOgQ,GACxBA,OAAsB,IAAZA,EAAqBA,EAAU,GAEzC,IA4EIC,EA5EAC,EAAa,GAEbC,EAAyB,CAAE5Q,KAAM6Q,GAAeC,MAAOC,IACvDC,EAAyBH,GAEzBI,EAAS,SAASpR,EAAGkM,GACnB,MAAO,CAACN,KAAM,OAAQ5L,EAAGsB,SAAStB,GAAIkM,UAExCmF,EAAS,SAASC,EAAMC,GAAQ,MAAO,CAACD,KAASC,IACjDC,EAAS,SAAS9I,GAAK,MAAO,CAACA,IAC/B+I,EAAS,SAASxE,EAAMX,GACpB,MAAO,CAACV,KAAM,OAAQqB,KAAMA,EAAKyE,cAAepF,SAEpDqF,EAAS,SAASnE,GAAO,MAAO,CAACA,IACjCoE,EAAS,SAASzB,EAAGrK,EAAI1J,GACpB,MAAO,CAACwP,KAAM,QAAS9F,KAAIiI,SAAU,CAACoC,EAAG/T,KAE9CyV,EAAS,SAAS7T,GAAS,MAAO,CAAC4N,KAAM,SAAU5N,UACnD8T,EAAS,SAASlN,EAAM0H,GACpB,MAAO,CAACV,KAAM,KAAMhH,KAAMA,EAAK8M,cAAepF,SAElDyF,EAAS,IACTC,EAASC,GAAuB,KAAK,GACrCC,EAAU,IACVC,EAAUF,GAAuB,KAAK,GACtCG,EAAU,SAAShV,EAAIsQ,GAAS,MAAO,CAAC9B,KAAM,SAAUxO,KAAIsQ,UAC5D2E,EAAU,SAASjV,GAAM,MAAO,CAACwO,KAAM,KAAMxO,GAAIA,EAAGsU,gBACpDY,EAAU,SAASlW,GAAK,OAAOA,GAC/BmW,EAAU,SAAS7J,GAAK,OAAO8J,WAAW9J,IAC1C+J,EAAU,SAAS3O,GAAK,OAAOxC,SAASwC,IACxC4O,EAAU,YACVC,EAAUC,GAAqB,CAAC,CAAC,IAAK,KAAM,CAAC,IAAK,OAAO,GAAO,GAChEC,EAAU,eACVC,EAAUF,GAAqB,CAAC,CAAC,IAAK,KAAM,CAAC,IAAK,KAAM,CAAC,IAAK,OAAO,GAAO,GAC5EG,EAAU,SAAS3V,GAAM,OAAOA,GAChC4V,EAAU,SACVC,EAAUL,GAAqB,CAAC,IAAK,MAAM,GAAO,GAClDM,EAAU,SACVC,EAAUP,GAAqB,CAAC,CAAC,IAAK,OAAO,GAAO,GACpDQ,EAAU,QACVC,EAAUT,GAAqB,CAAC,IAAK,MAAM,GAAO,GAClDU,EAAU,IACVC,EAAUtB,GAAuB,KAAK,GACtCuB,EAAU,IACVC,EAAUxB,GAAuB,KAAK,GACtCyB,EAAU,IACVC,EAAU1B,GAAuB,KAAK,GACtC2B,EAAU,IACVC,EAAU5B,GAAuB,KAAK,GACtC6B,EAAU,IACVC,EAAU9B,GAAuB,KAAK,GACtC+B,EAAU,KACVC,EAAUhC,GAAuB,MAAM,GACvCiC,EAAU,IACVC,EAAUlC,GAAuB,KAAK,GACtCmC,EAAU,SAAStO,GAAM,OAAOA,GAChCuO,EAAU,IACVC,EAAUrC,GAAuB,KAAK,GACtCsC,EAAU,IACVC,EAAUvC,GAAuB,KAAK,GACtCwC,GAAU,IACVC,GAAUzC,GAAuB,KAAK,GACtC0C,GAAU,KACVC,GAAU3C,GAAuB,MAAM,GACvC4C,GAAU,KACVC,GAAU7C,GAAuB,MAAM,GACvC8C,GAAU,aACVC,GAAUpC,GAAqB,CAAC,IAAK,KAAM,KAAM,OAAO,GAAO,GAE/DqC,GAAuB,EAEvBC,GAAuB,CAAC,CAAEC,KAAM,EAAGC,OAAQ,IAC3CC,GAAuB,EACvBC,GAAuB,GACvBC,GAAuB,EAI3B,GAAI,cAAe3E,EAAS,CAC1B,KAAMA,EAAQ4E,aAAazE,GACzB,MAAM,IAAIvS,MAAM,mCAAqCoS,EAAQ4E,UAAY,MAG3ErE,EAAwBJ,EAAuBH,EAAQ4E,WA2BzD,SAASvD,GAAuB5S,EAAMoW,GACpC,MAAO,CAAExI,KAAM,UAAW5N,KAAMA,EAAMoW,WAAYA,GAGpD,SAAS7C,GAAqBnD,EAAOE,EAAU8F,GAC7C,MAAO,CAAExI,KAAM,QAASwC,MAAOA,EAAOE,SAAUA,EAAU8F,WAAYA,GAexE,SAASC,GAAsBC,GAC7B,IAAwCtZ,EAApCuZ,EAAUV,GAAoBS,GAElC,GAAIC,EACF,OAAOA,EAGP,IADAvZ,EAAIsZ,EAAM,GACFT,GAAoB7Y,IAC1BA,IASF,IALAuZ,EAAU,CACRT,MAFFS,EAAUV,GAAoB7Y,IAEZ8Y,KAChBC,OAAQQ,EAAQR,QAGX/Y,EAAIsZ,GACmB,KAAxB/U,EAAMsP,WAAW7T,IACnBuZ,EAAQT,OACRS,EAAQR,OAAS,GAEjBQ,EAAQR,SAGV/Y,IAIF,OADA6Y,GAAoBS,GAAOC,EACpBA,EAIX,SAASC,GAAoBC,EAAUC,GACrC,IAAIC,EAAkBN,GAAsBI,GACxCG,EAAkBP,GAAsBK,GAE5C,MAAO,CACL7P,MAAO,CACLzC,OAAQqS,EACRX,KAAQa,EAAgBb,KACxBC,OAAQY,EAAgBZ,QAE1BvF,IAAK,CACHpM,OAAQsS,EACRZ,KAAQc,EAAcd,KACtBC,OAAQa,EAAcb,SAK5B,SAASc,GAASvH,GACZsG,GAAcI,KAEdJ,GAAcI,KAChBA,GAAiBJ,GACjBK,GAAsB,IAGxBA,GAAoBvQ,KAAK4J,IAO3B,SAASwH,GAAyBxH,EAAUC,EAAOhS,GACjD,OAAO,IAAI6R,EACTA,EAAgBU,aAAaR,EAAUC,GACvCD,EACAC,EACAhS,GAIJ,SAASoU,KACP,IAAIoF,EAAIC,EAAQC,EAyBhB,OAvBAF,EAAKnB,IACLoB,EAAKE,QACMzF,GACJ0F,OACM1F,IACTwF,EAqBN,SAASG,IACP,IAAIL,EAAIC,EAAQC,EAEhBF,EAAKnB,IACLoB,EAAKK,QACM5F,GACJ0F,OACM1F,IACTwF,EAAKG,OACM3F,GACMsF,EACfC,EAAKhF,EAAOgF,EAAIC,GAChBF,EAAKC,IAUTpB,GAAcmB,EACdA,EAAKtF,GAEHsF,IAAOtF,IACTsF,EAAKnB,IACLoB,EAAKK,QACM5F,IACMsF,EACfC,EAAK7E,EAAO6E,IAEdD,EAAKC,GAGP,OAAOD,EAxDEK,MACM3F,GACMsF,EAEfA,EADAC,EAAKjF,EAAOiF,EAAIC,KAWpBrB,GAAcmB,EACdA,EAAKtF,GAGAsF,EAyCT,SAASM,KACP,IAAIN,EAAIC,EAAQC,EA+BhB,OA7BAF,EAAKnB,IACLoB,EAAKM,QACM7F,GACJ8F,OACM9F,IACTwF,EA2BN,SAASO,IACP,IAAIT,EAAIC,EAAQC,EAEhBF,EAAKnB,IACLoB,EAAKnF,QACMJ,GACJgG,OACMhG,IACTwF,EAAKO,OACM/F,GACMsF,EACfC,EAAKhF,EAAOgF,EAAIC,GAChBF,EAAKC,IAUTpB,GAAcmB,EACdA,EAAKtF,GAEHsF,IAAOtF,IACTsF,EAAKnB,IACLoB,EAAKnF,QACMJ,IACMsF,EACfC,EAAK1E,EAAO0E,IAEdD,EAAKC,GAGP,OAAOD,EA9DES,MACM/F,GACJiG,OACMjG,GACMsF,EAEfA,EADAC,EAAK5E,EAAO4E,EAAIC,KAetBrB,GAAcmB,EACdA,EAAKtF,GAGAsF,EAyCT,SAASlF,KACP,IAAIkF,EAAIC,EAAIW,EAAIV,EA4BhB,OA1BAF,EAAKnB,IACLoB,EAAKY,QACMnG,IACTkG,EA2fJ,WACE,IAAIZ,EAAIC,EAAIW,EAAIV,EAEhBF,EAAKnB,IACLoB,EAAKa,QACMpG,GACTkG,EAAK/B,GACiC,KAAlCrU,EAAMsP,WAAW+E,KACnBqB,EAAK9C,EACLyB,OAEAqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAASzC,IAEpC6C,IAAOxF,IAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnBqB,EAAK5C,EACLuB,OAEAqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAASvC,IAEpC2C,IAAOxF,IAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnBqB,EAAK1C,EACLqB,OAEAqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAASrC,IAEpCyC,IAAOxF,IAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnBqB,EAAKxC,EACLmB,OAEAqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAASnC,IAEpCuC,IAAOxF,IACLlQ,EAAM5D,OAAOiY,GAAa,KAAOjB,GACnCsC,EAAKtC,EACLiB,IAAe,IAEfqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAASjC,IAEpCqC,IAAOxF,IAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnBqB,EAAKpC,EACLe,OAEAqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAAS/B,UAQhD6C,EADEV,IAAOxF,EACJlQ,EAAMuW,UAAUH,EAAI/B,IAEpBqB,KAEIxF,IACTwF,EAAKY,QACMpG,GACMsF,EACfC,EAAKjC,EAAQ4C,GACbZ,EAAKC,IAMPpB,GAAcmB,EACdA,EAAKtF,KAGPmE,GAAcmB,EACdA,EAAKtF,GAGP,OAAOsF,EA9kBAgB,MACMtG,IACTwF,EAAKpF,QACMJ,GACMsF,EAEfA,EADAC,EAAKzE,EAAOyE,EAAIW,EAAIV,KAWxBrB,GAAcmB,EACdA,EAAKtF,GAEHsF,IAAOtF,IACTsF,EAAKa,MAGAb,EAGT,SAASa,KACP,IAAIb,EAAIC,EAAIW,EAAIV,EAAIe,EAmHpB,OAjHAjB,EAAKnB,IACLoB,EAyJF,WACE,IAAID,EAAIC,EAAIW,EAEZZ,EAAKnB,IACLoB,EAAKa,QACMpG,IACTkG,EAuHJ,WACE,IAAIZ,EAAIC,EAAIW,EAAIV,EAAIe,EAAIC,EAAIC,EAE5BnB,EAAKnB,GACLoB,EAAKpB,GACDjC,EAAQlT,KAAKc,EAAM4W,OAAOvC,MAC5B+B,EAAKpW,EAAM4W,OAAOvC,IAClBA,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAASjD,IAEpC+D,IAAOlG,IACTkG,EAAK,MAEHA,IAAOlG,GACLoC,EAAQpT,KAAKc,EAAM4W,OAAOvC,MAC5BqB,EAAK1V,EAAM4W,OAAOvC,IAClBA,OAEAqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAAS/C,IAEpCmD,IAAOxF,IACTuG,EAAKI,QACM3G,GACLsC,EAAQtT,KAAKc,EAAM4W,OAAOvC,MAC5BqC,EAAK1W,EAAM4W,OAAOvC,IAClBA,OAEAqC,EAAKxG,EACmB,IAApByE,IAAyBW,GAAS7C,IAEpCiE,IAAOxG,IACTyG,EAAKG,QACM5G,EAETuF,EADAW,EAAK,CAACA,EAAIV,EAAIe,EAAIC,EAAIC,IAOxBtC,GAAcoB,EACdA,EAAKvF,KAOTmE,GAAcoB,EACdA,EAAKvF,KAGPmE,GAAcoB,EACdA,EAAKvF,GAGLsF,EADEC,IAAOvF,EACJlQ,EAAMuW,UAAUf,EAAInB,IAEpBoB,EAEHD,IAAOtF,IACTsF,EAAKnB,GACLoB,EAAKpB,IACL+B,EAAKU,QACM5G,IACTkG,EAAK,MAEHA,IAAOlG,IACTwF,EAAKmB,QACM3G,EAETuF,EADAW,EAAK,CAACA,EAAIV,IAOZrB,GAAcoB,EACdA,EAAKvF,GAGLsF,EADEC,IAAOvF,EACJlQ,EAAMuW,UAAUf,EAAInB,IAEpBoB,GAIT,OAAOD,EAjNAuB,MACM7G,GACJoG,OACMpG,GACMsF,EACfC,EAAK9D,EAAQyE,GACbZ,EAAKC,IAUTpB,GAAcmB,EACdA,EAAKtF,GAEHsF,IAAOtF,IACTsF,EAAKnB,IACLoB,EAAKa,QACMpG,IACTkG,EAAKU,QACM5G,GACJoG,OACMpG,GACMsF,EACfC,EAAK5D,EAAQuE,GACbZ,EAAKC,IAUTpB,GAAcmB,EACdA,EAAKtF,IAIT,OAAOsF,EA3MFwB,MACM9G,IACMsF,EACfC,EAAKxE,EAAOwE,KAEdD,EAAKC,KACMvF,IACTsF,EAAKnB,IACLoB,EAAKM,QACM7F,IACTkG,EAAKJ,QACM9F,IACTwF,EAuGR,SAASuB,IACP,IAAIzB,EAAIC,EAAQC,EAEhBF,EAAKnB,IACLoB,EAAKnF,QACMJ,GACJgG,OACMhG,IACTwF,EAAKuB,OACM/G,GACMsF,EACfC,EAAKhF,EAAOgF,EAAIC,GAChBF,EAAKC,IAUTpB,GAAcmB,EACdA,EAAKtF,GAEHsF,IAAOtF,IACTsF,EAAKnB,IACLoB,EAAKnF,QACMJ,IACMsF,EACfC,EAAK1E,EAAO0E,IAEdD,EAAKC,GAGP,OAAOD,EA1IIyB,MACM/G,IACTuG,EAAKN,QACMjG,GACMsF,EAEfA,EADAC,EAAKvE,EAAOuE,EAAIC,KAetBrB,GAAcmB,EACdA,EAAKtF,GAEHsF,IAAOtF,IACTsF,EAAKnB,IACLoB,EAAKM,QACM7F,GAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnB+B,EAAKjF,EACLkD,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAASlE,IAEpCgF,IAAOlG,IACTwF,EAAKW,QACMnG,GAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnBoC,EAAKnF,EACL+C,OAEAoC,EAAKvG,EACmB,IAApByE,IAAyBW,GAAS/D,IAEpCkF,IAAOvG,GACMsF,EAEfA,EADAC,EAAKjE,EAAQiE,EAAIC,KAGjBrB,GAAcmB,EACdA,EAAKtF,KAOTmE,GAAcmB,EACdA,EAAKtF,KAGPmE,GAAcmB,EACdA,EAAKtF,GAEHsF,IAAOtF,IACTsF,EAAKnB,IACLoB,EAAKM,QACM7F,IACMsF,EACfC,EAAKhE,EAAQgE,KAEfD,EAAKC,KACMvF,IACTsF,EAAKnB,IACLoB,EAAKO,QACM9F,IACTkG,EAAK9F,QACMJ,IACTwF,EAAKS,QACMjG,GACMsF,EAEfA,EADAC,EAAK/D,EAAQ0E,KAWjB/B,GAAcmB,EACdA,EAAKtF,OAORsF,EA8FT,SAASO,KACP,IAAIP,EAAQY,EAAIV,EAAIe,EAAIC,EAAIC,EAI5B,GAFAnB,EAAKnB,GACAiC,OACMpG,EAAY,CAUrB,GATAkG,EAAK/B,GACLqB,EAAKrB,GACDvC,EAAQ5S,KAAKc,EAAM4W,OAAOvC,MAC5BoC,EAAKzW,EAAM4W,OAAOvC,IAClBA,OAEAoC,EAAKvG,EACmB,IAApByE,IAAyBW,GAASvD,IAEpC0E,IAAOvG,EAAY,CASrB,IARAwG,EAAK,GACDzE,EAAQ/S,KAAKc,EAAM4W,OAAOvC,MAC5BsC,EAAK3W,EAAM4W,OAAOvC,IAClBA,OAEAsC,EAAKzG,EACmB,IAApByE,IAAyBW,GAASpD,IAEjCyE,IAAOzG,GACZwG,EAAGvS,KAAKwS,GACJ1E,EAAQ/S,KAAKc,EAAM4W,OAAOvC,MAC5BsC,EAAK3W,EAAM4W,OAAOvC,IAClBA,OAEAsC,EAAKzG,EACmB,IAApByE,IAAyBW,GAASpD,IAGtCwE,IAAOxG,EAETwF,EADAe,EAAK,CAACA,EAAIC,IAGVrC,GAAcqB,EACdA,EAAKxF,QAGPmE,GAAcqB,EACdA,EAAKxF,GAGLkG,EADEV,IAAOxF,EACJlQ,EAAMuW,UAAUH,EAAI/B,IAEpBqB,KAEIxF,IACTwF,EAAKY,QACMpG,GACMsF,EAEfA,EADKrD,EAAQiE,KAOf/B,GAAcmB,EACdA,EAAKtF,QAGPmE,GAAcmB,EACdA,EAAKtF,EAGP,OAAOsF,EAgGT,SAASsB,KACP,IAAItB,EAAIC,EAAIW,EAAIV,EAiChB,OA/BAF,EAAKnB,GACLoB,EAAKpB,GACDjC,EAAQlT,KAAKc,EAAM4W,OAAOvC,MAC5B+B,EAAKpW,EAAM4W,OAAOvC,IAClBA,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAASjD,IAEpC+D,IAAOlG,IACTkG,EAAK,MAEHA,IAAOlG,IACTwF,EAAKC,QACMzF,EAETuF,EADAW,EAAK,CAACA,EAAIV,IAOZrB,GAAcoB,EACdA,EAAKvF,GAGLsF,EADEC,IAAOvF,EACJlQ,EAAMuW,UAAUf,EAAInB,IAEpBoB,EAMT,SAASE,KACP,IAAIH,EAAIC,EAAIW,EAWZ,GATAZ,EAAKnB,GACLoB,EAAK,GACDnD,EAAQpT,KAAKc,EAAM4W,OAAOvC,MAC5B+B,EAAKpW,EAAM4W,OAAOvC,IAClBA,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAAS/C,IAEpC6D,IAAOlG,EACT,KAAOkG,IAAOlG,GACZuF,EAAGtR,KAAKiS,GACJ9D,EAAQpT,KAAKc,EAAM4W,OAAOvC,MAC5B+B,EAAKpW,EAAM4W,OAAOvC,IAClBA,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAAS/C,SAI1CkD,EAAKvF,EAQP,OALEsF,EADEC,IAAOvF,EACJlQ,EAAMuW,UAAUf,EAAInB,IAEpBoB,EAMT,SAASoB,KACP,IAAIrB,EAAIC,EAAIW,EAAIV,EA8BhB,OA5BAF,EAAKnB,GACLoB,EAAKpB,GACiC,KAAlCrU,EAAMsP,WAAW+E,KACnB+B,EAAK1D,EACL2B,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAAS3C,IAEpCyD,IAAOlG,IACTwF,EAAKC,QACMzF,EAETuF,EADAW,EAAK,CAACA,EAAIV,IAOZrB,GAAcoB,EACdA,EAAKvF,GAGLsF,EADEC,IAAOvF,EACJlQ,EAAMuW,UAAUf,EAAInB,IAEpBoB,EA4FT,SAASO,KACP,IAAIR,EAAIC,EAAIW,EAAIV,EA8BhB,OA5BAF,EAAKnB,IACLoB,EAAKa,QACMpG,GAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnB+B,EAAK3C,EACLY,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAAS5B,IAEpC0C,IAAOlG,IACTwF,EAAKY,QACMpG,EAETsF,EADAC,EAAK,CAACA,EAAIW,EAAIV,IAOhBrB,GAAcmB,EACdA,EAAKtF,KAGPmE,GAAcmB,EACdA,EAAKtF,GAGAsF,EAGT,SAASW,KACP,IAAIX,EAAIC,EAAIW,EAAIV,EA8BhB,OA5BAF,EAAKnB,IACLoB,EAAKa,QACMpG,GAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnB+B,EAAKzC,EACLU,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAAS1B,IAEpCwC,IAAOlG,IACTwF,EAAKY,QACMpG,EAETsF,EADAC,EAAK,CAACA,EAAIW,EAAIV,IAOhBrB,GAAcmB,EACdA,EAAKtF,KAGPmE,GAAcmB,EACdA,EAAKtF,GAGAsF,EAGT,SAASU,KACP,IAAIV,EAAIC,EAAIW,EAAIV,EA8BhB,OA5BAF,EAAKnB,IACLoB,EAAKa,QACMpG,GAC6B,KAAlClQ,EAAMsP,WAAW+E,KACnB+B,EAAKvC,GACLQ,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAASxB,KAEpCsC,IAAOlG,IACTwF,EAAKY,QACMpG,EAETsF,EADAC,EAAK,CAACA,EAAIW,EAAIV,IAOhBrB,GAAcmB,EACdA,EAAKtF,KAGPmE,GAAcmB,EACdA,EAAKtF,GAGAsF,EAGT,SAASI,KACP,IAAIJ,EAAIC,EAAIW,EAAIV,EAgDhB,OA9CAF,EAAKnB,IACLoB,EAAKa,QACMpG,GACTkG,EAAK/B,GACDrU,EAAM5D,OAAOiY,GAAa,KAAON,IACnC2B,EAAK3B,GACLM,IAAe,IAEfqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAAStB,KAEpC0B,IAAOxF,IACTwF,EA8DN,WACE,IAAIF,EAAIC,EAAIW,EAEZZ,EAAKnB,GACLoB,EAAK,GACDtB,GAAQjV,KAAKc,EAAM4W,OAAOvC,MAC5B+B,EAAKpW,EAAM4W,OAAOvC,IAClBA,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAASlB,KAExC,GAAIgC,IAAOlG,EACT,KAAOkG,IAAOlG,GACZuF,EAAGtR,KAAKiS,GACJjC,GAAQjV,KAAKc,EAAM4W,OAAOvC,MAC5B+B,EAAKpW,EAAM4W,OAAOvC,IAClBA,OAEA+B,EAAKlG,EACmB,IAApByE,IAAyBW,GAASlB,UAI1CqB,EAAKvF,EAGLsF,EADEC,IAAOvF,EACJlQ,EAAMuW,UAAUf,EAAInB,IAEpBoB,EAGP,OAAOD,EA9FE0B,MACMhH,IACLlQ,EAAM5D,OAAOiY,GAAa,KAAOJ,IACnCyB,EAAKzB,GACLI,IAAe,IAEfqB,EAAKxF,EACmB,IAApByE,IAAyBW,GAASpB,OAK1CkC,EADEV,IAAOxF,EACJlQ,EAAMuW,UAAUH,EAAI/B,IAEpBqB,KAEIxF,IACTwF,EAAKY,QACMpG,EAETsF,EADAC,EAAK,CAACA,EAAIW,EAAIV,IAOhBrB,GAAcmB,EACdA,EAAKtF,KAGPmE,GAAcmB,EACdA,EAAKtF,GAGAsF,EAGT,SAASc,KACP,IAAId,EAAIC,EAUR,IARAD,EAAK,GACDrB,GAAQjV,KAAKc,EAAM4W,OAAOvC,MAC5BoB,EAAKzV,EAAM4W,OAAOvC,IAClBA,OAEAoB,EAAKvF,EACmB,IAApByE,IAAyBW,GAASlB,KAEjCqB,IAAOvF,GACZsF,EAAGrR,KAAKsR,GACJtB,GAAQjV,KAAKc,EAAM4W,OAAOvC,MAC5BoB,EAAKzV,EAAM4W,OAAOvC,IAClBA,OAEAoB,EAAKvF,EACmB,IAApByE,IAAyBW,GAASlB,KAI1C,OAAOoB,EAwCT,IAFAvF,EAAaM,OAEML,GAAcmE,KAAgBrU,EAAM1B,OACrD,OAAO2R,EAMP,MAJIA,IAAeC,GAAcmE,GAAcrU,EAAM1B,QACnDgX,GAjhCK,CAAEjJ,KAAM,QAohCTkJ,GACJb,GACAD,GAAiBzU,EAAM1B,OAAS0B,EAAM4W,OAAOnC,IAAkB,KAC/DA,GAAiBzU,EAAM1B,OACnB2W,GAAoBR,GAAgBA,GAAiB,GACrDQ,GAAoBR,GAAgBA,Q,mLCzxC9C,IAAMnR,EAASC,oBAAU,UACzBD,EAAO6T,gBAAgB,QAMvB,IAAMC,EAA6B,CAAIC,EAAcrH,KACjD,IACI,IAAMlF,EAAOjO,gBAAMwa,EAAMrH,GAEzB,OADA1M,EAAOvB,MAAP,iBAAuBsV,EAAvB,sBAAyC9b,YAAGuP,KACrCA,EACT,MAAOwM,GAEL,MADAhU,EAAOiU,MAAP,wBAA8BF,EAA9B,eAAyC9b,YAAG+b,EAAItb,UAAhD,aAA8Dsb,EAAIxJ,UAC5DwJ,IAIP,MAAME,G,0HAAAA,E,YACWjY,GAA2B6X,EAAa7X,I,EADnDiY,E,aAGYH,GAA4BD,EAAaC,EAAM,CAAEzC,UAAW,WCtB9E,MAAM6C,EAGTlb,YAAYgI,GAA0B,iDAMvB8S,IACX,IAAMzR,EAAM4R,EAAOE,UAAUL,GAC7B,OAAO1a,KAAKgb,WAAWC,SAAShS,KARE,sBAWtByR,IACZ,IAAMzR,EAAM4R,EAAOK,WAAWR,GAC9B,OAAO1a,KAAKgb,WAAWG,kBAAkBlS,KAZzCjJ,KAAKgb,WAAa,IAAII,EAAW,CAC7BvY,MAAOgY,EAAOK,WAAWtT,EAAO/E,UAmBrC,MAAMuY,EACTxb,YAA6Byb,GAA8B,KAA9BA,gBAA8B,kBAE/CzY,IACR,IAAMH,EAAIG,EAAKH,EACTkM,EAAQ/L,EAAK+L,MAEnB,MAAO,CACHN,KAAMzL,EAAKyL,KACX5L,IACAkM,MAAOA,EAAM9B,IAAI7M,KAAKsb,qBAT6B,2BAatC,IAAiD,IAAjD,KAAEjN,EAAF,GAAQ9F,EAAR,SAAYiI,GAAqC,GAC3D3R,EAAG2M,GAAKgF,EAAS3D,IAAI7M,KAAKub,gBACjC,MAAO,CAAElN,OAAM9F,KAAIiI,SAAU,CAAC3R,EAAG2M,MAfsB,0BAkB/B,IAAiD,IAAjD,KAAE6C,EAAMqB,KAAMtE,EAAd,KAAkB2D,GAA+B,EACzE,MAAO,CACHV,OACAqB,KAAMtE,EACN2D,KAAMA,EAAKlC,IAAI7M,KAAKub,mBAtB+B,wBA0BjCpN,IACtB,OAAQA,EAAKE,MACT,IAAK,SAAU,OAAOF,EACtB,IAAK,KAAM,OAAOnO,KAAKwb,eAAerN,GACtC,IAAK,SAAU,OAAOnO,KAAKyb,mBAAmBtN,GAC9C,IAAK,KAAM,OAAOnO,KAAK0b,eAAevN,GACtC,IAAK,QAAS,OAAOnO,KAAKmb,kBAAkBhN,MAhCO,wBAoCjC,IAAyC,IAAzC,KAAEE,EAAF,KAAQhH,EAAR,KAAc0H,GAA2B,EAC/D,MAAO,CACHV,OACAhH,OACA0H,KAAMA,EAAKlC,IAAI7M,KAAK0b,mBAxC+B,4BA4C7B,IAAgD,IAAhD,KAAErN,EAAF,GAAQxO,EAAR,MAAYsQ,GAAoC,EAC1E,MAAO,CAAE9B,OAAMxO,KAAIsQ,MAAOnQ,KAAKub,eAAepL,MA7CS,wBAgDjChC,IACtB,IAAM,GAAEtO,GAAOsO,EACf,OAAItO,KAAMG,KAAKqb,cACJrb,KAAKub,eAAevb,KAAKqb,cAAcxb,IAEvCsO,K,6KCvEnB,IAAMxH,EAASC,oBAAU,aAElB,MAAM+U,EAQT/b,YACqBsO,EACjBjF,EACiB2S,EACjB7T,GACF,KAJmBmG,QAInB,KAFmB0N,KAEnB,oKAsBYnW,IACV,IAAMC,EAAO,IAAIC,aAAaF,IACxB,EAAEhD,EAAG8G,SAAUiG,EAAf,OAAqBtJ,EAArB,MAA6BoE,GAAUtK,KACvCqD,EAAQgC,IAAKhC,MAAMqC,GACrBa,EAAIL,EACR,IAAK,IAAM0E,KAAK4E,EAAK9E,OAAOjI,EAAGyD,EAAQoE,GACnCjF,IAAK3E,IAAI2C,EAAOuH,EAAGrE,IAAKiJ,EAAKlK,KA5BnC,iBAgCSG,IACP,IAAMC,EAAO,IAAIC,aAAaF,IACtB8D,SAAUiG,EAAMqM,SAAUC,EAA5B,MAAkC5N,EAAlC,EAAyCzL,EAAzC,OAA4CyD,EAA5C,MAAoDoE,GAAUtK,KAC9DqD,EAAQgC,IAAKhC,MAAMqC,GACnBH,EAAWF,IAAKE,SAASG,GACzBiD,EAAQC,KAAKC,MAEnBpC,IAAOqE,MAAMpF,EAAKL,IAAKO,SAAUnD,EAAjC,2BACAgE,IAAOqE,MAAMpF,EAAKL,IAAKW,aAAcwJ,EAAKlK,EAA1C,6BACAmB,IAAOqE,MAAMpF,EAAKL,IAAKQ,eAAeH,IAAQoW,EAAKxW,EAAG,2BAEtDqB,EAAOvB,MAAP,0BAAgCxG,YAAGsP,GAAnC,aAA8CtP,YAAGkd,KACjD,IAAK,IAAIvV,EAAIL,EAAQK,EAAI+D,EAAO/D,IAC5BuV,EAAK1Q,GAAG/F,IAAK9F,IAAI8D,EAAOkD,EAAGiJ,EAAKlK,GAAID,IAAK9F,IAAIgG,EAAUgB,EAAGuV,EAAKxW,IAGnEtF,KAAK+b,cAAcrW,GAEnBiB,EAAOvB,MAAP,gCAAsCwD,KAAKC,MAAQF,EAAnD,SAlDF,uBAqDuBjD,IACrBiB,EAAOvB,MAAP,oBAKA,IAJA,IAAM,EAAEE,EAAF,GAAKsW,EAAL,OAAS1V,EAAT,MAAiBoE,EAAjB,SAAwBlB,GAAapJ,KACrCuF,EAAWF,IAAKE,SAASG,GACzBF,EAAQH,IAAKG,MAAME,GAEhBa,EAAIL,EAAQK,EAAI+D,EAAO/D,IAAK,CACjC,IAAMzH,EAAIuG,IAAK9F,IAAIgG,EAAUgB,EAAGjB,IACzBxC,EAAG8P,EAAGxK,GAAK4T,MAAIC,IAAI,CACtBzT,KAAKC,MAAMW,EAAS1E,QAAQkX,EAAG9Y,EAAG,CAAEhE,IAAGyH,OACvC,IACAiC,KAAKC,MAAMW,EAAS1E,QAAQkX,EAAG7Y,EAAG,CAAEjE,IAAGyH,SAErC2V,EAAI,IAAIC,IAAJ,cAAiBrZ,EAAjB,aAAuB8P,EAAvB,cAA8BxK,EAA9B,OAEV/C,IAAK3E,IAAI8E,EAAO,CAAC0W,EAAEzP,EAAGyP,EAAEE,EAAGF,EAAE1Q,GAAIjF,EAAG,MAnExC,IAAM6C,EAAW,IAAIC,IAAS6E,IACtBzL,IAAF,SAAK8G,EAAL,UAAeC,GAAcJ,EAAS1E,QAAQuE,GAC9C/C,EAAS6B,EAAM7B,OACfxE,EAAOqG,EAAMrG,KACb4I,EAAQpE,EAASxE,EACvB+E,IAAOP,GAAU,EAAX,2CAAkDA,IACxDO,IAAO6D,GAAS7H,EAAV,0CAAgDyD,EAAhD,cAA4DxE,EAA5D,cAAsE4I,EAAtE,cAAiF7H,IAEvFzC,KAAKyC,EAAIA,EACTzC,KAAKuJ,SAAWA,EAChBvJ,KAAK6b,SAAWrS,EAChBxJ,KAAKkG,OAASA,EACdlG,KAAKsK,MAAQA,EACbtK,KAAKoJ,SAAWA,EAIpB,QACI,OAAOpJ,KAAK6b,SAASvW,G,sKCtCdsB,oBAAU,QAClBC,SAAS,QAET,MAAMqC,G,EAAAA,E,UACStB,GACP,IAAIkT,EAAS5R,EAAKmT,WAAWzU,IAAS0U,YAAY1U,EAAOhF,O,EAF3DsG,E,eAKa,CAACtB,EAAgBG,IAC5BmB,EAAKqT,mBAAmBrT,EAAKmT,WAAWzU,GAASG,I,EANnDmB,E,WASS,CAACtB,EAAgBnF,IACxByG,EAAKsT,eAAetT,EAAKmT,WAAWzU,GAASnF,I,EAV/CyG,E,qBAa2B,CAACtB,EAA0BG,KAC3D,IAAM0U,EAAW,IAAI3B,EAASlT,GACxBqB,EAAMwT,EAASH,YAAY1U,EAAOhF,MAClCgZ,EAAK1S,EAAKwT,UAAU9U,EAAQ6U,GAClC,OAAO,IAAId,EAAUzS,EAAKsT,eAAe5U,EAAQqB,EAAIxG,GAAIwG,EAAK2S,EAAI7T,K,EAjB7DmB,E,aAoBoBtB,IAClB,CACHhF,KAAMgF,EAAOhF,KACbC,MAAO+E,EAAO/E,OAAS,IACvBC,EAAG8E,EAAO9E,GAAK,IACfC,EAAG6E,EAAO7E,GAAK,MACf+F,EAAGlB,EAAOkB,GAAK,EACf6T,MAAO/U,EAAO+U,OAAS,EACvBC,OAAQhV,EAAOgV,QAAU,EACzBC,MAAOjV,EAAOiV,OAAS,K,EA7BtB3T,E,iBAiCuB,CAACtB,EAA0BnF,KACvD,IAAM,MAAEka,EAAF,EAAS7T,EAAT,OAAY8T,EAAZ,MAAoBC,GAAUjV,EACpC,MAAO,CAAEkB,IAAG6T,QAAOC,SAAQna,IAAGiH,QAAKmT,W,EAnC9B3T,E,YAsCkB,CAACtB,EAA0B6U,KAC3C,CACH3Z,EAAG2Z,EAASK,aAAT,iBAAgClV,EAAO9E,EAAvC,MACHC,EAAG0Z,EAASK,aAAT,iBAAgClV,EAAO7E,EAAvC,U,oOCoCR,IAAMsB,EAAW,IA1ExB,MAOEzE,cAAc,4GAFF,GAEE,iBAoBI,KAChB,IACMmd,EAAQ3d,OAAO4d,WACfC,EAAS7d,OAAO8d,YAChBC,EAASJ,EAAQE,EAGvBjd,KAAKqE,SAAS+Y,QAAQL,EAAOE,GAC7Bjd,KAAKqd,OAAS,IAAIC,IAHN,IAG6BH,EAP5B,IAAY,KAQzBnd,KAAKqd,OAAO9X,SAASgY,EAAIvd,KAAKud,IA7BlB,gBAoCL,KACPvd,KAAKqE,SAASE,OAAOvE,KAAKwd,MAAOxd,KAAKqd,UArC1B,gBAwCJ,IAAiC,IAAjC,EAAE/X,EAAF,SAAKC,EAAL,MAAeC,GAAkB,GACnC,OAAEkG,GAAW1L,KACbyd,EAAW/R,EAAO+R,SACxBhX,IAAOqE,MAAMvF,EAAS5D,OAAS2D,EAAG,GAClCmB,IAAOqE,MAAMtF,EAAM7D,OAAS,EAAG,GAE/B4D,EAASmY,QAAQ,CAAC5e,EAAGyH,KACfoX,MAAM7e,IACR8e,QAAQC,KAAR,mCAAyCtX,MAI7CkX,EAASK,aAAa,WAAY,IAAIC,IAAgBxY,EAAUD,IAChEmY,EAASK,aAAa,QAAS,IAAIC,IAAgBvY,EAAO,IAE1D,IAAI+X,EAAI,EACR,GAAIjY,EAAI,EAAG,CACTmY,EAASO,wBACT,IAAMpL,EAAI6K,EAASQ,eACnBV,EAAI/U,KAAK5E,IAAI,EAAGgP,EAAEsL,OAAOX,EAAI3K,EAAEuL,OAAS,GAE1Cne,KAAKqd,OAAO9X,SAASgY,EAAIvd,KAAKud,EAAIA,EAElCa,sBAAsBpe,KAAKuE,UA9D3BvE,KAAKqE,SAAW,IAAIga,IACpBre,KAAKod,UACLhe,OAAOkf,SAAW,KAChBte,KAAKod,UACLgB,sBAAsBpe,KAAKuE,SAG7BvE,KAAK0L,OAAS,IAAI6S,IAChB,IAAIC,IACJ,IAAIC,IAAe,CACjBC,aAAcC,IACdjd,KAAM,QAIV1B,KAAKwd,MAAQ,IAAIoB,IACjB5e,KAAKwd,MAAMjO,IAAIvP,KAAK0L,QAetB,iBACE,OAAO1L,KAAKqE,SAASC","file":"2.20b0e36c06c5a26ad511.js","sourcesContent":["export const pp = (a: any, p = 2) => JSON.stringify(a, null, p);\n","import multirange from 'multirange';\nimport {BehaviorSubject, Subject} from 'rxjs';\n\nimport {poolSize} from '../../core/pipe/pool';\nimport debug from '../debug';\nimport {renderer} from '../renderer';\n\ntype Change<T> = {\n  newValue: T;\n  oldValue?: T;\n  event?: Event;\n};\n\nconst query = new URLSearchParams(window.location.search);\nconst persistenceEnabled = query.get('p') != '0';\nconst hash = (() => {\n  const temp = window.location.hash.substr(1);\n  return new URLSearchParams(temp ? atob(temp) : '');\n})();\n\nexport abstract class AbstractInput<T, E = HTMLElement> {\n  private readonly subject: Subject<Change<T>>;\n  protected el?: E;\n\n  constructor(\n      readonly id: string, private _value: T,\n      private readonly persistent: boolean) {\n    if (persistenceEnabled) {\n      this.initFromOrWriteToHash();\n    } else {\n      this.persistent = false;\n    }\n    this.subject = this.newSubject();\n  }\n\n  initFromOrWriteToHash = () => {\n    if (this.persistent && hash.has(this.id)) {\n      this._value = this.parse(hash.get(this.id));\n    } else if (this.persistent) {\n      this.updateHash();\n    }\n  };\n\n  newSubject = () => new BehaviorSubject({newValue: this._value});\n\n  setup = (el: E) => {\n    this.el = el;\n    this._setup();\n  };\n\n  protected abstract _setup(): void;\n\n  protected parse(str: string): T {\n    throw new Error('parse unsupported');\n  };\n  protected stringify(value: T): string {\n    throw new Error('stringify unsupported');\n  };\n\n  get stream() {\n    return this.subject.asObservable();\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(newValue: T) {\n    const oldValue = this.value;\n    this._value = newValue;\n    this.subject.next({newValue, oldValue, event: window.event});\n    if (this.persistent) this.updateHash();\n  }\n\n  private updateHash = () => {\n    const str = this.stringify(this.value);\n    hash.set(this.id, str);\n    document.location.hash = btoa(hash.toString());\n  };\n}\n\ntype TextInputId = 'pipe'|'theta'|'h'|'v';\n\nexport class TextInput extends AbstractInput<string, HTMLInputElement> {\n  readonly disabled = false;\n\n  constructor(\n      readonly id: TextInputId,\n      _value: string,\n      persistent: boolean = true,\n  ) {\n    super(id, _value, persistent);\n  }\n\n  protected _setup = () => {\n    this.el.onchange = () => this.value = this.el.value;\n    this.el.oninput = () => this.el.size = this.el.value.length;\n\n    this.stream.subscribe(({newValue}) => {\n      this.el.value = newValue;\n      this.el.size = newValue.length;\n    });\n  };\n\n  protected parse(str: string) {\n    return str;\n  }\n\n  protected stringify(text: string) {\n    return text;\n  }\n}\n\ntype ToggleInputId = 'animate'|'mic'|'fullscreen';\n\nexport class ToggleInput extends AbstractInput<boolean> {\n  constructor(\n      readonly id: ToggleInputId,\n      _value: boolean,\n      readonly disabled: boolean = false,\n      persistent: boolean = true,\n  ) {\n    super(id, _value, persistent);\n  }\n\n  protected _setup = () => {\n    const on = this.el.querySelector<HTMLInputElement>('.on');\n    on.onclick = () => this.value = true;\n\n    const off = this.el.querySelector<HTMLInputElement>('.off');\n    off.onclick = () => this.value = false;\n\n    this.stream.subscribe(({newValue}) => {\n      if (newValue) {\n        on.style.display = 'none';\n        off.style.display = 'inline';\n      } else {\n        on.style.display = 'inline';\n        off.style.display = 'none';\n      }\n    });\n  };\n\n  protected parse(str: string) {\n    if (/1|true/i.test(str))\n      return true;\n    else if (/0|false/i.test(str))\n      return false;\n    else\n      throw new Error(`invalid boolean value for input ${this.id}: ${str}`);\n  };\n\n  protected stringify(bool: boolean) {\n    return bool ? '1' : '0';\n  }\n}\n\ntype RangeInputId = 'allowed_db_range';\n\nexport class RangeInput extends AbstractInput<[number, number]> {\n  constructor(\n      readonly id: RangeInputId,\n      _value: [number, number],\n      readonly disabled: boolean = false,\n      persistent: boolean = true,\n  ) {\n    super(id, _value, persistent);\n  }\n\n  protected _setup = () => {\n    const input = this.el.querySelector<MultirangeHTMLInputElement>('input');\n    multirange(input);\n    const minEl = this.el.querySelector<HTMLElement>('.min');\n    const maxEl = this.el.querySelector<HTMLElement>('.max');\n\n    input.onchange = () => {\n      this.value = [+input.valueLow, +input.valueHigh];\n    };\n\n    this.el.querySelector<HTMLInputElement>('input.ghost').oninput =\n        input.oninput = () => {\n          minEl.innerText = input.valueLow.toString();\n          maxEl.innerText = input.valueHigh.toString();\n        };\n\n    this.stream.subscribe(({newValue}) => {\n      input.value = this.stringify(newValue);\n      minEl.innerText = input.valueLow.toString();\n      maxEl.innerText = input.valueHigh.toString();\n    });\n  };\n\n  protected parse(str: string): [number, number] {\n    const [min, max] = str.split(/,/);\n    return [parseInt(min), parseInt(max)];\n  }\n\n  protected stringify([min, max]) {\n    return `${min},${max}`;\n  };\n}\n\nexport class ActionInput extends AbstractInput<void> {\n  constructor(\n      id: string,\n      private readonly action: (ev: MouseEvent, el: HTMLElement) => void,\n      readonly disabled: boolean = false,\n  ) {\n    super(id, null, false);\n  }\n\n  protected _setup = () => {\n    this.el.onclick = (ev) => this.action(ev, this.el);\n  };\n}\n\n// Points generation is done in parallel, so pick n such\n// that each chunk is size 2000\nconst n = 2000 * poolSize;\n\nexport const inputs = {\n  pipe: new TextInput(\n      'pipe',\n      `${n}->torus(4, 1, 1)->R(theta, 0, 1, cos, tan)->R(theta, 0, 2)->R(theta, 0, 3)->stereo(3)`,\n      ),\n  theta: new TextInput('theta', 'pi * (t + onset) / 20'),\n  h: new TextInput('h', 'chroma * abs(p[0])'),\n  v: new TextInput('v', 'power'),\n  animate: new ToggleInput('animate', true, false, true),\n  mic: new ToggleInput('mic', false, false, false),\n  fullscreen: new ToggleInput(\n      'fullscreen',\n      false,\n      !document.fullscreenEnabled,\n      false,\n      ),\n  allowedDbs: new RangeInput('allowed_db_range', [-100, -30]),\n  save: new ActionInput(\n      'save',\n      async (_, el) => {\n        const canvas = renderer.domElement;\n        renderer.render();\n        const blob = await new Promise(resolve => canvas.toBlob(resolve));\n        const url = URL.createObjectURL(blob);\n        try {\n          const a = document.createElement('a');\n          a.download = `stereo${document.location.hash}`;\n          a.href = url;\n          a.click();\n        } finally {\n          URL.revokeObjectURL(url);\n        }\n      }),\n};\nexport type Inputs = typeof inputs;\n\ndebug('inputs', inputs);\n","import assert from 'assert';\n\nexport type Vector = Float32Array;\n\nexport class Data {\n    constructor(\n        readonly n: number,\n        readonly d: number,\n        readonly position: Float32Array,\n        readonly color: Float32Array\n    ) { }\n\n    static fromBuffer = (buffer: ArrayBuffer) => {\n        const data = new Float32Array(buffer);\n        const n = data[Data.nOffset];\n        const d = data[Data.positionOffset(data)];\n        const position = Data.position(data);\n        const color = Data.color(data);\n        return new Data(n, d, position, color);\n    };\n\n    static bufferFor = (n: number, d0: number, d: number): SharedArrayBuffer => {\n        const bytesPerNum = 4;\n        const count = 3 + n * (d0 + d + 3);\n        const byteLength = bytesPerNum * count;\n        const buffer = new SharedArrayBuffer(byteLength);\n        const data = new Float32Array(buffer);\n        data[Data.nOffset] = n;\n        data[Data.inputOffset] = d0;\n        data[Data.positionOffset(data)] = d;\n        return buffer;\n    };\n\n    static input = (arr: Float32Array) => {\n        const offset = Data.inputOffset + 1;\n        return arr.subarray(offset, offset + Data.inputLength(arr));\n    };\n\n    static position = (arr: Float32Array) => {\n        const offset = Data.positionOffset(arr) + 1;\n        return arr.subarray(offset, offset + Data.positionLength(arr));\n    };\n\n    static color = (arr: Float32Array) => {\n        const offset = Data.colorOffset(arr);\n        return arr.subarray(offset);\n    };\n\n    static nOffset = 0;\n\n    static inputOffset = Data.nOffset + 1;\n    private static inputLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d0 = arr[Data.inputOffset];\n        return n * d0;\n    };\n\n    static positionOffset = (arr: Float32Array) =>\n        Data.inputOffset + Data.inputLength(arr) + 1;\n    private static positionLength = (arr: Float32Array) => {\n        const n = arr[Data.nOffset];\n        const d = arr[Data.positionOffset(arr)];\n        return n * d;\n    };\n\n    static colorOffset = (arr: Float32Array) =>\n        Data.positionOffset(arr) + Data.positionLength(arr) + 1;\n\n    static get = (arr: Vector, i: number, stride: number) => {\n        const offset = i * stride;\n        return arr.subarray(offset, offset + stride);\n    };\n\n    static set = (arr: Vector, value: ArrayLike<number>, i: number, stride: number) => {\n        assert(value.length <= stride);\n        const offset = i * stride;\n        return arr.set(value, offset);\n    };\n}\n","import { spawn, Worker, Pool, ModuleThread } from \"threads\";\nimport { getLogger } from 'loglevel';\nimport { Params, PipelineWorker, Chunk } from './types';\nimport { Pipe } from \"./pipe\";\nimport { Data } from \"../data\";\nimport { Resolver, Resolution } from \"./resolver\";\n\nconst logger = getLogger('PipelinePool');\nlet pool: Pool<ModuleThread<PipelineWorker>>;\nlet data: Map<string, SharedArrayBuffer>;\nlogger.setLevel('info');\n\nexport const poolSize = 2 * navigator.hardwareConcurrency;\n\nexport const startPool = async () => {\n    logger.info('starting worker pool');\n    let i = 0;\n    pool = Pool(() => spawn(new Worker('./pipe.worker', { name: `pipe${i++}` })), poolSize);\n    data = new Map();\n    let promises = [];\n    for (let i = 0; i < poolSize; i++) {\n        // pre-load scripts so the first task doesn't take forever\n        promises.push(pool.queue(async () => { }));\n    }\n    await Promise.all(promises);\n};\n\nexport const stopPool = async (): Promise<void> => {\n    logger.info('waiting for pending tasks to complete before terminating pool');\n    try {\n        await pool.terminate(true);\n    } catch (err) {\n        logger.error(err);\n    } finally {\n        pool = null;\n    }\n};\n\nconst initialize = (params: Params, n: number, buffer: SharedArrayBuffer): Promise<void> => {\n    return timing('initialization')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.initialize(params, chunk, buffer));\n        });\n    });\n};\n\nconst iterate = (params: Params, n: number, buffer: SharedArrayBuffer) => {\n    return timing('iteration')(async () => {\n        return forkJoin(n, async (chunk) => {\n            return pool.queue(w => w.iterate(params, chunk, buffer));\n        });\n    });\n};\n\nconst getKey = (params: Params) => JSON.stringify({\n    pipe: params.pipe,\n    theta: params.theta,\n    h: params.h,\n    l: params.v,\n});\n\nconst getOrInitialize = async (params: Params, n: number, d0: number, d: number): Promise<SharedArrayBuffer> => {\n    const key = getKey(params);\n    if (!data.has(key)) {\n        const buffer = Data.bufferFor(n, d0, d);\n        await initialize(params, n, buffer);\n        data.set(key, buffer);\n    }\n    return data.get(key);\n};\n\nconst forkJoin = async (n: number, op: (chunk: Chunk) => Promise<void>) => {\n    const size = Math.round(n / poolSize);\n    let promises = [];\n    for (let offset = 0; offset < n; offset += size) {\n        const chunk = { offset, size: Math.min(n - offset, size) };\n        promises.push(op(chunk));\n    }\n    await Promise.all(promises);\n};\n\nconst timing = (label: string) => async<T>(op: () => Promise<T>) => {\n    const start = Date.now();\n    const t = await op();\n    const elapsed = Date.now() - start;\n    logger.debug(`${label} took ${elapsed}ms`);\n    return t;\n};\n\nexport const runPipeline = async (params: Params): Promise<SharedArrayBuffer> => {\n    const ast = Pipe.compile(params);\n    const resolver = new Resolver(Pipe.scopeFor(params, ast.n));\n    const { n, staticFn, dynamicFn } = resolver.resolve(ast) as Resolution;\n    const buffer = await getOrInitialize(params, n, staticFn.d, dynamicFn.d);\n    await iterate(params, n, buffer);\n\n    return buffer.slice(0);\n};\n","export const inf = 2 ** 32 - 1;\n","import { Vector } from \"../data\";\nimport assert from 'assert';\nimport { inf } from \"../constants\";\n\nexport const cos = Math.cos;\nexport const sin = Math.sin;\nexport const tan = Math.tan;\nexport const tanh = Math.tanh;\nexport const exp = Math.exp;\n\nexport const components = (d) => Array.from(new Array(d).keys());\n\nexport interface Fn {\n  readonly d: number;\n  readonly domain: number;\n  fn(x: Vector, y?: Vector): Vector;\n  sample(n: number, offset: number, limit: number): Generator<Vector>;\n}\n\nexport class CompositeFn implements Fn {\n  private readonly x: Vector;\n  private readonly y: Vector;\n  constructor(readonly fns: Fn[]) {\n    assert(fns.length, 'fns cannot be empty');\n\n    const length = Math.max(this.domainMax, this.dMax);\n    this.x = new Float32Array(length);\n    this.y = new Float32Array(length);\n\n  }\n\n  get first() {\n    return this.fns[0];\n  }\n\n  get last() {\n    return this.fns[this.fns.length - 1];\n  }\n\n  get domain() {\n    return this.first.domain;\n  }\n\n  get d() {\n    return this.last.d;\n  }\n\n  get domainMax() {\n    return this.fns.reduce((max, f) => Math.max(f.domain, max), 0);\n  }\n\n  get dMax() {\n    return this.fns.reduce((max, f) => Math.max(f.d, max), 0);\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { fns, d } = this;\n    const [first, ...rest] = fns;\n    if (fns.length == 0) return [];\n\n    for (const x of first.sample(n, offset, limit)) {\n      this.x.set(x);\n      if (rest.length) {\n        CompositeFn.apply(rest, this.x, this.y);\n      } else {\n        this.y.set(x);\n      }\n      yield this.y.subarray(0, d);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { fns, domain, d } = this;\n    assert.equal(x.length, domain);\n    assert.equal(y.length, d);\n\n    this.x.set(x);\n    CompositeFn.apply(fns, this.x, this.y);\n    y.set(this.y.subarray(0, d));\n    return y;\n  };\n\n  private static apply = (fns: Fn[], x: Vector, y: Vector) => {\n    assert.equal(x.length, y.length);\n    for (const f of fns) {\n      f.fn(x.subarray(0, f.domain), y.subarray(0, f.d));\n      x.set(y);\n    }\n    for (let i = 0; i < y.length; i++) {\n      if (!isFinite(y[i])) y[i] = Math.sign(y[i]) * inf;\n    }\n  };\n\n  static Builder = class {\n    private readonly fns: Fn[] = [];\n\n    get d() {\n      return this.last.d;\n    }\n\n    get last() {\n      return this.fns[this.fns.length - 1];\n    }\n\n    add = (fn: Fn) => {\n      const { fns, last } = this;\n      if (last && fn.domain !== last.d) {\n        throw new Error(\n          `Cannot add ${fn} to composite, because its domain is not ${last.d}`,\n        );\n      }\n      fns.push(fn);\n      return this;\n    };\n\n    build = () => {\n      return new CompositeFn(this.fns);\n    };\n  };\n}\n","import { Fn } from './fn';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Interval implements Fn {\n  readonly domain: number;\n\n  constructor(readonly d: number, readonly a: number[], readonly b: number[]) {\n    assert.equal(a.length, d);\n    assert.equal(b.length, d);\n    this.domain = d;\n  }\n\n  static nPerLevel = (d: number, n: number) => {\n    return Math.round(Math.pow(n, 1 / d));\n  };\n\n  static n = (d: number, n: number) => Interval.nPerLevel(d, n) ** d;\n\n  /**\n   * @param x A vector of length this.domain contained in the interval [0, 1].\n   * @returns A mapping of the vector into this interval.\n   */\n  fn = (x: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, b, d } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    for (let i = 0; i < d; i++) {\n      y[i] = a[i] + x[i] * (b[i] - a[i]);\n    }\n    return y;\n  };\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const { d, fn } = this;\n    n = Interval.nPerLevel(d, n);\n    const points: number[][] = [[]];\n    let i = 0;\n\n    while (points.length && i < limit) {\n      const p = points.pop()!;\n      if (p.length < d) {\n        points.push(...successors(p));\n      } else if (i++ >= offset) {\n        yield fn(p);\n      }\n    }\n\n    function* successors(p: number[]): Generator<number[]> {\n      for (let i = 0; i < n; i++) {\n        yield [...p, i / n];\n      }\n    }\n  };\n}\n","import Interval from \"./interval\";\nimport { Fn } from \"./fn\";\nimport { Vector } from \"../data\";\n\nexport default class Cube implements Fn {\n  private readonly interval: Interval;\n\n  constructor(readonly d: number, readonly l: number) {\n    this.interval = new Interval(\n      d,\n      new Array(d).fill(-l / 2),\n      new Array(d).fill(l / 2)\n    );\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  fn = (x: Vector, y?: Vector) => this.interval.fn(x, y);\n\n  sample = (n: number, offset: number, limit: number) =>\n    this.interval.sample(n, offset, limit);\n}\n","import { Fn, cos, sin } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Rotator implements Fn {\n  readonly r0: number;\n  readonly r1: number;\n\n  constructor(\n    readonly d: number,\n    readonly theta: number,\n    readonly d0: number,\n    readonly d1: number,\n    readonly f0: (theta: number) => number = cos,\n    readonly f1: (theta: number) => number = sin,\n  ) {\n    this.r0 = f0(theta);\n    this.r1 = f1(theta);\n  }\n\n  get domain() {\n    return this.d;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const p of cube.sample(n, offset, limit)) {\n      yield this.fn(p);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, d0, d1, r0, r1 } = this;\n    assert.equal(x.length, d);\n    assert.equal(y.length, d);\n    y.set(x);\n\n    const a = x[d0], b = x[d1];\n    y[d0] = a * r0 - b * r1;\n    y[d1] = a * r1 + b * r0;\n    return y;\n  };\n}\n","import Rotator from './rotator';\nimport Cube from './cube';\nimport { Fn, components, CompositeFn } from './fn';\nimport { TypedArray } from 'three';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Sphere implements Fn {\n  private readonly root: Float32Array;\n\n  constructor(readonly d: number, r: number) {\n    this.root = new Float32Array(d);\n    this.root[0] = r;\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * Math.PI);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { d, root } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    const r = new CompositeFn(components(d - 1).map((i) => new Rotator(d, phi[i], 0, i + 1)));\n    r.fn(root, y);\n    return y;\n  };\n}\n","import { Fn, exp, components } from './fn';\nimport Cube from './cube';\nimport Sphere from './sphere';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Spiral implements Fn {\n  private readonly sphere: Sphere;\n\n  constructor(readonly d: number, readonly a: number[], readonly k: number[]) {\n    this.sphere = new Sphere(d, 1);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 4 * Math.PI);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (phi: Float32Array, y: Vector = new Float32Array(this.d)) => {\n    const { a, k, domain, d } = this;\n    assert.equal(phi.length, d - 1);\n    assert.equal(y.length, d);\n\n    this.sphere.fn(phi, y);\n    let x = 0;\n    for (let i = 0; i < domain; i++) {\n      x += k[i] * phi[i];\n    };\n    const r = exp(x);\n    for (let i = 0; i < d; i++) {\n      y[i] = y[i] * a[i] * r;\n    }\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport Rotator from './rotator';\nimport assert from 'assert';\nimport { Vector } from '../data';\n\nexport default class Torus implements Fn {\n  private readonly cross: Sphere;\n\n  constructor(readonly d: number, readonly r: number, readonly t: number) {\n    assert(d > 2, `torus is only defined for d > 2; got ${d}`);\n    this.cross = new Sphere(d - 1, t);\n  }\n\n  get domain() {\n    return this.d - 1;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2 * Math.PI);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (theta: Vector, y: Vector = new Float32Array(this.d)) => {\n    const { cross, d, r } = this;\n    assert.equal(theta.length, d - 1, `torus expects an input of ${d - 1}; got ${theta.length}`);\n    const rotator = new Rotator(d, theta[d - 2], 0, d - 1);\n\n    cross.fn(theta.subarray(0, d - 2), y.subarray(0, d - 1));\n    y[0] += r;\n    rotator.fn(y, y);\n\n    return y;\n  };\n}\n","import Cube from './cube';\nimport Sphere from './sphere';\nimport { Fn } from './fn';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\n// This shape does not implement a torus. It used to,\n// but then I changed the way Rotator works, which\n// changed the way that the points of the sphere are\n// distributed, making the translation step behave incorrectly\n// Still makes a cool shape though, so keeping it\nexport default class FuckedUpTorus implements Fn {\n    private readonly sphere: Sphere;\n    private readonly circle: Sphere;\n\n    constructor(readonly d: number, readonly r: number, readonly t: number) {\n        this.sphere = new Sphere(d, t);\n        this.circle = new Sphere(2, r);\n    }\n\n    get domain() {\n        return this.d - 1;\n    }\n\n    sample = function* (n: number, offset: number, limit: number) {\n        const cube = new Cube(this.domain, 2 * Math.PI);\n        for (const phi of cube.sample(n, offset, limit)) {\n            yield this.fn(phi);\n        }\n    };\n\n    fn = (phi: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { domain, d, sphere, circle } = this;\n        assert.equal(phi.length, domain);\n        assert.equal(y.length, d);\n        sphere.fn(phi, y);\n        const q = circle.fn(phi.subarray(d - 2));\n        y[0] += q[0];\n        y[d - 1] += q[1];\n        return y;\n    };\n}\n","import { Fn } from './fn';\nimport Cube from './cube';\nimport { Vector } from '../data';\nimport assert from 'assert';\n\nexport default class Stereo implements Fn {\n  private readonly fromTemp: Vector;\n  private readonly toTemp: Vector;\n\n  constructor(private readonly from: number, private readonly to: number) {\n    this.fromTemp = new Float32Array(Math.max(from, to));\n    this.toTemp = new Float32Array(Math.max(from, to));\n  }\n\n  get domain() {\n    return this.from;\n  }\n\n  get d() {\n    return this.to;\n  }\n\n  sample = function* (n: number, offset: number, limit: number) {\n    const cube = new Cube(this.domain, 2);\n    for (const phi of cube.sample(n, offset, limit)) {\n      yield this.fn(phi);\n    }\n  };\n\n  fn = (x: Vector, y: Vector = new Float32Array(this.to)) => {\n    let { from, to, fromTemp, toTemp } = this;\n    assert.equal(x.length, from);\n    assert.equal(y.length, to);\n\n    if (from === to) {\n      y.set(x);\n      return y;\n    }\n\n    fromTemp.set(x);\n\n    while (from < to) {\n      Stereo.up(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, ++from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    while (from > to) {\n      Stereo.down(\n        fromTemp.subarray(0, from),\n        toTemp.subarray(0, --from)\n      );\n      fromTemp.set(toTemp);\n    }\n\n    y.set(toTemp.subarray(0, to));\n    return y;\n  };\n\n  static up = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length + 1);\n    const n2 = norm2(x);\n    const divisor = n2 + 1;\n    temp[0] = (n2 - 1) / divisor;\n    for (let i = 1; i <= x.length; i++) {\n      temp[i] = (2 * x[i - 1]) / divisor;\n    }\n  };\n\n  static down = (x: Vector, temp: Vector) => {\n    assert.equal(temp.length, x.length - 1);\n    for (let i = 0; i < temp.length; i++) {\n      temp[i] = x[i + 1] / (1 - x[0]);\n    }\n  };\n}\n\nconst norm2 = (x: Vector) => {\n  let result = 0;\n  for (let i = 0; i < x.length; i++) {\n    result += x[i] * x[i];\n  }\n  return result;\n};\n","import { Fn } from \"./fn\";\nimport Cube from \"./cube\";\nimport { Vector } from \"../data\";\nimport assert from 'assert';\n\nexport class Identity implements Fn {\n    readonly domain: number;\n\n    constructor(readonly d: number) {\n        this.domain = d;\n    }\n\n    fn = (x: Vector, y: Vector = new Float32Array(this.d)) => {\n        const { d } = this;\n        assert.equal(x.length, d);\n        assert.equal(y.length, d);\n        y.set(x);\n        return y;\n    };\n\n    sample = function* (n: number, offset: number, limit: number) {\n        throw new Error('identity function does not support sampling');\n    };\n}\n","import { Scope, UnaryOperator, Link } from './types';\nimport { Value, PipeNode, StepNode, ArithNode, Scalar, NumberNode, AccessNode, FnNode } from \"./ast\";\nimport assert from 'assert';\nimport { pp } from '../pp';\nimport { Fn, CompositeFn } from '../fn/fn';\nimport Cube from '../fn/cube';\nimport Spiral from '../fn/spiral';\nimport Torus from '../fn/torus';\nimport FuckedUpTorus from '../fn/fucked_up_torus';\nimport Sphere from '../fn/sphere';\nimport Stereo from '../fn/stereo';\nimport Rotator from '../fn/rotator';\nimport Interval from '../fn/interval';\nimport { Identity } from '../fn/identity';\n\nexport type Resolution = {\n    n: number;\n    staticFn: CompositeFn;\n    dynamicFn: CompositeFn;\n};\n\nexport class Resolver {\n    constructor(private readonly scope: Scope) { }\n\n    resolve = (node: PipeNode | Scalar, extraScope: object = {}) => {\n        switch (node.kind) {\n            case 'pipe': return this.resolvePipe(node);\n            case 'number': return node.value;\n            case 'fn': return this.resolveFn(node, extraScope);\n            case 'access': return this.resolveAccess(node, extraScope);\n            case 'id': return this.resolveIdToNumber(node.id, extraScope);\n            case 'arith': return this.resolveArith(node, extraScope);\n        }\n    };\n\n    resolvePipe = (pipe: PipeNode): Resolution => {\n        const chain = pipe.chain;\n        const links: Link[] = [];\n        const fun = chain.shift();\n        const d = (fun.args.shift() as NumberNode).value;\n        const link = this.resolveFirstStep(d, fun);\n        const n = Interval.n(link.fn.domain, pipe.n);\n\n        links.push(link);\n\n        for (let i = 0; i < chain.length; i++) {\n            const fun = chain[i];\n            const link = this.resolveStep(links[i].fn, fun);\n            links.push(link);\n        }\n\n        const [staticFn, dynamicFn] = this.buildComposites(links);\n        return { n, staticFn, dynamicFn };\n    };\n\n    private buildComposites = (links: Link[]) => {\n        let builder = new CompositeFn.Builder();\n        while (links.length && !links[0].isDynamic) {\n            builder.add(links.shift().fn);\n        }\n\n        const init = builder.build();\n        builder = new CompositeFn.Builder().add(new Identity(init.d));\n\n        while (links.length) {\n            builder.add(links.shift().fn);\n        }\n\n        const iter = builder.build();\n        return [init, iter];\n    };\n\n    private resolveFirstStep = (d: number, { type, args }: StepNode) => {\n        const fn = funs[type](d, ...args.map(a => this.resolveScalar(a)));\n        const isDynamic = args.some(isNodeDynamic);\n\n        return { fn, isDynamic };\n    };\n\n    private resolveStep = (prev: Fn, { type, args }: StepNode): Link => {\n        const d = ranges[type](prev.d);\n        const fn = funs[type](d, ...args.map(a => this.resolveScalar(a)));\n        const isDynamic = args.some(isNodeDynamic);\n\n        return { fn, isDynamic };\n    };\n\n    private resolveScalar = (arg: Scalar, extraScope: object = {}): Value => {\n        switch (arg.kind) {\n            case 'number': return arg.value;\n            case 'fn': return this.resolveFn(arg, extraScope);\n            case 'access': return this.resolveAccess(arg, extraScope);\n            case 'id': return this.resolveId(arg.id, extraScope);\n            case 'arith': return this.resolveArith(arg, extraScope);\n        }\n    };\n\n    private resolveFn = ({ name, args }: FnNode, extraScope: object): number => {\n        const fn = Math[name];\n        assert(typeof fn === 'function', `Expected ${name} to be a Math function in ${pp({ name, args })}`);\n        return fn(...args.map(a => this.resolveScalar(a, extraScope)));\n    };\n\n    private resolveAccess = ({ id, index }: AccessNode, extraScope: object): number => {\n        const scope = { ...this.scope, ...extraScope };\n        const target = scope[id];\n        assert(target, `Unable to resolve ${id} in scope ${pp(scope, 2)}`);\n        return target[this.resolveScalar(index, extraScope) as number];\n    };\n\n    private resolveId = (id: string, extraScope: object): Value => {\n        if (id in Math && typeof Math[id] === 'function') {\n            return Math[id];\n        } else {\n            return this.resolveIdToNumber(id, extraScope);\n        }\n    };\n\n    private resolveIdToNumber = (id: string, extraScope: object): number => {\n        const idu = id.toUpperCase();\n        if (id in extraScope) {\n            return extraScope[id];\n        } else if (id in this.scope) {\n            return this.scope[id];\n        } else if (idu in Math && typeof Math[idu] === 'number') {\n            return Math[idu];\n        } else {\n            assert.fail(`unable to resolve id ${id} in scope ${pp({ ...this.scope, ...extraScope }, 2)}`);\n        }\n    };\n\n    private resolveArith = ({ op, operands }: ArithNode, extraScope: object) => {\n        const [a, b] = operands.map(a => this.resolveScalar(a, extraScope));\n        if (typeof a === 'number' && typeof b === 'number') {\n            return ops[op](a, b);\n        }\n        assert.fail(`One or more arithmetic operands evaluate to a non-number in ${pp({ op, operands }, 2)}`);\n\n    };\n}\n\nconst isNodeDynamic = (node: Scalar): boolean => {\n    switch (node.kind) {\n        case 'fn': return node.args.some(isNodeDynamic);\n        case 'id': return ['t', 'power', 'chroma', 'onset'].includes(node.id);\n        case 'arith': return node.operands.some(isNodeDynamic);\n        default: return false;\n    }\n};\n\nconst ops: {\n    [op: string]: (a: number, b: number) => number;\n} = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '*': (a, b) => a * b,\n    '/': (a, b) => a / b,\n    '**': (a, b) => a ** b,\n    '^': (a, b) => a ** b,\n};\n\nconst rotate = (\n    d: number,\n    theta: number,\n    d0: number,\n    d1: number,\n    f0: UnaryOperator = Math.cos,\n    f1: UnaryOperator = Math.sin,\n) => {\n    return new Rotator(d, theta, d0, d1, f0, f1);\n};\n\nconst funs: {\n    [op: string]: (d: number, ...rest) => Fn;\n} = {\n    cube: (d, l) => new Cube(d, l),\n    sphere: (d, r: number) => new Sphere(d, r),\n    spiral: (d, a: number, k: number) =>\n        new Spiral(d, new Array(d).fill(a), new Array(d - 1).fill(k)),\n    torus: (d, r: number, t: number) => new Torus(d, r, t),\n    fucked_up_torus: (d, r: number, t: number) =>\n        new FuckedUpTorus(d, r, t),\n    rotate,\n    r: rotate,\n    stereo: (d, to) => new Stereo(d, to),\n};\n\ntype Funs = typeof funs;\n\ntype Ranges = {\n    [P in keyof Funs]: (domain: number) => number;\n};\n\nconst ranges: Ranges = {\n    cube: (domain) => domain,\n    sphere: (domain) => domain + 1,\n    spiral: (domain) => domain + 1,\n    torus: (domain) => domain + 1,\n    fucked_up_torus: (domain) => domain + 1,\n    rotate: (domain) => domain,\n    r: (domain) => domain,\n    stereo: (domain) => domain,\n};\n","module.exports = __webpack_public_path__ + \"0.d7220a31fa7b138fbaff.worker.js\"","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { pipe: peg$parsepipe, arith: peg$parsearith },\n      peg$startRuleFunction  = peg$parsepipe,\n\n      peg$c0 = function(n, chain) {\n        return {kind: 'pipe', n: parseInt(n), chain};\n      },\n      peg$c1 = function(head, tail) { return [head, ...tail]; },\n      peg$c2 = function(f) { return [f]; },\n      peg$c3 = function(type, args) {\n          return {kind: 'step', type: type.toLowerCase(), args};\n        },\n      peg$c4 = function(arg) { return [arg]; },\n      peg$c5 = function(s, op, a) {\n           return {kind: 'arith', op, operands: [s, a]};\n        },\n      peg$c6 = function(value) { return {kind: 'number', value}; },\n      peg$c7 = function(name, args) {\n          return {kind: 'fn', name: name.toLowerCase(), args};\n        },\n      peg$c8 = \"[\",\n      peg$c9 = peg$literalExpectation(\"[\", false),\n      peg$c10 = \"]\",\n      peg$c11 = peg$literalExpectation(\"]\", false),\n      peg$c12 = function(id, index) { return {kind: 'access', id, index}; },\n      peg$c13 = function(id) { return {kind: 'id', id: id.toLowerCase()}; },\n      peg$c14 = function(a) { return a; },\n      peg$c15 = function(f) { return parseFloat(f); },\n      peg$c16 = function(i) { return parseInt(i); },\n      peg$c17 = /^[a-zA-Z]/,\n      peg$c18 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n      peg$c19 = /^[a-zA-Z0-9]/,\n      peg$c20 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n      peg$c21 = function(id) { return id; },\n      peg$c22 = /^[+\\-]/,\n      peg$c23 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c24 = /^[0-9]/,\n      peg$c25 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c26 = /^[eE]/,\n      peg$c27 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c28 = \".\",\n      peg$c29 = peg$literalExpectation(\".\", false),\n      peg$c30 = \"+\",\n      peg$c31 = peg$literalExpectation(\"+\", false),\n      peg$c32 = \"-\",\n      peg$c33 = peg$literalExpectation(\"-\", false),\n      peg$c34 = \"*\",\n      peg$c35 = peg$literalExpectation(\"*\", false),\n      peg$c36 = \"/\",\n      peg$c37 = peg$literalExpectation(\"/\", false),\n      peg$c38 = \"**\",\n      peg$c39 = peg$literalExpectation(\"**\", false),\n      peg$c40 = \"^\",\n      peg$c41 = peg$literalExpectation(\"^\", false),\n      peg$c42 = function(op) { return op; },\n      peg$c43 = \"(\",\n      peg$c44 = peg$literalExpectation(\"(\", false),\n      peg$c45 = \")\",\n      peg$c46 = peg$literalExpectation(\")\", false),\n      peg$c47 = \",\",\n      peg$c48 = peg$literalExpectation(\",\", false),\n      peg$c49 = \"->\",\n      peg$c50 = peg$literalExpectation(\"->\", false),\n      peg$c51 = \"=>\",\n      peg$c52 = peg$literalExpectation(\"=>\", false),\n      peg$c53 = /^[ \\t\\n\\r]/,\n      peg$c54 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepipe() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseuint();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsechain() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestep();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepipe_sep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechain();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestep();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestep() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselparen();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestep_args();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserparen();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestep_args() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsearith();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestep_args();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsearith();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsescalar();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsearith_op();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsearith();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c5(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsescalar();\n    }\n\n    return s0;\n  }\n\n  function peg$parsescalar() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c6(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseidentifier();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselparen();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefn_args();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parserparen();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c7(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseidentifier();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s2 = peg$c8;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c9); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsescalar();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s4 = peg$c10;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c11); }\n              }\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c12(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseidentifier();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1);\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parselparen();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsearith();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parserparen();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c14(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefn_args() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsearith();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefn_args();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsearith();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefloat();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseint();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c16(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = [];\n        if (peg$c19.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c20); }\n        }\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          if (peg$c19.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c20); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c21(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloat() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c22.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c24.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsemantissa();\n        if (s4 !== peg$FAILED) {\n          if (peg$c26.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c27); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseint();\n            if (s6 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5, s6];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseint();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemantissa();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseint() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c22.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseuint() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c24.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c25); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c24.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c25); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemantissa() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c28;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseuint();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsearith_op() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s3 = peg$c30;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s3 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s3 = peg$c32;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c33); }\n        }\n        if (s3 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s3 = peg$c34;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c35); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c36;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s3 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c38) {\n                s3 = peg$c38;\n                peg$currPos += 2;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c39); }\n              }\n              if (s3 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 94) {\n                  s3 = peg$c40;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c41); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c42(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c43;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserparen() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 41) {\n        s2 = peg$c45;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c46); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c47;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepipe_sep() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c49) {\n        s3 = peg$c49;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c51) {\n            s3 = peg$c51;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c53.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c54); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c53.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c54); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c53.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c54); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c53.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","import { parse } from './grammar.pegjs';\nimport { PipeNode, ArithNode } from \"./ast\";\nimport { pp } from '../pp';\nimport { getLogger } from 'loglevel';\n\nconst logger = getLogger('Parser');\nlogger.setDefaultLevel('info');\n\ntype Options = {\n    startRule: 'arith';\n};\n\nconst loggingParse: typeof parse = <T>(expr: string, options?: Options): T => {\n    try {\n        const node = parse(expr, options);\n        logger.debug(`parsed ${expr} into node ${pp(node)}`);\n        return node;\n    } catch (err) {\n        logger.error(`error parsing ${expr} at ${pp(err.location)}: ${err.message}`);\n        throw err;\n    }\n};\n\nexport class Parser {\n    static parsePipe = (pipe: string): PipeNode => loggingParse(pipe);\n\n    static parseArith = (expr: string): ArithNode => loggingParse(expr, { startRule: 'arith' });\n}\n","import { NormalizedParams } from './types';\nimport { Parser } from './parser';\nimport { PipeNode, ArithNode, Scalar, StepNode, FnNode, IdNode, AccessNode } from './ast';\n\nexport class Compiler {\n    private readonly simplifier: Simplifier;\n\n    constructor(params: NormalizedParams) {\n        this.simplifier = new Simplifier({\n            theta: Parser.parseArith(params.theta),\n        });\n    }\n\n    compilePipe = (expr: string): PipeNode => {\n        const ast = Parser.parsePipe(expr);\n        return this.simplifier.simplify(ast);\n    };\n\n    compileArith = (expr: string): ArithNode => {\n        const ast = Parser.parseArith(expr);\n        return this.simplifier.simplifyArithNode(ast);\n    };\n}\n\ntype Substitutions = {\n    [id: string]: Scalar;\n};\n\nexport class Simplifier {\n    constructor(private readonly substitutions: Substitutions) { }\n\n    simplify = (pipe: PipeNode): PipeNode => {\n        const n = pipe.n;\n        const chain = pipe.chain;\n\n        return {\n            kind: pipe.kind,\n            n,\n            chain: chain.map(this.simplifyStepNode),\n        };\n    };\n\n    simplifyArithNode = ({ kind, op, operands }: ArithNode): ArithNode => {\n        const [a, b] = operands.map(this.simplifyScalar);\n        return { kind, op, operands: [a, b] };\n    };\n\n    private simplifyStepNode = ({ kind, type: fn, args }: StepNode): StepNode => {\n        return {\n            kind,\n            type: fn,\n            args: args.map(this.simplifyScalar),\n        };\n    };\n\n    private simplifyScalar = (node: Scalar): Scalar => {\n        switch (node.kind) {\n            case 'number': return node;\n            case 'fn': return this.simplifyFnNode(node);\n            case 'access': return this.simplifyAccessNode(node);\n            case 'id': return this.simplifyIdNode(node);\n            case 'arith': return this.simplifyArithNode(node);\n        }\n    };\n\n    private simplifyFnNode = ({ kind, name, args }: FnNode): FnNode => {\n        return {\n            kind,\n            name,\n            args: args.map(this.simplifyIdNode),\n        };\n    };\n\n    private simplifyAccessNode = ({ kind, id, index }: AccessNode): AccessNode => {\n        return { kind, id, index: this.simplifyScalar(index) };\n    };\n\n    private simplifyIdNode = (node: IdNode): Scalar => {\n        const { id } = node;\n        if (id in this.substitutions) {\n            return this.simplifyScalar(this.substitutions[id]);\n        } else {\n            return node;\n        }\n    };\n}\n","import { CompositeFn } from \"../fn/fn\";\nimport { Scope, HV, Chunk } from \"./types\";\nimport { Data, Vector } from \"../data\";\nimport { pp } from \"../pp\";\nimport { getLogger } from \"loglevel\";\nimport assert from 'assert';\nimport { Color } from \"three\";\nimport { hsv } from 'color-convert';\nimport { Resolver, Resolution } from \"./resolver\";\nimport { PipeNode } from \"./ast\";\n\nconst logger = getLogger('Evaluator');\n\nexport class Evaluator {\n    private readonly n: number;\n    private readonly staticFn: CompositeFn;\n    private readonly dynaicFn: CompositeFn;\n    private readonly offset: number;\n    private readonly limit: number;\n    private readonly resolver: Resolver;\n\n    constructor(\n        private readonly scope: Scope,\n        ast: PipeNode,\n        private readonly hv: HV,\n        chunk: Chunk,\n    ) {\n        const resolver = new Resolver(scope);\n        const { n, staticFn, dynamicFn } = resolver.resolve(ast) as Resolution;\n        const offset = chunk.offset;\n        const size = chunk.size;\n        const limit = offset + size;\n        assert(offset >= 0, `offset must be non-negative; got ${offset}`);\n        assert(limit <= n, `offset + size must be <= n; got ${offset} + ${size} = ${limit} > ${n}`);\n\n        this.n = n;\n        this.staticFn = staticFn;\n        this.dynaicFn = dynamicFn;\n        this.offset = offset;\n        this.limit = limit;\n        this.resolver = resolver;\n    }\n\n\n    private get d() {\n        return this.dynaicFn.d;\n    }\n\n    initialize = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { n, staticFn: init, offset, limit } = this;\n        const input = Data.input(data);\n        let i = offset;\n        for (const y of init.sample(n, offset, limit)) {\n            Data.set(input, y, i++, init.d);\n        }\n    };\n\n    iterate = (buffer: SharedArrayBuffer): void => {\n        const data = new Float32Array(buffer);\n        const { staticFn: init, dynaicFn: iter, scope, n, offset, limit } = this;\n        const input = Data.input(data);\n        const position = Data.position(data);\n        const start = Date.now();\n\n        assert.equal(data[Data.nOffset], n, `n(data) != n(evaluator)`);\n        assert.equal(data[Data.inputOffset], init.d, `d0(data) != d0(evaluator)`);\n        assert.equal(data[Data.positionOffset(data)], iter.d, 'd(data) != d(evaluator)');\n\n        logger.debug(`iterating using ${pp(scope)}, ${pp(iter)}`);\n        for (let i = offset; i < limit; i++) {\n            iter.fn(Data.get(input, i, init.d), Data.get(position, i, iter.d));\n        }\n\n        this.computeColors(data);\n\n        logger.debug(`iteration complete in ${Date.now() - start}ms`);\n    };\n\n    private computeColors = (data: Vector) => {\n        logger.debug(`computing colors`);\n        const { d, hv, offset, limit, resolver } = this;\n        const position = Data.position(data);\n        const color = Data.color(data);\n\n        for (let i = offset; i < limit; i++) {\n            const p = Data.get(position, i, d);\n            const [h, s, l] = hsv.hsl([\n                Math.round(resolver.resolve(hv.h, { p, i }) as number),\n                100,\n                Math.round(resolver.resolve(hv.v, { p, i }) as number),\n            ]);\n            const c = new Color(`hsl(${h}, ${s}%, ${l}%)`);\n\n            Data.set(color, [c.r, c.g, c.b], i, 3);\n        }\n\n    };\n}\n","import { getLogger } from 'loglevel';\nimport { Params, NormalizedParams, HV, Chunk } from './types';\nimport { Compiler } from './compiler';\nimport { Evaluator } from './evaluator';\nimport { PipeNode } from './ast';\nimport { inf } from '../constants';\n\nconst logger = getLogger('Pipe');\nlogger.setLevel('info');\n\nexport class Pipe {\n    static compile = (params: Params): PipeNode => {\n        return new Compiler(Pipe.normalized(params)).compilePipe(params.pipe);\n    };\n\n    static evaluatorFor = (params: Params, chunk?: Chunk) => {\n        return Pipe.evaluatorForNormal(Pipe.normalized(params), chunk);\n    };\n\n    static scopeFor = (params: Params, n: number) => {\n        return Pipe.scopeForNormal(Pipe.normalized(params), n);\n    };\n\n    private static evaluatorForNormal = (params: NormalizedParams, chunk?: Chunk) => {\n        const compiler = new Compiler(params);\n        const ast = compiler.compilePipe(params.pipe);\n        const hv = Pipe.compileHV(params, compiler);\n        return new Evaluator(Pipe.scopeForNormal(params, ast.n), ast, hv, chunk);\n    };\n\n    private static normalized = (params: Params): NormalizedParams => {\n        return {\n            pipe: params.pipe,\n            theta: params.theta || 't',\n            h: params.h || '1',\n            v: params.v || '0.5',\n            t: params.t || 0,\n            power: params.power || 0,\n            chroma: params.chroma || 0,\n            onset: params.onset || 0,\n        };\n    };\n\n    private static scopeForNormal = (params: NormalizedParams, n: number) => {\n        const { power, t, chroma, onset } = params;\n        return { t, power, chroma, n, inf, onset };\n    };\n\n    private static compileHV = (params: NormalizedParams, compiler: Compiler): HV => {\n        return {\n            h: compiler.compileArith(`359 * (${params.h})`),\n            v: compiler.compileArith(`100 * (${params.v})`),\n        };\n    };\n}\n","import {\n  PerspectiveCamera,\n  BufferGeometry,\n  BufferAttribute,\n  Points,\n  PointsMaterial,\n  WebGLRenderer,\n  VertexColors,\n  Scene,\n} from 'three';\nimport { Data } from '../core/data';\nimport assert from 'assert';\n\nclass Renderer {\n  private renderer: WebGLRenderer;\n  private scene: Scene;\n  private camera: PerspectiveCamera;\n  private points: Points;\n  private z = 5;\n\n  constructor() {\n    this.renderer = new WebGLRenderer();\n    this.setSize();\n    window.onresize = () => {\n      this.setSize();\n      requestAnimationFrame(this.render);\n    };\n\n    this.points = new Points(\n      new BufferGeometry(),\n      new PointsMaterial({\n        vertexColors: VertexColors,\n        size: 0.001,\n      })\n    );\n\n    this.scene = new Scene();\n    this.scene.add(this.points);\n  }\n\n  private setSize = () => {\n    const near = 0.01, far = 1000;\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const aspect = width / height;\n    const fov = 100;\n\n    this.renderer.setSize(width, height);\n    this.camera = new PerspectiveCamera(fov, aspect, near, far);\n    this.camera.position.z = this.z;\n  };\n\n  get domElement() {\n    return this.renderer.domElement;\n  }\n\n  render = () => {\n    this.renderer.render(this.scene, this.camera);\n  };\n\n  update = ({ d, position, color }: Data) => {\n    const { points } = this;\n    const geometry = points.geometry as BufferGeometry;\n    assert.equal(position.length % d, 0);\n    assert.equal(color.length % 3, 0);\n\n    position.forEach((p, i) => {\n      if (isNaN(p)) {\n        console.warn(`found NaN value at index ${i}`);\n      }\n    });\n\n    geometry.setAttribute('position', new BufferAttribute(position, d));\n    geometry.setAttribute('color', new BufferAttribute(color, 3));\n\n    let z = 5;\n    if (d > 2) {\n      geometry.computeBoundingSphere();\n      const s = geometry.boundingSphere;\n      z = Math.min(5, s.center.z + s.radius + 1);\n    }\n    this.camera.position.z = this.z = z;\n\n    requestAnimationFrame(this.render);\n  };\n}\n\nexport const renderer = new Renderer();\n"],"sourceRoot":""}